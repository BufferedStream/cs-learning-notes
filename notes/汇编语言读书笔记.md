## 汇编语言读书笔记

### 第 1 章	基础知识

汇编语言是直接在硬件之上工作的编程语言，我们首先要了解硬件系统的结构，才能有效地应用汇编语言对其编程。



#### 1.1 机器语言

机器语言是机器指令的集合。机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一列二进制数字。计算机将之转变为一列高低电平，以使计算机的电子器件受到驱动，进行运算。

上面所说的计算机指的是可以执行机器指令，进行运算的机器。在我们常用的 PC 机中，有一个芯片来完成上面所说的计算机的功能。这个芯片就是我们常说的 CPU（Central Processing Unit，中央处理单元），CPU 是一种微处理器。以后我们提到的计算机是指由 CPU 和其他受 CPU 直接或间接控制的芯片、器件、设备组成的计算机系统，比如我们最常见的 PC 机。

每一种微处理器，由于硬件设计和内部结构的不同，就需要用不同的电平脉冲来控制，使它工作。所以每一种微处理器都有自己的机器指令集，也就是机器语言。



#### 1.2 汇编语言的产生

由于机器语言的晦涩难懂和不易查错，给整个产业的发展带来了障碍，汇编语言产生了。

汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令是机器指令便于记忆的书写格式。如下例所示：

操作：寄存器 BX 的内容送到 AX 中

机器指令：1000100111011000

汇编指令：mov ax,bx



寄存器，简单地讲是 CPU 中可以存储数据的器件，一个 CPU 中有多个寄存器。AX 和 bX 是寄存器的代号。

我们需要编译器将汇编语言解读成计算机能读懂的机器指令。图 1.1 描述了这个工作过程。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE5.jpg"/> </div><br>
#### 1.3 汇编语言的组成

汇编语言有以下 3 类指令组成。

（1）汇编指令：机器码的助记符，有对应的机器码。

（2）伪指令：没有对应的机器码，由编译器执行，计算机并不执行。

（3）其他符号：如 +、-、*、/ 等，由编译器识别，没有对应的机器码。

汇编语言的核心是汇编指令，它决定了汇编语言的特性。



#### 1.4 存储器

CPU 是计算机的核心部件，它控制整个计算机的运作并进行运算。要想让一个 CPU 工作，就必须向它提供指令和数据。指令和数据在存储器中存放，也就是我们平时所说的内存。磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被 CPU 使用。要灵活地利用汇编语言编程，我们首先要了解 CPU 是如何从内存中读取信息，以及向内存中写入信息的。



#### 1.5 指令和数据

指令和数据是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。CPU 在工作的时候把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。

例如，内存中的二进制信息 1000100111011000，计算机可以把它看作大小为 89D8H 的数据来处理，也可以将其看作指令 mov ax,bx 来执行。

```assembly
1000100111011000 ——> 89D8H（数据）
1000100111011000 ——> mov ax,bx（程序）
```



#### 1.6 存储单元

存储器被划分成若干个存储单元，每个存储单元从 0 开始顺序编号，例如一个存储器有 128 个存储单元，编号从 0~127，如图 1.2 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE1.jpg"/> </div><br>
那么一个存储单元能存储多少信息呢？我们知道电子计算机的最小信息单位是 bit（音译为比特），也就是一个二进制位。8 个 bit 组成一个 Byte，也就是通常讲的一个字节。微型机存储器的存储单元可以存储一个 Byte，即 8 个二进制位。一个存储器有 128 个存储单元，它可以存储 128 个 Byte。

微机存储器的容量是以字节为最小单位来计算的。对于拥有 128 个存储单元的存储器，我们可以说，它的容量是 128 个字节。

对于大容量的存储器一般还用以下单位来计量容量（以下用 B 来代表 Byte）

1KB=1024B	1MB=1024KB	1GB=1024MB	1TB=1024GB

磁盘的容量单位同内存的一样，实际上以上单位是微机中常用的计量单位。



#### 1.7 CPU 对存储器的读写

CPU 要从内存中读数据，首先要指定存储单元的地址。另外，在一台微机中，不止有存储器这一种器件。CPU 在读写时还要指明，它要对哪一个器件进行操作，进行哪种操作，是从中读出数据，还是向里面写入数据。

可见，CPU 要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行下面 3 类信息的交互。

- 存储单元的地址（地址信息）；
- 器件的选择，读或写的命令（控制信息）；
- 读或写的数据（数据信息）。

那么 CPU 是通过什么将地址、数据和控制信息传到存储器芯片中的呢？电子计算机能处理、传输的信息都是电信号，电信号当然要用导线传送。在计算机中专门有连接 CPU 和其他芯片的导线，通常称为总线。总线从物理上来讲，就是一根根导线的集合。根据传送信息的不同，总线从逻辑上又分为 3 类，地址总线、控制总线和数据总线。

CPU 从 3 号单元中读取数据的过程（见图 1.3）如下。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE2.jpg"/> </div><br>
（1）CPU 通过地址线将地址信息 3 发出。

（2）CPU 通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。

（3）存储器将 3 号单元中的数据 8 通过数据线送入 CPU。



对于 8086CPU，下面的机器码，能够完成从 3 号单元读数据。

机器码：	101000010000001100000000

含义：		从 3 号单元读取数据送入寄存器 AX

CPU 接收这条机器码后将完成我们上面所述的读写工作。

机器码难于记忆，用汇编指令来表示，情况如下。

机器码：	10100001 00000011 00000000

对应的汇编指令：MOV AX,[3]

含义：		传送 3 号单元的内容入 AX



#### 1.8 地址总线

现在我们知道，CPU 是通过地址总线来指定存储器多纳伊的。可见地址总线上能传送多少个不同的信息，CPU 就可以对多少个存储单元进行寻址。

现假设，一个 CPU 有 10 根地址总线，让我们来看一下它的寻址情况。我们知道，在电子计算机中，一根导线可以传送的稳定状态只有两种，高电平或是低电平。用二进制表示就是 1 或 0，10 根导线可以传送 10 位二进制数据。而 10 位二进制数可以表示多少个不同的数据呢？2 的 10 次方个。最小数为 0，最大数为 1023。

一个 CPU 有 N 根地址线，则可以说这个 CPU 的地址总线的宽度为 N。这样的 CPU 最多可以寻找 2 的 N 次方个内存单元。



#### 1.9 数据总线

CPU 与内存或其他器件之间的数据传送是通过数据总线来进行的。数据总线的宽度决定了 CPU 和外界的数据传送速度。8 根数据总线一次可传送一个 8 位二进制数据（即一个字节）。16 根数据总线一次可传送两个字节。

8088CPU 的数据总线宽度为 8，8086CPU 的数据总线宽度为 16。我们来分别看一下它们向内存中写入数据 89D8H 时，是如何通过数据总线传送数据的。图 1.5 展示了 8088CPU 数据总线上的数据传送情况；图 1.6 展示了 8086CPU 数据总线上的数据传送情况。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE3.jpg"/> </div><br>
<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE4.jpg"/> </div><br>
8086 有 16 根数据线，可一次传送16 位数据，所以可一次传送数据 89D8H；而 8088 只有 8 根数据线，一次只能传 8 位数据，所以向内存写入数据 89D8H 时需要进行两次数据传送。



#### 1.10 控制总线

CPU 对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。所以，控制总线的宽度决定了 CPU 对外部器件的控制能力。

前面所讲的内容读或写命令是由几根控制线综合发出的，其中有一根称为 “读信号输出” 的控制线负责由 CPU 向外传送读信号，CPU 向该控制线上输出低电平表示将要读取数据；有一根称为 “写信号输出” 的控制线则负责传送写信号。



#### 1.1~1.10 小结

（1）汇编指令是机器指令的助记符，同机器指令一一对应。

（2）每一种 CPU 都有自己的汇编指令集。

（3）CPU 可以直接使用的信息在存储器中存放。

（4）在存储器中指令和数据没有任何区别，都是二进制信息。

（5）存储单元从零开始顺序编号。

（6）一个存储单元可以存储 8 个 bit，即 8 位二进制数。

（7）1KB=1024B	1MB=1024KB	1GB=1024MB	1TB=1024GB

（8）每一个 CPU 芯片都有许多管脚，这些管脚和总线相连。也可以说，这些管脚引出总线。一个 CPU 可以引出 3 种总线的宽度标志了这个 CPU 的不同方面的性能：

​	地址总线的宽度决定了 CPU 的寻址能力；

​	数据总线的宽度决定了 CPU 与其他器件进行数据传送时的一次数据传送量；

​	控制总线的宽度决定了 CPU 对系统中其他器件的控制能力。



#### 监测点 1.1

1. 1 个 CPU 的寻址能力为 8KB，那么它的地址总线的宽度为____。
   **13**
   解析：CPU 在内存中寻址的最小单位是 Byte（字节），8KB = 2^13^ B，因此地址总线的宽度为 13。
2. 1KB 的存储器有____个存储单元。存储单元的编号从____到____。
   **1024 0 1023**
3. 1KB 的存储器可以存储____个 bit，____个 Byte。
   **2^13^ 2^10^**
4. 1GB、1MB、1KB分别是____________Byte
   **2^30^ 2^20^ 2^10^**
5. 8080、8088、80286、80386 的地址总线宽度分别为 16 根、20 根、24 根、32 根，则他们的寻址能力分别为____（KB）、____（MB）、____（MB）、____（GB）。
   **64 1 16 4**
6. 8080、8088、8086、80286、80386 的数据总线宽度分别为 8 根、8 根、16 根、16 根、32 根。则它们一次可以传送的数据为：____（B）、____（B）、____（B）、____（B）、____（B）。
   **1 1 2 2 4**
7. 从内存中读取 1024 字节的数据，8086 至少要读取____次，80386 至少要读取____次。
   **512 256**
8. 在存储器中，数据和程序以____形式存放。
   **二进制**





#### 1.11	内存地址空间（概述）

什么是内存地址空间呢？举例来讲，一个 CPU 的地址总线宽度为 10，那么可以寻址 1024 个内存单元，这 1024 个可寻到的内存单元就构成这个 CPU 的内存地址空间。下面进行深入讨论。首先需要介绍两部分基本知识，主板和接口卡。



#### 1.12	主	板

在每一台 PC 机中，都有一个主板，主板上有核心器件和一些主要器件，这些器件通过总线（地址总线、数据总线、控制总线）相连。这些器件有 CPU、存储器、外围芯片组、扩展插槽等。扩展插槽上一般插有 RAM 内存条和各类接口卡。



#### 1.13	接	口	卡

计算机系统中，所有可用程序控制其工作的设备，必须受到 CPU 的控制。CPU 对外部设备都不能直接控制，如显示器、音箱、打印机等。直接控制这些设备进行工作的是插在扩展插槽上的接口卡。扩展插槽通过总线和 CPU 相连，所以接口卡也通过总线同 CPU 相连。CPU 可以直接控制这些接口卡，从而实现 CPU 对外设的间接控制。简单地讲，就是 CPU 通过总线向接口卡发送命令，接口卡根据 CPU 的命令控制外设进行工作。



#### 1.14	各类存储器芯片

一台 PC 机中，装有多个存储器芯片，这些存储器芯片从物理连接上看是独立的、不同的器件。从读写属性上看分为两类：随机存储器（RAM）和只读存储器（ROM）。随机存储器可读可写，但必须带电存储，关机后存储的内容丢失；只读存储器只能读取不能写入，关机后其中的内容不丢失。这些存储器从功能和连接上又可以分为以下几类。

- 随机存储器

  用于存放供 CPU 使用的绝大部分程序和数据，主随机存储器一般由两个位置上的 RAM 组成，装在主板上 RAM 和插在扩展插槽上的 RAM。

- 装有 BIOS（Basic Input/Output System，基本输入/输出系统）的 ROM

   BIOS 是由主板和各类接口卡（如显卡、网卡等）厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应 BIOS 的 ROM。例如，主板上的 ROM 中存储着主板的 BIOS（通常称为系统 BIOS）；显卡上的 ROM 中存储着显卡的 BIOS；如果网卡上装有 ROM，那其中就可以存储网卡的 BIOS。

- 接口卡上的 RAM

   某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有 RAM。最典型的是显示卡上的 RAM，一般称为显存。显示卡随时将显存中的数据向显示器上输出。换句话说，我们将需要显示的内容写入显存，就会出现在显示器上。

   

图 1.7 展示了 PC 系统中各类存储器的逻辑连接情况。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE6.jpg"/> </div><br>
#### 1.15	内存地址空间

上述的那些存储器，在物理上是独立的器件，但是在以下两点上相同。

- 都和 CPU 的总线相连。
- CPU 对它们进行读或写的时候，都通过控制线发出内存读写命令。

这也就是说，CPU 在操控它们的时候，把它们都当作内存来对待，把它们总的看作一个由若干存储单元组成的**逻辑存储器**，这个逻辑存储器就是我们所说的内存地址空间。在汇编这门课中，我们所面对的是内存地址空间。

图 1.8 展示了 CPU 将系统中各类存储器看作一个逻辑存储器的情况。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE7.jpg"/> </div><br>
在图 1.8 中，所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU 在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。

假设，图 1.8 中的内存地址空间的地址段分配如下：

地址 0~7FFFH 的 32KB 为主随机存储器的地址空间；

地址 8000H~9FFFH 的 8KB 空间为显存地址空间；

地址 A000H~FFFF 的 24KB 空间为各个 ROM 的地址空间。

 这样，CPU 向内存地址为 1000H 的内存单元中写入数据，这个数据就会被写入主随机存储器中。CPU 向内存地址为 8000H 的内存单元中写入数据，这个数据就被写入到显存中，然后会被显卡输出到显示器上。CPU 向内存地址为 C000H 的内存单元中写入数据的操作，是没有任何结果的。C000H 单元中的内容不会被改变，C000H 单元实际上就是 ROM 存储器中的一个单元。

内存地址空间的大小受 CPU 地址总线宽度的限制。8086CPU 的地址总线宽度为 20，可以传送 2^20^ 个不同的地址信息（大小从 0 至 2^20^ - 1）。即可以定位 2^20^ 个内存单元，则 8086PC 的内存地址空间大小为 1MB。同理，80386CPU 的地址空间宽度为 32，则内存地址空间最大为 4GB。

我们在基于一个计算机硬件系统编程的时候，必须知道这个系统中的内存地址空间分配情况。因为当我们想在某类存储器中读写数据的时候，必须知道它的第一个单元的地址和最后一个单元的地址，才能保证读写操作是在预期的存储器中进行。比如，我们希望向显示器输出一段信息，那么必须将这段信息写到显存中，显卡才能将它输出到显示器上，要向显存中写入数据，必须知道显存在内存地址空间中的地址。

不同的计算机系统的内存地址空间的分配情况是不同的，图 1.9 展示了 8086PC 机内存地址空间分配的基本情况。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE8.jpg"/> </div><br>
图 1.9 告诉我们，从地址 0 ~ 9FFFF 的内存单元中读取数据，实际上就是在读取主随机存储器中的数据；向地址 A0000 ~ BFFFF 的内存单元中写数据，就是向显存中写入数据，这些数据会被显示卡输出到显示器上；我们向地址 C0000 ~ FFFFF 的内存单元中写入数据的操作是无效的，因为这等于改写只读存储器中的内容。

最终运行程序的是 CPU，我们用汇编语言编程的时候，必须要从 CPU 的角度考虑问题。对 CPU 来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受 CPU 寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。

https://docs.qq.com/sheet/DREhUSENWaWtGRWp3?tab=j37kf8&c=K37B0M0



### 第 2 章	寄存器

一个典型的 CPU 由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。前一章所说的总线，相对于 CPU 内部来说是外部总线。内部总线实现 CPU 内部各个器件之间的联系，外部总线实现 CPU 和主板上其他器件的联系。简单地说，在 CPU 中：

- 运算器进行信息处理；
- 寄存器进行信息存储；
- 控制器控制各种器件进行工作；
- 内部总线连接各种器件，在它们之间进行数据的传送。

对于一个汇编程序员来说，CPU 中的主要部件是寄存器。寄存器是 CPU 中程序员可以用指令读写的部件。程序员通过改变各种寄存器中的内容来实现对 CPU 的控制。

不同的 CPU，寄存器的个数、结构是不相同的。8086CPU 有 14 个寄存器，每个寄存器都有一个名称。这些寄存器是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。



AH&AL = AX（accumulator）：累加寄存器

BH&BL = BX（base）：基址寄存器

CH&CL = CX（count）：计数寄存器

DH&DL = DX（data）：数据寄存器

SP（Stack Pointer）：堆栈指针寄存器

BP（Base Pointer）：基址指针寄存器

SI（Source Index）：源变址寄存器

DI（Destination Index）：目的变址寄存器

IP（Instruction Pointer）：指令指针寄存器

CS（Code Segment）：代码段寄存器

DS（Data Segment）：数据段寄存器

SS（Stack Segment）：堆栈寄存器

ES（Extra Segment）：附加段寄存器 OF





#### 2.1	通用寄存器

8086CPU 的所有寄存器都是 16 位的，可以存放两个字节。AX、BX、CX、DX 这 4 个寄存器通常用来存放一般性的数据，被称为通用寄存器。

以 AX 为例，寄存器的逻辑结构如图 2.1 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE9.jpg"/> </div><br>
8086CPU 的上一代 CPU 中的寄存器都是 8 位的，为了保证兼容，使原来基于上代 CPU 编写的程序稍加修改就可以运行在 8086 之上，8086CPU 的 AX、BX、CX、DX 这 4 个寄存器都可分为可独立使用的 8 位寄存器来用：

- AX 可分为 AH 和 AL；

- BX 可分为 BH 和 BL；

- CX 可分为 CH 和 CL；

- DX 可分为 DH 和 DL。

  

以 AX 为例，8086CPU 的 16 位寄存器分为两个 8 位寄存器的情况如图 2.3 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE10.jpg"/> </div><br>
AX 的低 8 位（0 位 ~ 7 位）构成了 AL 寄存器，高 8 位（8 位 ~ 15 位）构成了 AH 寄存器。AH 和 AL 寄存器是可以独立使用的 8 位寄存器。图 2.4 展示了 16 位寄存器及它所分成的两个 8 位寄存器的数据存储的情况。

一个 16 位寄存器可以存储的数据最大值为 65535，一个 8 位寄存器可以存储的数据最大值为 255。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE11.jpg"/> </div><br>
#### 2.2	字在寄存器中的存储

出于对兼容性的考虑，8086CPU 可以一次性处理以下两种尺寸的数据。

- 字节：记为 byte，一个字节由 8 个 bit 组成，可以存在 8 位寄存器中。
- 字：记为 word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节，如图 2.5 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE12.jpg"/> </div><br>
一个字可以存在一个 16 位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高 8 位寄存器和低 8 位寄存器中。如图 2.4 所示，一个字型数据 20000，存在 AX 寄存器中，在 AH 中存储了它的高 8 位，在 AL 中存储了它的低 8 位。AH 和 AL 中的数据，既可以看成是一个字型数据的高 8 位和低 8 位，这个字型数据的大小是 20000；又可以看成是两个独立的字节型数据，它们的大小分别是 78 和 32。





#### 2.3	几条汇编指令

通过汇编指令控制 CPU 进行工作，看一下表 2.1 中的几条指令。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE13.jpg"/> </div><br>
注意，为了使具有高级语言基础的读者更好地理解指令的含义，有时会用文字描述和高级语言描述这两种方式来描述一条汇编指令的含义。在写一条汇编指令或一个寄存器的名称时不区分大小写。如：mov ax,18 和 MOV AX,18 的含义相同：bx 和 BX 的含义相同。





#### 2.4	物理地址

我们知道，CPU 访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址。

CPU 通过地址总线送入存储器的，必须是一个内存单元的物理地址。在 CPU 向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。不同的 CPU 可以有不同的形成物理地址的方式。我们现在讨论 8086CPU 是如何在内部形成内存单元的物理地址的。





#### 2.5	16 位结构的 CPU

我们说 8086CPU 的上一代 CPU（8080、8085）等是 8 位机，而 8086 是 16 位机，也可以说 8086 是 16 位结构的 CPU。那么什么是 16 位结构的 CPU 呢？

概括地讲，16 位结构（16 位机、字长为 16 位等常见说法，与 16 位结构的含义相同）描述了一个 CPU 具有下面几方面的结构特性。

- 运算器一次最多可以处理 16 位的数据；

- 寄存器的最大宽度为 16 位；

- 寄存器和运算器之间的通路为 16 位。

  

8086 是 16 位机构的 CPU，这也就是说，在 8086 内部，能够一次性处理、传输、暂时存储的信息的最大长度是 16 位的。内存单元的地址在送上地址总线之前，必须在 CPU 中处理、传输、暂时存放，对于 16 位 CPU，能一次性处理、传输、暂时存储 16 位的地址。





#### 2.6	8086CPU 给出物理地址的方法

8086CPU 有 20 位地址总线，可以传送 20 位地址，达到 1MB 寻址能力。8086CPU 又是 16 位结构，在内部一次性处理、传输、暂时存储的地址为 16 位。从 8086CPU 的内部结构来看，如果将地址从内部简单地发出，那么它只能送出 16 位的地址，表现出的寻址能力只有 64KB。

8086CPU 采用一种在内部用两个 16 位地址合成的方法来形成一个 20 位的物理地址。

8086CPU 相关部件的逻辑结构如图 2.6 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE14.jpg"/> </div><br>
如图 2.6 所示，当 8086CPU 要读写内存时：

（1）CPU 中的相关部件提供两个 16 位的地址，一个称为段地址，另一个称为偏移地址；

（2）段地址和偏移地址通过内部总线送入一个称为地址加法器的部件；

（3）地址加法器将两个 16 位地址合成为一个 20 位的物理地址；

（4）地址加法器通过内部总线将 20 位物理地址送入输入输出控制电路；

（5）输入输出控制电路将 20 位物理地址送上地址总线；

（6）20 位物理地址被地址总线传送到存储器。



地址加法器采用**物理地址=段地址✖16 + 偏移地址**的方法用段地址和偏移地址合成物理地址。





#### 2.7	“段地址✖16 + 偏移地址=物理地址” 的本质含义

注意，这里讨论的是 8086CPU 段地址和偏移地址的本质含义，而不是为了解决具体的问题，而在本质含义之上引申出来的更高级的逻辑意义。不管以多少种不同的逻辑意义去看待 “段地址×16+偏移地址=物理地址” 的寻址模式，一定要清楚地知道它的本质含义，这样才能更灵活地利用它来分析解决问题。如果只拘泥于某一种引申出来的逻辑含义，而模糊本质含义的话，将从意识上限制对这种寻址功能的灵活应用。

“段地址×16+偏移地址=物理地址” 的本质含义是：CPU 在访问内存时，用一个基础地址（段地址×16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。

更一般地说，8086CPU 的这种寻址功能是 **“基础地址+偏移地址=物理地址”** 寻址模式的一种具体实现方案。8086CPU中，段地址×16可看做是基础地址。





#### 2.8	段的概念

我们注意到，“段地址” 这个名称中包含着 “段” 的概念。这种说法可能对一些学习者产生了误导，使人误以为内存被划分成了一个一个的段，每一个段有一个段地址。如果我们在一开始形成了这种认识，将影响以后对汇编语言的深入理解和灵活应用。

其实，内存并没有分段，段的划分来自于 CPU，由于 8086CPU 用 “基础地址（段地址✖16）+偏移地址=物理地址” 的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。如图 2.9 所示，我们可以认为：地址 10000H~100FFH 的内存单元组成一个段，该段的起始地址（基础地址）为 10000H，段地址为 1000H，大小为 100H；我们也可以认为地址：10000H ~ 1007FH、10080H ~ 100FFH 的内存单元组成两个段，它们的起始地址（基础地址）为：10000H 和 10080H，段地址为：1000H 和 1008H，大小都为 80H。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE15.jpg"/> </div><br>
以后，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址✖16 定位段的起始地址（基础地址），用偏移地址定位段中的内存单元。有两点需要注意：段地址✖16 必然是 16 的倍数，所以一个段的起始地址也一定是 16 的倍数；偏移地址为 16 位，16 位地址的寻址能力为 64KB，所以一个段的长度最大为 64KB。

CPU 访问内存单元时，必须向内存提供内存的那样的物理地址。8086CPU 在内部用段地址和偏移地址移位相加的方法形成最终的物理地址。

（1）CPU 可以用不同的段地址和偏移地址形成同一个物理地址。

（2）如果给定一个段地址，仅通过变化偏移地址来进行寻址，最多可定位多少个内存单元？

偏移地址 16 位，变化范围为 0~FFFFH，仅用偏移地址来寻址最多可寻 64KB 个内存单元。

在 8086PC 机中，存储单元的地址用两个元素来描述，即段地址和偏移地址。

“数据在 21F60H 内存单元中。” 这句话对于 8086PC 机一般不这样讲，取而代之的是两种类似的说法：（1）数据存在内存 2000:1F60 单元中；（2）数据存在内存的 2000H 段中的 1F60H 单元中。这两种描述都表示 ”数据在内存 21F60H 单元中“。

可以根据需要，将地址连续、起始地址为 16 的倍数的一组内存单元定义为一个段。



#### 2.9	段寄存器

我们前面讲到，8086CPU 在访问内存时要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。这里，需要看一下，是什么部件提供段地址。段地址在 8086CPU 的段寄存器中存放。8086CPU 有 4 个段寄存器：CS、DS、SS、ES。

CS（Code Segment）：代码段寄存器

DS（Data Segment）：数据段寄存器

SS（Stack Segment）：堆栈寄存器

ES（Extra Segment）：附加段寄存器 OF

当 8086CPU 要访问内存时由这 4 个段寄存器提供内存单元的段地址。本章中只看一下 CS。



#### 2.10	CS 和 IP

CS（Code Segment）代码段寄存器和 IP（Instruction Pointer）指令指针寄存器是 8086CPU 中两个最关键的寄存器，它们指示了 CPU 当前要读取指令的地址。CS 为代码段寄存器，IP 为指令指针寄存器，从名称上我们可以看出它们和指令的关系。

在 8086PC 机中，任意时刻，设 CS 中的内容为 M，IP 中的内容为 N，8086CPU 将从内存 M✖16+N 单元开始，读取一条指令并执行。

也可以这样表述：8086 机中，任意时刻，CPU 将 CS:IP 指向的内容当作指令执行。

图太多了，略。

通过上面的过程展示，8086 CPU 的工作过程可以简要描述如下。

（1）从 CS:IP 指向的内存单元读取指令，读取的指令进入指令缓冲器；

（2）IP=IP+所读取指令的长度，从而指向下一条指令；

（3）执行指令。转到步骤（1），重复这个过程。

在 8086CPU 加电启动或复位后（即 CPU 刚开始工作时）CS 和 IP 被设置为 CS=FFFFH，IP=0000H，即在 8086PC 机刚启动时，CPU 从内存 FFFF0H 单元中读取指令执行。FFFF0H 单元中的指令是 8086PC 机开机后执行的第一条指令。

现在，我们更清楚了 CS 和 IP 的重要性，它们的内容提供了 CPU 要执行指令的地址。

我们在第 1 章中讲过，在内存中，指令和数据没有任何区别，都是二进制信息，CPU 在工作的时候把有的信息看作指令，有的信息看作数据。现在，如果提出一个问题：CPU 根据什么将内存中的信息看作指令？如何回答？我们可以说，CPU 将 CS:IP 指向的内存单元中的内容看作指令，因为，在任何时候，CPU 将 CS、IP 中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行。如果说，内存中的一段信息曾被 CPU 执行过的话，那么，它所在的内存单元必然被 CS:IP 指向过。 



#### 2.11	修改 CS、IP 的指令

在 CPU 中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对 CPU 的控制。CPU 从何处执行指令是由 CS、IP 中的内容决定的，程序员可以通过改变 CS、IP 中的内容来控制 CPU 执行目标指令。

8086CPU 大部分寄存器的值，都可以用 mov 指令来改变，mov 指令被称为传送指令。但是，mov 指令不能用于设置 CS、IP 的值，原因很简单，因为 8086CPU 没有提供这样的功能。8086CPU 为 CS、IP 提供了另外的指令来改变它们的值。能够改变 CS、IP 的内容的指令被统称为转移指令。我们现在介绍一个最简单的可以修改 CS、IP 的指令：jmp 指令。

若想同时修改 CS、IP 的内容，可用形如 “jmp 段地址：偏移地址” 的指令完成，如

jmp 2AE3:3，执行后：CS=2AE3H，IP=0003H，CPU 将从 2AE33H 处读取指令。

jmp 3:0B16，执行后：CS=0003H，IP=0B16H，CPU 将从 00B46H 处读取指令。

"jmp 段地址：偏移地址" 指令的功能为：用指令中给出的段地址修改 CS，偏移地址修改 IP。

若想仅修改 IP 的内容，可用形如 "jmp 某一合法寄存器" 的指令完成，如

jmp ax，指令执行前：ax=1000H，CS=2000H，IP=0003H

​				指令执行后：ax=1000H，CS=2000H，IP=1000H

jmp bx，指令执行前：bx=0B16H，CS=2000H，IP=0003H

​				指令执行后：bx=0B16H，CS=2000H，IP=0B16H

"jmp 某一合法寄存器" 指令的功能为：用寄存器中的值修改 IP。

jmp ax，在含义上好似：mov IP,ax。

注意，我们在适当的时候，会用已知的汇编指令的语法来描述新学的汇编指令的功能。采用一种 "用汇编解释汇编" 的方法来使读者更好地理解汇编指令的功能，这样做有助于读者进行知识的相互融会。要强调的是，我们是用 "已知的汇编指令的语法" 进行描述，并不是用 "已知的汇编指令" 来描述，比如，我们用 mov IP,ax 来描述 jmp ax，并不是说真有 mov IP,ax 这样的指令，而是用 mov 指令的语法来说明 jmp 指令的功能。我们可以用同样的方法描述 jmp 3:01B6 的功能：jmp 3:01B6 在含义上好似 mov CS,3  mov IP,01B6。



#### 2.12	代码段

前面讲过，对于 8086PC 机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为 N（N≤64KB）的一组代码，存放一组地址连续、起始地址为 16 的倍数的内存单元中，我们可以认为，这段内存是用来存放代码的，从而定义了一个代码段。

```assembly
mov ax,0000   (B8 00 00)
add ax,0123H  (05 23 01)
mov bx,ax     (8B D8)
jmp bx        (FF E3)
```



这段长度为 10 个字节的指令，存放在 123B0H~123B9H 的一组内存单元中，我们就可以认为，123B0H~123B9H 这段内存是用来存放代码的，是一个代码段，它的段地址为 123BH，长度为 10 个字节。

如何使得代码段中的指令被执行呢？将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU 并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。CPU 只认被 CS:IP 指向的内存单元中的内容为指令。所以，要让 CPU 执行我们放在代码段中的指令，必须要将 CS:IP 指向所定义的代码段中的第一条指令的首地址。如上面的例子，我们将一段代码存放在 123B0H~123B9H 内存单元中，将其定义为代码段，如果要让这段代码得到指向，可设 CS=123BH、IP=0000H。



#### 实验 1	查看 CPU 和内存，用机器指令和汇编指令编程

（1）什么是 Debug？

Debug 是 DOS、windows 都提供的实模式（8086 方式）程序的调试工具。使用它，可以查看 CPU 各种寄存器中的内容、内存的情况和在机器码级跟踪程序的运行。

（2）我们用到的 Debug 功能。

- 用 Debug 的 R 命令查看、改变 CPU 寄存器的内容；

- 用 Debug 的 D 命令查看内存中的内容；

- 用 Debug 的 E 命令改写内存中的内容；

- 用 Debug 的 U 命令将内存中的机器指令翻译成汇编指令；

- 用 Debug 的 T 命令执行一条机器指令；

- 用 Debug 的 A 命令以汇编指令的格式在内存中写入一条机器指令。

  

Debug 的命令比较多，共有 20 多个，但这 6 个命令是和汇编学习密切相关的。在以后的实验中，我们还会用到一个 P 命令。

（3）进入 Debug

高等级的 win10 系统不支持 Debug，需要下载安装 DOSBox。



（4）用 R 命令查看、改变 CPU 寄存器的内容。

（5）用 Debug 的 D 命令查看内存中的内容。

要查看内存 10000H 处的内容，首先将这个地址表示为段地址:偏移地址的格式，可以是 1000:0，然后用 “d 1000:0” 列出 1000:0 处的内容。

使用 "d 段地址:偏移地址" 的格式，Debug 将列出从指定内存单元开始的 128 个内存单元的内容。如图 2.34 所示，在使用 d 1000:0 后，Debug 列出了 1000:0~1000:7F 中的内容。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE16.jpg"/> </div><br>
1. 中间是从指定地址开始的 128 个内存的单元的内容，用十六进制的格式输出，每行的输出从 16 的整数倍的地址开始，最多输出 16 个单元的内容。
2. 左边是每行的起始地址。
3. 右边是每个内存单元中的数据对应的可显示的 ASCII 码字符。



在以进入 Debug 后，用 D 命令直接查看，将列出 Debug 预设的地址出处的内容。在使用 "d 段地址:偏移地址" 之后，接着使用 D 命令，可列出后续的内容。也可以指定 D 命令的查看范围，此时采用 "d 段地址:偏移地址 结尾偏移地址" 的格式。比如要看 1000:0~1000:9 中的内容，可以用 "d 1000:0 9" 实现。



（6）用 Debug 的 E 命令改写内存中的内容。

（7）用 E 命令向内存中写入机器码，用 U 命令查看内存中机器码的含义，用 T 命令执行内存中的机器码。

（8）用 Debug 的 A 命令以汇编指令的形式在内存中写入机器指令。







### 第 3 章	寄存器（内存访问）

第 2 章钟，我们主要从 CPU 如何执行指令的角度讲解了 8086CPU 的逻辑结构、形成物理地址的方法、相关的寄存器以及一些指令。这一章中，我们从访问内存的角度继续学习几个寄存器。



#### 3.1	内存中字的存储

CPU 中，用 16 位寄存器来存储一个字。高 8 位存放高位字节，低 8 位存放低位字节。在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元来存放，这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。

我们提出字单元的概念：字单元，即存放一个字型数（16 位）的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。

在以后的课程中，我们将起始地址为 N 的字单元简称为 N 地址字单元。比如一个子单元由 2、3 两个内存单元组成，则这个字单元的起使地址为 2，我们可以说这是 2 地址字单元。



#### 3.2	DS 和 [address]

CPU 要读写一个内存单元的时候，必须先给出这个内存单元的地址，在 8086PC 中，内存地址由段地址和偏移地址组成。8086CPU 中有一个 DS 寄存器，DS（Data Segment）：数据段寄存器，通常用来存放要访问数据的段地址。比如我们要读取 10000H 单元的内容，可以用如下的程序段进行。

```assembly
mov bx,1000H
mov ds,bx
mov al,[0]
```



上面的 3 条指令将 1000H(1000:0) 地址中的数据读到 a1 中。

下面详细说明指令的含义。

mov a1,[0]

前面我们使用 mov 指令，可完成两种传送：1.将数据直接送入寄存器；2.将一个寄存器中的内存送入另一个寄存器。

也可以使用 mov 指令将一个内存单元中的内容送入一个寄存器中。从哪一个内存单元送到哪一个寄存器中呢？在指令中必须指明。寄存器用寄存器名来指明，内存单元则需用内存单元的地址来指明。显然，此时 mov 指令的格式应该是：mov 寄存器名，内存单元地址。

[...] 表示一个内存的那样，[...] 中的 0 表示内存单元的偏移地址。我们知道，只有偏移地址是不能定位一个内存单元的，那么内存单元的段地址是多少呢？指令执行时，8086CPU 自动取 ds 中的数据为内存单元的段地址。

因为 8086CPU 不支持将数据直接送入段寄存器的操作，ds 是一个段寄存器，所以 mov ds,1000H 这条指令是非法的。那么如何将 1000H 送入 ds 呢？只好用一个寄存器来进行中转，即先将 1000H 送入一个一般的寄存器，如 bx，再将 bx 中的内容送入 ds。





### 3.3	字 的 传 送

前面我们用 mov 指令在寄存器和内存之间进行字节型数据的传送。因为 8086CPU 是 16 位结构，有 16 根数据线，所以，可以一次性传送 16 位的数据，也就是说可以一次性传送一个字。只要在 mov 指令中给出 16 位的寄存器就可以进行 16 位数据的传送了。比如：

```assembly
mov bx,1000H
mov ds,bx
mov ax,[0]	;1000:0 处的字型数据送入 ax
mov [0],cx  ;cs 中的 16 位数据送到 1000:0 处
```



#### 3.4	mov、add、sub 指令

前面我们用到了 mov、add、sub 指令，它们都带有两个操作对象。

到现在，我们知道，mov 指令可以有以下几种形式。

mov	寄存器，数据			比如：mov ax,8

mov	寄存器，寄存器		比如：mov ax,bx

mov	寄存器，内存单元    比如：mov ax,[0]

mov	内存单元，寄存器	比如：mov [0],ax

mov	段寄存器，寄存器	比如：mov ds,ax

我们可以根据这些已知指令进行下面的推测。

（1）既然有 “mov 段寄存器，寄存器”，那么也该有 "mov 寄存器，段寄存器"。

（2）既然有 “mov 内存单元，寄存器”，那么也该有 "mov 内存单元，段寄存器"

（3）“mov 段寄存器，内存单元” 也应该可行。



add 和 sub 指令同 mov 一样，都有两个操作对象。它们也可以有以下几种形式。

add  寄存器，数据          	 比如：add ax,8

add  寄存器，寄存器           比如：add ax,bx 

add  寄存器，内存单元       比如：add ax,[0] 

add  内存单元，寄存器       比如：add [0],ax 

sub  寄存器，数据               比如：sub ax,9 

sub  寄存器，寄存器           比如：sub ax,bx 

sub  寄存器，内存单元       比如：sub ax,[0] 

sub  内存单元，寄存器       比如：sub [0],ax



#### 3.5	数 据 段

前面讲过（参见 2.8 节）。对于 8086PC 机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将一组长度为 N（N≤64KB）、地址连续、起始地址为 16 的倍数的内存单元当作专门存储数据的内存单元，从而定义了一个数据段。比如用 123B0H~123B9H 这段内存空间来存放数据，我们就可以认为，123B0H~123B9H 这段内存是一个数据段，它的段地址为 123BH，长度为 10 个字节。

如何访问数据段中的数据呢？将一段内存当作数据段，是我们在编程时的一种安排，可以在具体操作的时候，用 ds 存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。

比如，将 123B0H~123B9H 的内存单元定义为数据段。现在要累加这个数据段中的前 3 个单元中的数据，代码如下。

```assembly
mov ax,123BH
mov ds,ax		;将 123BH 送入 ds 中，作为数据段的段地址
mov al,0		;用 al 存放累加结果
add al,[0]		;将数据段第一个单元{偏移地址为 0}中的数值加到 al 中
add al,[1]		;将数据段第二个单元{偏移地址为 1}中的数值加到 al 中
add al,[2]		;将数据段第三个单元{偏移地址为 2}中的数值加到 al 中
```



#### 3.1~3.5	小	结

（1）字再内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。

（2）用 mov 指令访问内存单元，可以在 mov 指令中只给出单元的偏移地址，此时，段地址默认在 DS 寄存器中。

（3）[address] 表示一个偏移地址为 address 的内存单元。

（4）在内存和寄存器之间传送字型数据时，高地址单元和高 8 位寄存器、低地址单元和低 8 位寄存器相对应。

（5）mov、add、sub 是具有两个操作对象的指令。jmp 是具有一个操作对象的指令。

（6）可以根据自己的推测，在 Debug 中实验指令的新格式。





#### 3.6	栈

在这里，我们对栈的研究仅限于这个角度：栈是一种具有特殊的访问方式的存储空间。它的特殊性就在于，最后进入这个空间的数据，最先出去。

从程序化的角度来讲，应该有一个标记，这个标记一直指示着栈顶的元素。

栈有两个基本的操作：入栈和出栈。入栈就是将要给新的元素放到栈顶，出栈就是从栈顶取出一个元素。栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。栈的这种操作被称为LIFO（Last In First Out，后进先出）。



#### 3.7	CPU 提供的栈机制

现今的 CPU 中都有栈的设计，8086CPU 也不例外。8086CPU 提供相关的指令来以栈的方式访问内存空间。这意味着。在基于 8086CPU 编程的时候，可以将一段内存当作栈来使用。

8086CPU 提供入栈和出栈指令，最基本的两个是 PUSH（入栈）和 POP（出栈）。比如，push ax 表示将寄存器 ax 中的数据送入栈中，pop ax 表示从栈顶取出数据送入 ax。8086CPU 的入栈和出栈操作都是以字为单位进行的。

下面举例说明，我们可以将 10000H~1000FH 这段内存当作栈来使用。

图 3.9 描述了下面一段指令的执行过程。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE17.jpg"/> </div><br>
```assembly
mov ax,0123H
push ax
mov bx,2266H
push bx
mov cx,1122H
push cx
pop ax
pop bx
pop cx
```



注意，字型数据用两个单元存放，高地址存放高 8 位，低地址单元存放低 8 位。

读者看到图 3.9 所描述的 push 和 pop 指令的执行过程，是否有一些疑惑？总结一下，大概是这两个问题。

第一，我们将 10000H~1000FH 这段内存当作栈来使用，CPU 执行 push 和 pop 指令时，将对这段空间按照栈的后进先出的规则进行访问。但是，一个重要的问题是，CPU 如何知道 10000H~1000FH 这段空间被当作栈来使用？

第二，push ax 等入栈指令执行时，要将寄存器中的内容放入当前栈顶单元的上方，成为新的栈顶元素；pop ax 等指令执行时，要从栈顶单元中取出数据，送入寄存器中。显然，push、pop 在执行的时候，必须知道哪个单元是栈顶单元，可是，如何知道呢？

这不禁让我们想起另外一个讨论过的问题，就是，CPU 如何知道当前要执行的指令所在的位置？我们现在知道答案，那就是 CS、IP 中存放着当前指令的段地址和偏移地址。现在的问题是：CPU 如何知道栈顶的位置？显然，也应该有相应的寄存器来存放栈顶的地址，8086CPU 中，有两个寄存器，段寄存器 SS 和寄存器 SP，SS（Stack Segment）：堆栈寄存器，SP（Stack Pointer）：堆栈指针寄存器，栈顶的段地址存放在 SS 中，偏移地址存放在 SP 中。**任意时刻，SS:SP 指向栈顶元素**。push 指令和 pop 指令执行时，CPU 从 SS 和 SP 中得到栈顶的地址。

现在，我们可以完整地描述 push 和 pop 指令的功能了，例如 push ax。

push ax 的执行，由以下两步完成。

（1）SP=SP-2，SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；

（2）将 ax 中的内容送入 SS:SP 指向的内存单元处，SS:SP 此时指向新栈顶。

图 3.10 描述了 8086CPU 对 push 指令的执行过程。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE18.jpg"/> </div><br>
从图中我们可以看出，8086CPU 中，入栈时，栈顶从高地址向低地址方向增长。

接下来，我们描述 pop 指令的功能，例如 pop ax。

pop ax 的执行过程和 push ax 刚好相反，由以下两步完成。

（1）将 SS:SP 指向的内存单元处的数据送入 ax 中；

（2）SP=SP+2，SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。

图 3.12 描述了 8086CPU 对 pop 指令的执行过程。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE19.jpg"/> </div><br>
注意，图 3.12 中，出栈后，SS:SP 指向新的栈顶 1000EH，pop 操作前的栈顶元素，1000CH 处的 2266H 依然存在，但是，它已不在栈中。当再次执行 push 等入栈指令后，SS:SP 移至 1000CH，并在里面写入新的数据，它将被覆盖。





#### 3.8	栈顶超界的问题

我们现在知道，8086CPU 用 SS 和 SP 指示栈顶的地址，并提供 push 和 pop 指令实现入栈和出栈。

但是，还有一个问题需要讨论，就是 SS 和 SP 只是记录了栈顶的地址，依靠 SS 和 SP 可以保证在入栈和出栈时找到栈顶。可是，如何能够保证在入栈、出栈时，栈顶不会超出栈空间？

图 3.13 描述了在执行 push 指令后，栈顶超出栈空间的情况。图 3.14 描述了在执行 pop 指令后，栈顶超出栈空间的情况。







上面描述了执行 push、pop 指令时，发生的栈顶超界问题。可以看到，当栈满的时候再使用 push 指令入栈，或栈空的时候再使用 pop 指令出栈，都将发生栈顶超界问题。

栈顶超界是最危险的，因为我们既然将一段空间安排为栈，那么在栈空间之外的空间里很可能存放了具有其他用途的数据、代码等，这些数据、代码可能是我们自己程序中的，也可能是别的程序中的（毕竟一个计算机系统中并不是只有我们自己的程序在运行）。但是由于我们在入栈出栈时的不小心，而将这些数据、代码意外地改写，将会引发一连串的错误。

我们当然希望 CPU 可以帮我们解决这个问题，比如说在 CPU 中有记录栈顶上限和栈底的寄存器，我们可以通过填写这些寄存器来指定栈空间的范围，然后，CPU 在执行 push 指令的时候靠检测栈顶上限寄存器、在执行 pop 指令的时候靠检测栈底寄存器保证不会超界。

不过，对于 8086CPU，这只是我们的一个设想（我们当然可以这样设想，如果 CPU 是我们设计的话，这也就不仅仅是一个设想）。实际的情况是，8086CPU 中并没有这样的寄存器。

8086CPU 不保证我们对栈的操作不会超界。这也就是说，8086CPU 只知道栈顶在何处（由 SS:SP 指示），而不知道我们安排的栈空间有多大。这点就好像 CPU 只知道当前要执行的指令在何处（由 CS:IP 指示），而不知道要执行的指令有多少。从这两点上我们可以看出 8086CPU 的工作机理，它只考虑当前的情况：当前的栈顶在何处、当前要执行的指令是哪一条。

我们在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致的超界；执行出栈操作的时候也要注意，以防栈空的时候继续出栈而导致的超界。



#### 3.9	push、pop 指令

前面我们一直在使用 push ax 和 pop ax，显然 push 和 pop 指令是可以在寄存器和内存（栈空间当然也是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间。）之间传送数据的。

push 和 pop 指令的格式可以是如下形式：

```assembly
push	寄存器		;将一个寄存器中的数据入栈
pop		寄存器		;出栈，用一个寄存器接收出栈的数据
```



当然也可以是如下形式：

```assembly
push	段寄存器	;将一个段寄存器中的数据入栈
pop		段寄存器	;出栈，用一个段寄存器接收出栈的数据
```



push 和 pop 也可以在内存单元和内存单元之间传送数据，我们可以：

```assembly
push	内存单元	 ;将一个内存字单元处的字入栈（注意：栈操作都是以字为单位）
pop		内存单元  	 ;出栈，用一个内存字单元接收出栈的数据
```



比如：

```assembly
mov ax,1000H
mov ds,ax		;内存单元的段地址要放在 ds 中
push [0]		;将 1000:0 处的字压入栈中
pop	 [2]		;出栈，出栈的数据送入 1000:2 处
```



指令执行时，CPU 要知道内存单元的地址，可以在 push、pop 指令中只给出内存单元的偏移地址，段地址在指令执行时，CPU 从 ds 中取得。

与 CS 一样，SS 不能直接通过 mov 传送数据，需要通过寄存器中转；但是与 IP 不一样，SP 可以直接用 mov 传送数据。

用栈来暂存以后需要恢复的寄存器中的内容时，出栈的顺序和入栈的顺序相反，因为最后入栈的寄存器的内容在栈顶，所以在恢复时，要最先出栈。

push、pop 指令实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与 mov 指令不同的是，push 和 pop 指令访问的内存单元的地址不是在指令中给出的，而是由 SS:SP 指出的。同时，push 和 pop 指令还要改变 SP 中的内容。

我们要十分清楚的是，push 和 pop 指令同 mov 指令不同，CPU 执行 mov 指令只需一步操作，就是传送，而执行 push、pop 指令却需要两步操作。执行 push 时，CPU 的两步操作是：先改变 SP，后向 SS:SP 处传送。执行 pop 时，CPU 的两步操作是：先读取 SS:SP 处的数据，后改变 SP。

注意，push，pop 等栈操作指令，修改的只是 SP。也就是说，栈顶的变化范围最大为：0~FFFFH。

提供：SS、SP 指示栈顶：改变 SP 后写内存的入栈ss指令；读内存后改变 SP 的出栈指令。这就是 8086CPU 提供的栈操作机制。



#### 栈 的 综 述

（1）8086CPU 提供了栈操作机制，方案如下。

在 SS、SP 中存放栈顶的段地址和偏移地址；

提供入栈和出栈指令，它们根据 SS:SP 指示的地址，按照栈的方式访问内存单元。

（2）push 指令的执行步骤：1.SP=SP-2；2.向 SS:SP 指向的字单元中传入数据。

（3）pop 指令的执行步骤：1.从 SS:SP 指向的字单元中读取数据；2.SP=SP+2。

（4）任意时刻，SS:SP 指向栈顶元素。

（5）8086CPU 只记录栈顶，栈空间的大小我们要自己管理。

（6）用栈来暂存以后需要恢复的寄存器的内容时，寄存器出栈的顺序要和入栈的顺序相反。

（7）push、pop 实质上是一种内存传送指令，注意它们的灵活应用。

栈是一种非常重要的机制，一定要深入理解，灵活掌握。





#### 3.10	栈	段

前面讲过（参见 2.8 节），对于 8086PC 机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为 N(N≤64KB) 的一组地址连续、起始地址为 16 的倍数的内存单元，当作栈空间来用，从而定义了一个栈段。比如，我们将 10010H~1001FH 这段长度为 16 字节的内存空间当作栈来用，以栈的方式进行访问。这段空间就可以称为一个栈段，段地址为 1001H，大小为 16 字节。

将一段内存当作栈段，仅仅是我们在编程时的一种安排，CPU 并不会由于这种安排，就在执行 push、pop 等栈操作指令时自动地将我们定义的栈段当作栈空间来访问。如何使得如 push、pop 等栈操作指令访问我们定义的栈段呢？前面我们已经讨论过，就是要将 SS:SP 指向我们定义的栈段。



#### 问题	3.11

如果将 1000H~1FFFFH 这段空间当作栈段，初始这条栈是空的，此时，SS=1000H，SP=？

分析：

1.【1000H~1FFFFH 这段空间当作栈】

栈满时，栈顶标记指向 1000H。

栈为空的话，栈顶标记指向 1FFFFH+2=20000H

2.【初始状态是空的】

栈顶标记指向 20000H，SS=1000H，SP 肯定等于 0000H。因为栈顶的变化范围是：0~FFFFH。



#### 问题	3.12

一个栈段最大可以设为多少？为什么？

分析：这个问题显而易见，提出来只是为了提示我们将相关的知识融会起来。首先从栈操作指令所完成的功能的角度上来看，push、pop 等指令在执行的时候只修改 SP，所以栈顶的变化范围是 0~FFFFH，从栈空时候的 SP=0，一直压栈，直到栈满时 SP=0；如果再次压栈，栈顶将环绕，覆盖了原来栈中的内容。所以一个栈段的容量最大为 64KB。



#### 段 的 综 述

我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排。

我们可以用一个段存放数据，将它定义为 “数据段”。

我们可以用一个段存放代码，将它定义为 “代码段”。

我们可以用一个段当作栈，将它定义为 “栈段”。

我们可以这样安排，但若要让 CPU 按照我们的安排来访问这些段，就要：

对于数据段，将它的段地址放在 DS 中，用 mov、add、sub 等访问内存单元的指令时，CPU 就将我们定义的数据段中的内容当作数据来访问。

对于代码段，将它的段地址放在 CS 中，将段中的第一条指令的偏移地址放在 IP 中，这样CPU 就将执行我们定义的代码段中的指令。

对于栈段，将它的地址放在 SS 中，将栈顶单元的偏移地址放在 SP 中，这样 CPU 在需要进行栈操作的时候，比如执行 push、pop 指令等，就将我们定义的栈段当作栈空间来用。

可见，不管我们如何安排，CPU 将内存中的某段代码当作代码，是因 CS:IP 指向了哪里；CPU 将某段内容当作栈，是因为 SS:SP 指向了哪里。我们一定要清楚，什么是我们的安排，以及如何让 CPU 按我们的安排行事。要非常清楚 CPU 的工作机理，才能在控制 CPU 按照我们的安排运行的时候做到游刃有余。

比如我们将 10000H~1001FH 安排为代码段，并在里面存储如下代码：

```assembly
mov ax,1000H
mov ss,ax
mov sp,0029H	;初始化栈顶
mov ax,cs		
mov ds,ax		;设置数据段地址
mov ax,[0]
add ax,[2]
mov bx,[4]
add bx,[6]
push ax
push bx
pop ax
pop bx
```



设置 CS=1000H，IP=0，这段代码将得到执行。可以看到，在这段代码中，我们又将 10000H~1001FH 安排为栈段和数据段。10000H~1001FH 这段内存，既是代码段，又是栈段和数据段。

一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。关键在于 CPU 中寄存器的设置，即 CS、IP，SS、SP，DS 的指向。





#### 实验 2	用机器指令和汇编指令编程

1.预备知识：Debug 的使用

前面实验中，讲了 Debug 的一些主要命令的用法，这里，再补充一些关于 Debug 的知识。

（1）关于 D 命令。

从上次实验中，我们知道，D 命令是查看内存单元的命令，可以用：

“d 段地址:偏移地址” 的格式查看指定的内存单元的内容，上次实验中，D 命令后面的段地址和偏移地址都是直接给出的。

现在，我们知道段地址是放在段寄存器中的，在 D 命令后面直接给出段地址，是 Debug 提供的一种直观的操作方式。D 命令是由 Debug 执行的，Debug 在执行 “d 1000:0” 这样的命令时，也会先将段地址 1000H 送入段寄存器中。

Debug 是靠什么来执行 D 命令的？当然是一段程序。

谁来执行这段程序？当然是 CPU。

CPU 在访问内存单元的时候从哪里得到内存单元的段地址？从段寄存器中得到。

所以，Debug 在其处理 D 命令的程序段中，必须有将段地址送入段寄存器的代码。

段寄存器有 4 个：CS、DS、SS、ES，将段地址送入哪个段寄存器呢？

首先不能是 CS，因为 CS:IP 必须指向 Debug 处理 D 命令的代码，也不能是 SS，因为 SS:SP 要指向栈顶。这样只剩下了 DS 和 ES 可以选择，放在哪里呢？我们知道，访问内存的指令如 "mov ax,[0]" 等一般都默认段地址在 ds 中，所以 Debug 在执行如 "d 段地址:偏移地址" 这种 D 命令时，将段地址送入 ds 中比较方便。

D 命令也提供了一种符合 CPU 机理的格式：“d 段寄存器:偏移地址”，以段寄存器中的数据为段地址 SA，列出从 SA:偏移地址开始的内存区间中的数据。以下是几个例子。

```assembly
-r ds
:1000
-d ds:0			;查看从 1000:0 开始的内存区间中的内容

-r ds
:1000
-d ds:10 18		;查看 1000:10~1000:18 中的内容

-d cs:0			;查看当前代码段中的指令代码
-d ss:0			;查看当前栈段中的内容
```













































