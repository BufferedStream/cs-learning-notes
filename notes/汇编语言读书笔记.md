## 汇编语言读书笔记

### 第 1 章	基础知识

汇编语言是直接在硬件之上工作的编程语言，我们首先要了解硬件系统的结构，才能有效地应用汇编语言对其编程。



#### 1.1 机器语言

机器语言是机器指令的集合。机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一列二进制数字。计算机将之转变为一列高低电平，以使计算机的电子器件受到驱动，进行运算。

上面所说的计算机指的是可以执行机器指令，进行运算的机器。在我们常用的 PC 机中，有一个芯片来完成上面所说的计算机的功能。这个芯片就是我们常说的 CPU（Central Processing Unit，中央处理单元），CPU 是一种微处理器。以后我们提到的计算机是指由 CPU 和其他受 CPU 直接或间接控制的芯片、器件、设备组成的计算机系统，比如我们最常见的 PC 机。

每一种微处理器，由于硬件设计和内部结构的不同，就需要用不同的电平脉冲来控制，使它工作。所以每一种微处理器都有自己的机器指令集，也就是机器语言。



#### 1.2 汇编语言的产生

由于机器语言的晦涩难懂和不易查错，给整个产业的发展带来了障碍，汇编语言产生了。

汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令是机器指令便于记忆的书写格式。如下例所示：

操作：寄存器 BX 的内容送到 AX 中

机器指令：1000100111011000

汇编指令：mov ax,bx



寄存器，简单地讲是 CPU 中可以存储数据的器件，一个 CPU 中有多个寄存器。AX 和 bX 是寄存器的代号。

我们需要编译器将汇编语言解读成计算机能读懂的机器指令。图 1.1 描述了这个工作过程。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE5.jpg"/> </div><br>
#### 1.3 汇编语言的组成

汇编语言有以下 3 类指令组成。

（1）汇编指令：机器码的助记符，有对应的机器码。

（2）伪指令：没有对应的机器码，由编译器执行，计算机并不执行。

（3）其他符号：如 +、-、*、/ 等，由编译器识别，没有对应的机器码。

汇编语言的核心是汇编指令，它决定了汇编语言的特性。



#### 1.4 存储器

CPU 是计算机的核心部件，它控制整个计算机的运作并进行运算。要想让一个 CPU 工作，就必须向它提供指令和数据。指令和数据在存储器中存放，也就是我们平时所说的内存。磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被 CPU 使用。要灵活地利用汇编语言编程，我们首先要了解 CPU 是如何从内存中读取信息，以及向内存中写入信息的。



#### 1.5 指令和数据

指令和数据是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。CPU 在工作的时候把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。

例如，内存中的二进制信息 1000100111011000，计算机可以把它看作大小为 89D8H 的数据来处理，也可以将其看作指令 mov ax,bx 来执行。

```assembly
1000100111011000 ——> 89D8H（数据）
1000100111011000 ——> mov ax,bx（程序）
```



#### 1.6 存储单元

存储器被划分成若干个存储单元，每个存储单元从 0 开始顺序编号，例如一个存储器有 128 个存储单元，编号从 0~127，如图 1.2 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE1.jpg"/> </div><br>
那么一个存储单元能存储多少信息呢？我们知道电子计算机的最小信息单位是 bit（音译为比特），也就是一个二进制位。8 个 bit 组成一个 Byte，也就是通常讲的一个字节。微型机存储器的存储单元可以存储一个 Byte，即 8 个二进制位。一个存储器有 128 个存储单元，它可以存储 128 个 Byte。

微机存储器的容量是以字节为最小单位来计算的。对于拥有 128 个存储单元的存储器，我们可以说，它的容量是 128 个字节。

对于大容量的存储器一般还用以下单位来计量容量（以下用 B 来代表 Byte）

1KB=1024B	1MB=1024KB	1GB=1024MB	1TB=1024GB

磁盘的容量单位同内存的一样，实际上以上单位是微机中常用的计量单位。



#### 1.7 CPU 对存储器的读写

CPU 要从内存中读数据，首先要指定存储单元的地址。另外，在一台微机中，不止有存储器这一种器件。CPU 在读写时还要指明，它要对哪一个器件进行操作，进行哪种操作，是从中读出数据，还是向里面写入数据。

可见，CPU 要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行下面 3 类信息的交互。

- 存储单元的地址（地址信息）；
- 器件的选择，读或写的命令（控制信息）；
- 读或写的数据（数据信息）。

那么 CPU 是通过什么将地址、数据和控制信息传到存储器芯片中的呢？电子计算机能处理、传输的信息都是电信号，电信号当然要用导线传送。在计算机中专门有连接 CPU 和其他芯片的导线，通常称为总线。总线从物理上来讲，就是一根根导线的集合。根据传送信息的不同，总线从逻辑上又分为 3 类，地址总线、控制总线和数据总线。

CPU 从 3 号单元中读取数据的过程（见图 1.3）如下。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE2.jpg"/> </div><br>
（1）CPU 通过地址线将地址信息 3 发出。

（2）CPU 通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。

（3）存储器将 3 号单元中的数据 8 通过数据线送入 CPU。



对于 8086CPU，下面的机器码，能够完成从 3 号单元读数据。

机器码：	101000010000001100000000

含义：		从 3 号单元读取数据送入寄存器 AX

CPU 接收这条机器码后将完成我们上面所述的读写工作。

机器码难于记忆，用汇编指令来表示，情况如下。

机器码：	10100001 00000011 00000000

对应的汇编指令：MOV AX,[3]

含义：		传送 3 号单元的内容入 AX



#### 1.8 地址总线

现在我们知道，CPU 是通过地址总线来指定存储器多纳伊的。可见地址总线上能传送多少个不同的信息，CPU 就可以对多少个存储单元进行寻址。

现假设，一个 CPU 有 10 根地址总线，让我们来看一下它的寻址情况。我们知道，在电子计算机中，一根导线可以传送的稳定状态只有两种，高电平或是低电平。用二进制表示就是 1 或 0，10 根导线可以传送 10 位二进制数据。而 10 位二进制数可以表示多少个不同的数据呢？2 的 10 次方个。最小数为 0，最大数为 1023。

一个 CPU 有 N 根地址线，则可以说这个 CPU 的地址总线的宽度为 N。这样的 CPU 最多可以寻找 2 的 N 次方个内存单元。



#### 1.9 数据总线

CPU 与内存或其他器件之间的数据传送是通过数据总线来进行的。数据总线的宽度决定了 CPU 和外界的数据传送速度。8 根数据总线一次可传送一个 8 位二进制数据（即一个字节）。16 根数据总线一次可传送两个字节。

8088CPU 的数据总线宽度为 8，8086CPU 的数据总线宽度为 16。我们来分别看一下它们向内存中写入数据 89D8H 时，是如何通过数据总线传送数据的。图 1.5 展示了 8088CPU 数据总线上的数据传送情况；图 1.6 展示了 8086CPU 数据总线上的数据传送情况。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE3.jpg"/> </div><br>
<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE4.jpg"/> </div><br>
8086 有 16 根数据线，可一次传送16 位数据，所以可一次传送数据 89D8H；而 8088 只有 8 根数据线，一次只能传 8 位数据，所以向内存写入数据 89D8H 时需要进行两次数据传送。



#### 1.10 控制总线

CPU 对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。所以，控制总线的宽度决定了 CPU 对外部器件的控制能力。

前面所讲的内容读或写命令是由几根控制线综合发出的，其中有一根称为 “读信号输出” 的控制线负责由 CPU 向外传送读信号，CPU 向该控制线上输出低电平表示将要读取数据；有一根称为 “写信号输出” 的控制线则负责传送写信号。



#### 1.1~1.10 小结

（1）汇编指令是机器指令的助记符，同机器指令一一对应。

（2）每一种 CPU 都有自己的汇编指令集。

（3）CPU 可以直接使用的信息在存储器中存放。

（4）在存储器中指令和数据没有任何区别，都是二进制信息。

（5）存储单元从零开始顺序编号。

（6）一个存储单元可以存储 8 个 bit，即 8 位二进制数。

（7）1KB=1024B	1MB=1024KB	1GB=1024MB	1TB=1024GB

（8）每一个 CPU 芯片都有许多管脚，这些管脚和总线相连。也可以说，这些管脚引出总线。一个 CPU 可以引出 3 种总线的宽度标志了这个 CPU 的不同方面的性能：

​	地址总线的宽度决定了 CPU 的寻址能力；

​	数据总线的宽度决定了 CPU 与其他器件进行数据传送时的一次数据传送量；

​	控制总线的宽度决定了 CPU 对系统中其他器件的控制能力。



#### 监测点 1.1

1. 1 个 CPU 的寻址能力为 8KB，那么它的地址总线的宽度为____。
   **13**
   解析：CPU 在内存中寻址的最小单位是 Byte（字节），8KB = 2^13^ B，因此地址总线的宽度为 13。
2. 1KB 的存储器有____个存储单元。存储单元的编号从____到____。
   **1024 0 1023**
3. 1KB 的存储器可以存储____个 bit，____个 Byte。
   **2^13^ 2^10^**
4. 1GB、1MB、1KB分别是____________Byte
   **2^30^ 2^20^ 2^10^**
5. 8080、8088、80286、80386 的地址总线宽度分别为 16 根、20 根、24 根、32 根，则他们的寻址能力分别为____（KB）、____（MB）、____（MB）、____（GB）。
   **64 1 16 4**
6. 8080、8088、8086、80286、80386 的数据总线宽度分别为 8 根、8 根、16 根、16 根、32 根。则它们一次可以传送的数据为：____（B）、____（B）、____（B）、____（B）、____（B）。
   **1 1 2 2 4**
7. 从内存中读取 1024 字节的数据，8086 至少要读取____次，80386 至少要读取____次。
   **512 256**
8. 在存储器中，数据和程序以____形式存放。
   **二进制**





#### 1.11	内存地址空间（概述）

什么是内存地址空间呢？举例来讲，一个 CPU 的地址总线宽度为 10，那么可以寻址 1024 个内存单元，这 1024 个可寻到的内存单元就构成这个 CPU 的内存地址空间。下面进行深入讨论。首先需要介绍两部分基本知识，主板和接口卡。



#### 1.12	主	板

在每一台 PC 机中，都有一个主板，主板上有核心器件和一些主要器件，这些器件通过总线（地址总线、数据总线、控制总线）相连。这些器件有 CPU、存储器、外围芯片组、扩展插槽等。扩展插槽上一般插有 RAM 内存条和各类接口卡。



#### 1.13	接	口	卡

计算机系统中，所有可用程序控制其工作的设备，必须受到 CPU 的控制。CPU 对外部设备都不能直接控制，如显示器、音箱、打印机等。直接控制这些设备进行工作的是插在扩展插槽上的接口卡。扩展插槽通过总线和 CPU 相连，所以接口卡也通过总线同 CPU 相连。CPU 可以直接控制这些接口卡，从而实现 CPU 对外设的间接控制。简单地讲，就是 CPU 通过总线向接口卡发送命令，接口卡根据 CPU 的命令控制外设进行工作。



#### 1.14	各类存储器芯片

一台 PC 机中，装有多个存储器芯片，这些存储器芯片从物理连接上看是独立的、不同的器件。从读写属性上看分为两类：随机存储器（RAM）和只读存储器（ROM）。随机存储器可读可写，但必须带电存储，关机后存储的内容丢失；只读存储器只能读取不能写入，关机后其中的内容不丢失。这些存储器从功能和连接上又可以分为以下几类。

- 随机存储器

  用于存放供 CPU 使用的绝大部分程序和数据，主随机存储器一般由两个位置上的 RAM 组成，装在主板上 RAM 和插在扩展插槽上的 RAM。

- 装有 BIOS（Basic Input/Output System，基本输入/输出系统）的 ROM

   BIOS 是由主板和各类接口卡（如显卡、网卡等）厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应 BIOS 的 ROM。例如，主板上的 ROM 中存储着主板的 BIOS（通常称为系统 BIOS）；显卡上的 ROM 中存储着显卡的 BIOS；如果网卡上装有 ROM，那其中就可以存储网卡的 BIOS。

- 接口卡上的 RAM

   某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有 RAM。最典型的是显示卡上的 RAM，一般称为显存。显示卡随时将显存中的数据向显示器上输出。换句话说，我们将需要显示的内容写入显存，就会出现在显示器上。

   

图 1.7 展示了 PC 系统中各类存储器的逻辑连接情况。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE6.jpg"/> </div><br>
#### 1.15	内存地址空间

上述的那些存储器，在物理上是独立的器件，但是在以下两点上相同。

- 都和 CPU 的总线相连。
- CPU 对它们进行读或写的时候，都通过控制线发出内存读写命令。

这也就是说，CPU 在操控它们的时候，把它们都当作内存来对待，把它们总的看作一个由若干存储单元组成的**逻辑存储器**，这个逻辑存储器就是我们所说的内存地址空间。在汇编这门课中，我们所面对的是内存地址空间。

图 1.8 展示了 CPU 将系统中各类存储器看作一个逻辑存储器的情况。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE7.jpg"/> </div><br>
在图 1.8 中，所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU 在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。

假设，图 1.8 中的内存地址空间的地址段分配如下：

地址 0~7FFFH 的 32KB 为主随机存储器的地址空间；

地址 8000H~9FFFH 的 8KB 空间为显存地址空间；

地址 A000H~FFFF 的 24KB 空间为各个 ROM 的地址空间。

 这样，CPU 向内存地址为 1000H 的内存单元中写入数据，这个数据就会被写入主随机存储器中。CPU 向内存地址为 8000H 的内存单元中写入数据，这个数据就被写入到显存中，然后会被显卡输出到显示器上。CPU 向内存地址为 C000H 的内存单元中写入数据的操作，是没有任何结果的。C000H 单元中的内容不会被改变，C000H 单元实际上就是 ROM 存储器中的一个单元。

内存地址空间的大小受 CPU 地址总线宽度的限制。8086CPU 的地址总线宽度为 20，可以传送 2^20^ 个不同的地址信息（大小从 0 至 2^20^ - 1）。即可以定位 2^20^ 个内存单元，则 8086PC 的内存地址空间大小为 1MB。同理，80386CPU 的地址空间宽度为 32，则内存地址空间最大为 4GB。

我们在基于一个计算机硬件系统编程的时候，必须知道这个系统中的内存地址空间分配情况。因为当我们想在某类存储器中读写数据的时候，必须知道它的第一个单元的地址和最后一个单元的地址，才能保证读写操作是在预期的存储器中进行。比如，我们希望向显示器输出一段信息，那么必须将这段信息写到显存中，显卡才能将它输出到显示器上，要向显存中写入数据，必须知道显存在内存地址空间中的地址。

不同的计算机系统的内存地址空间的分配情况是不同的，图 1.9 展示了 8086PC 机内存地址空间分配的基本情况。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE8.jpg"/> </div><br>
图 1.9 告诉我们，从地址 0 ~ 9FFFF 的内存单元中读取数据，实际上就是在读取主随机存储器中的数据；向地址 A0000 ~ BFFFF 的内存单元中写数据，就是向显存中写入数据，这些数据会被显示卡输出到显示器上；我们向地址 C0000 ~ FFFFF 的内存单元中写入数据的操作是无效的，因为这等于改写只读存储器中的内容。

最终运行程序的是 CPU，我们用汇编语言编程的时候，必须要从 CPU 的角度考虑问题。对 CPU 来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受 CPU 寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。

https://docs.qq.com/sheet/DREhUSENWaWtGRWp3?tab=j37kf8&c=K37B0M0



### 第 2 章	寄存器

一个典型的 CPU 由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。前一章所说的总线，相对于 CPU 内部来说是外部总线。内部总线实现 CPU 内部各个器件之间的联系，外部总线实现 CPU 和主板上其他器件的联系。简单地说，在 CPU 中：

- 运算器进行信息处理；
- 寄存器进行信息存储；
- 控制器控制各种器件进行工作；
- 内部总线连接各种器件，在它们之间进行数据的传送。

对于一个汇编程序员来说，CPU 中的主要部件是寄存器。寄存器是 CPU 中程序员可以用指令读写的部件。程序员通过改变各种寄存器中的内容来实现对 CPU 的控制。

不同的 CPU，寄存器的个数、结构是不相同的。8086CPU 有 14 个寄存器，每个寄存器都有一个名称。这些寄存器是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。



AH&AL = AX（accumulator）：累加寄存器

BH&BL = BX（base）：基址寄存器

CH&CL = CX（count）：计数寄存器

DH&DL = DX（data）：数据寄存器

SP（Stack Pointer）：堆栈指针寄存器

BP（Base Pointer）：基址指针寄存器

SI（Source Index）：源变址寄存器

DI（Destination Index）：目的变址寄存器

IP（Instruction Pointer）：指令指针寄存器

CS（Code Segment）：代码段寄存器

DS（Data Segment）：数据段寄存器

SS（Stack Segment）：堆栈寄存器

ES（Extra Segment）：附加段寄存器 OF





#### 2.1	通用寄存器

8086CPU 的所有寄存器都是 16 位的，可以存放两个字节。AX、BX、CX、DX 这 4 个寄存器通常用来存放一般性的数据，被称为通用寄存器。

以 AX 为例，寄存器的逻辑结构如图 2.1 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE9.jpg"/> </div><br>
8086CPU 的上一代 CPU 中的寄存器都是 8 位的，为了保证兼容，使原来基于上代 CPU 编写的程序稍加修改就可以运行在 8086 之上，8086CPU 的 AX、BX、CX、DX 这 4 个寄存器都可分为可独立使用的 8 位寄存器来用：

- AX 可分为 AH 和 AL；

- BX 可分为 BH 和 BL；

- CX 可分为 CH 和 CL；

- DX 可分为 DH 和 DL。

  

以 AX 为例，8086CPU 的 16 位寄存器分为两个 8 位寄存器的情况如图 2.3 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE10.jpg"/> </div><br>
AX 的低 8 位（0 位 ~ 7 位）构成了 AL 寄存器，高 8 位（8 位 ~ 15 位）构成了 AH 寄存器。AH 和 AL 寄存器是可以独立使用的 8 位寄存器。图 2.4 展示了 16 位寄存器及它所分成的两个 8 位寄存器的数据存储的情况。

一个 16 位寄存器可以存储的数据最大值为 65535，一个 8 位寄存器可以存储的数据最大值为 255。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE11.jpg"/> </div><br>
#### 2.2	字在寄存器中的存储

出于对兼容性的考虑，8086CPU 可以一次性处理以下两种尺寸的数据。

- 字节：记为 byte，一个字节由 8 个 bit 组成，可以存在 8 位寄存器中。
- 字：记为 word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节，如图 2.5 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE12.jpg"/> </div><br>
一个字可以存在一个 16 位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高 8 位寄存器和低 8 位寄存器中。如图 2.4 所示，一个字型数据 20000，存在 AX 寄存器中，在 AH 中存储了它的高 8 位，在 AL 中存储了它的低 8 位。AH 和 AL 中的数据，既可以看成是一个字型数据的高 8 位和低 8 位，这个字型数据的大小是 20000；又可以看成是两个独立的字节型数据，它们的大小分别是 78 和 32。





#### 2.3	几条汇编指令

通过汇编指令控制 CPU 进行工作，看一下表 2.1 中的几条指令。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE13.jpg"/> </div><br>
注意，为了使具有高级语言基础的读者更好地理解指令的含义，有时会用文字描述和高级语言描述这两种方式来描述一条汇编指令的含义。在写一条汇编指令或一个寄存器的名称时不区分大小写。如：mov ax,18 和 MOV AX,18 的含义相同：bx 和 BX 的含义相同。





#### 2.4	物理地址

我们知道，CPU 访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址。

CPU 通过地址总线送入存储器的，必须是一个内存单元的物理地址。在 CPU 向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。不同的 CPU 可以有不同的形成物理地址的方式。我们现在讨论 8086CPU 是如何在内部形成内存单元的物理地址的。





#### 2.5	16 位结构的 CPU

我们说 8086CPU 的上一代 CPU（8080、8085）等是 8 位机，而 8086 是 16 位机，也可以说 8086 是 16 位结构的 CPU。那么什么是 16 位结构的 CPU 呢？

概括地讲，16 位结构（16 位机、字长为 16 位等常见说法，与 16 位结构的含义相同）描述了一个 CPU 具有下面几方面的结构特性。

- 运算器一次最多可以处理 16 位的数据；

- 寄存器的最大宽度为 16 位；

- 寄存器和运算器之间的通路为 16 位。

  

8086 是 16 位机构的 CPU，这也就是说，在 8086 内部，能够一次性处理、传输、暂时存储的信息的最大长度是 16 位的。内存单元的地址在送上地址总线之前，必须在 CPU 中处理、传输、暂时存放，对于 16 位 CPU，能一次性处理、传输、暂时存储 16 位的地址。





#### 2.6	8086CPU 给出物理地址的方法

8086CPU 有 20 位地址总线，可以传送 20 位地址，达到 1MB 寻址能力。8086CPU 又是 16 位结构，在内部一次性处理、传输、暂时存储的地址为 16 位。从 8086CPU 的内部结构来看，如果将地址从内部简单地发出，那么它只能送出 16 位的地址，表现出的寻址能力只有 64KB。

8086CPU 采用一种在内部用两个 16 位地址合成的方法来形成一个 20 位的物理地址。

8086CPU 相关部件的逻辑结构如图 2.6 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE14.jpg"/> </div><br>
如图 2.6 所示，当 8086CPU 要读写内存时：

（1）CPU 中的相关部件提供两个 16 位的地址，一个称为段地址，另一个称为偏移地址；

（2）段地址和偏移地址通过内部总线送入一个称为地址加法器的部件；

（3）地址加法器将两个 16 位地址合成为一个 20 位的物理地址；

（4）地址加法器通过内部总线将 20 位物理地址送入输入输出控制电路；

（5）输入输出控制电路将 20 位物理地址送上地址总线；

（6）20 位物理地址被地址总线传送到存储器。



地址加法器采用**物理地址=段地址✖16 + 偏移地址**的方法用段地址和偏移地址合成物理地址。





#### 2.7	“段地址✖16 + 偏移地址=物理地址” 的本质含义

注意，这里讨论的是 8086CPU 段地址和偏移地址的本质含义，而不是为了解决具体的问题，而在本质含义之上引申出来的更高级的逻辑意义。不管以多少种不同的逻辑意义去看待 “段地址×16+偏移地址=物理地址” 的寻址模式，一定要清楚地知道它的本质含义，这样才能更灵活地利用它来分析解决问题。如果只拘泥于某一种引申出来的逻辑含义，而模糊本质含义的话，将从意识上限制对这种寻址功能的灵活应用。

“段地址×16+偏移地址=物理地址” 的本质含义是：CPU 在访问内存时，用一个基础地址（段地址×16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。

更一般地说，8086CPU 的这种寻址功能是 **“基础地址+偏移地址=物理地址”** 寻址模式的一种具体实现方案。8086CPU中，段地址×16可看做是基础地址。





#### 2.8	段的概念

我们注意到，“段地址” 这个名称中包含着 “段” 的概念。这种说法可能对一些学习者产生了误导，使人误以为内存被划分成了一个一个的段，每一个段有一个段地址。如果我们在一开始形成了这种认识，将影响以后对汇编语言的深入理解和灵活应用。

其实，内存并没有分段，段的划分来自于 CPU，由于 8086CPU 用 “基础地址（段地址✖16）+偏移地址=物理地址” 的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。如图 2.9 所示，我们可以认为：地址 10000H~100FFH 的内存单元组成一个段，该段的起始地址（基础地址）为 10000H，段地址为 1000H，大小为 100H；我们也可以认为地址：10000H ~ 1007FH、10080H ~ 100FFH 的内存单元组成两个段，它们的起始地址（基础地址）为：10000H 和 10080H，段地址为：1000H 和 1008H，大小都为 80H。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE15.jpg"/> </div><br>
以后，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址✖16 定位段的起始地址（基础地址），用偏移地址定位段中的内存单元。有两点需要注意：段地址✖16 必然是 16 的倍数，所以一个段的起始地址也一定是 16 的倍数；偏移地址为 16 位，16 位地址的寻址能力为 64KB，所以一个段的长度最大为 64KB。

CPU 访问内存单元时，必须向内存提供内存的那样的物理地址。8086CPU 在内部用段地址和偏移地址移位相加的方法形成最终的物理地址。

（1）CPU 可以用不同的段地址和偏移地址形成同一个物理地址。

（2）如果给定一个段地址，仅通过变化偏移地址来进行寻址，最多可定位多少个内存单元？

偏移地址 16 位，变化范围为 0~FFFFH，仅用偏移地址来寻址最多可寻 64KB 个内存单元。

在 8086PC 机中，存储单元的地址用两个元素来描述，即段地址和偏移地址。

“数据在 21F60H 内存单元中。” 这句话对于 8086PC 机一般不这样讲，取而代之的是两种类似的说法：（1）数据存在内存 2000:1F60 单元中；（2）数据存在内存的 2000H 段中的 1F60H 单元中。这两种描述都表示 ”数据在内存 21F60H 单元中“。

可以根据需要，将地址连续、起始地址为 16 的倍数的一组内存单元定义为一个段。



#### 2.9	段寄存器

我们前面讲到，8086CPU 在访问内存时要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。这里，需要看一下，是什么部件提供段地址。段地址在 8086CPU 的段寄存器中存放。8086CPU 有 4 个段寄存器：CS、DS、SS、ES。

CS（Code Segment）：代码段寄存器

DS（Data Segment）：数据段寄存器

SS（Stack Segment）：堆栈寄存器

ES（Extra Segment）：附加段寄存器 OF

当 8086CPU 要访问内存时由这 4 个段寄存器提供内存单元的段地址。本章中只看一下 CS。



#### 2.10	CS 和 IP

CS（Code Segment）代码段寄存器和 IP（Instruction Pointer）指令指针寄存器是 8086CPU 中两个最关键的寄存器，它们指示了 CPU 当前要读取指令的地址。CS 为代码段寄存器，IP 为指令指针寄存器，从名称上我们可以看出它们和指令的关系。

在 8086PC 机中，任意时刻，设 CS 中的内容为 M，IP 中的内容为 N，8086CPU 将从内存 M✖16+N 单元开始，读取一条指令并执行。

也可以这样表述：8086 机中，任意时刻，CPU 将 CS:IP 指向的内容当作指令执行。

图太多了，略。

通过上面的过程展示，8086 CPU 的工作过程可以简要描述如下。

（1）从 CS:IP 指向的内存单元读取指令，读取的指令进入指令缓冲器；

（2）IP=IP+所读取指令的长度，从而指向下一条指令；

（3）执行指令。转到步骤（1），重复这个过程。

在 8086CPU 加电启动或复位后（即 CPU 刚开始工作时）CS 和 IP 被设置为 CS=FFFFH，IP=0000H，即在 8086PC 机刚启动时，CPU 从内存 FFFF0H 单元中读取指令执行。FFFF0H 单元中的指令是 8086PC 机开机后执行的第一条指令。

现在，我们更清楚了 CS 和 IP 的重要性，它们的内容提供了 CPU 要执行指令的地址。

我们在第 1 章中讲过，在内存中，指令和数据没有任何区别，都是二进制信息，CPU 在工作的时候把有的信息看作指令，有的信息看作数据。现在，如果提出一个问题：CPU 根据什么将内存中的信息看作指令？如何回答？我们可以说，CPU 将 CS:IP 指向的内存单元中的内容看作指令，因为，在任何时候，CPU 将 CS、IP 中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行。如果说，内存中的一段信息曾被 CPU 执行过的话，那么，它所在的内存单元必然被 CS:IP 指向过。 



#### 2.11	修改 CS、IP 的指令

在 CPU 中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对 CPU 的控制。CPU 从何处执行指令是由 CS、IP 中的内容决定的，程序员可以通过改变 CS、IP 中的内容来控制 CPU 执行目标指令。

8086CPU 大部分寄存器的值，都可以用 mov 指令来改变，mov 指令被称为传送指令。但是，mov 指令不能用于设置 CS、IP 的值，原因很简单，因为 8086CPU 没有提供这样的功能。8086CPU 为 CS、IP 提供了另外的指令来改变它们的值。能够改变 CS、IP 的内容的指令被统称为转移指令。我们现在介绍一个最简单的可以修改 CS、IP 的指令：jmp 指令。

若想同时修改 CS、IP 的内容，可用形如 “jmp 段地址：偏移地址” 的指令完成，如

jmp 2AE3:3，执行后：CS=2AE3H，IP=0003H，CPU 将从 2AE33H 处读取指令。

jmp 3:0B16，执行后：CS=0003H，IP=0B16H，CPU 将从 00B46H 处读取指令。

"jmp 段地址：偏移地址" 指令的功能为：用指令中给出的段地址修改 CS，偏移地址修改 IP。

若想仅修改 IP 的内容，可用形如 "jmp 某一合法寄存器" 的指令完成，如

jmp ax，指令执行前：ax=1000H，CS=2000H，IP=0003H

​				指令执行后：ax=1000H，CS=2000H，IP=1000H

jmp bx，指令执行前：bx=0B16H，CS=2000H，IP=0003H

​				指令执行后：bx=0B16H，CS=2000H，IP=0B16H

"jmp 某一合法寄存器" 指令的功能为：用寄存器中的值修改 IP。

jmp ax，在含义上好似：mov IP,ax。

注意，我们在适当的时候，会用已知的汇编指令的语法来描述新学的汇编指令的功能。采用一种 "用汇编解释汇编" 的方法来使读者更好地理解汇编指令的功能，这样做有助于读者进行知识的相互融会。要强调的是，我们是用 "已知的汇编指令的语法" 进行描述，并不是用 "已知的汇编指令" 来描述，比如，我们用 mov IP,ax 来描述 jmp ax，并不是说真有 mov IP,ax 这样的指令，而是用 mov 指令的语法来说明 jmp 指令的功能。我们可以用同样的方法描述 jmp 3:01B6 的功能：jmp 3:01B6 在含义上好似 mov CS,3  mov IP,01B6。



#### 2.12	代码段

前面讲过，对于 8086PC 机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为 N（N≤64KB）的一组代码，存放一组地址连续、起始地址为 16 的倍数的内存单元中，我们可以认为，这段内存是用来存放代码的，从而定义了一个代码段。

```assembly
mov ax,0000   (B8 00 00)
add ax,0123H  (05 23 01)
mov bx,ax     (8B D8)
jmp bx        (FF E3)
```



这段长度为 10 个字节的指令，存放在 123B0H~123B9H 的一组内存单元中，我们就可以认为，123B0H~123B9H 这段内存是用来存放代码的，是一个代码段，它的段地址为 123BH，长度为 10 个字节。

如何使得代码段中的指令被执行呢？将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU 并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。CPU 只认被 CS:IP 指向的内存单元中的内容为指令。所以，要让 CPU 执行我们放在代码段中的指令，必须要将 CS:IP 指向所定义的代码段中的第一条指令的首地址。如上面的例子，我们将一段代码存放在 123B0H~123B9H 内存单元中，将其定义为代码段，如果要让这段代码得到指向，可设 CS=123BH、IP=0000H。



#### 实验 1	查看 CPU 和内存，用机器指令和汇编指令编程

（1）什么是 Debug？

Debug 是 DOS、windows 都提供的实模式（8086 方式）程序的调试工具。使用它，可以查看 CPU 各种寄存器中的内容、内存的情况和在机器码级跟踪程序的运行。

（2）我们用到的 Debug 功能。

- 用 Debug 的 R 命令查看、改变 CPU 寄存器的内容；

- 用 Debug 的 D 命令查看内存中的内容；

- 用 Debug 的 E 命令改写内存中的内容；

- 用 Debug 的 U 命令将内存中的机器指令翻译成汇编指令；

- 用 Debug 的 T 命令执行一条机器指令；

- 用 Debug 的 A 命令以汇编指令的格式在内存中写入一条机器指令。

  

Debug 的命令比较多，共有 20 多个，但这 6 个命令是和汇编学习密切相关的。在以后的实验中，我们还会用到一个 P 命令。

（3）进入 Debug

高等级的 win10 系统不支持 Debug，需要下载安装 DOSBox。



（4）用 R 命令查看、改变 CPU 寄存器的内容。

（5）用 Debug 的 D 命令查看内存中的内容。

要查看内存 10000H 处的内容，首先将这个地址表示为段地址:偏移地址的格式，可以是 1000:0，然后用 “d 1000:0” 列出 1000:0 处的内容。

使用 "d 段地址:偏移地址" 的格式，Debug 将列出从指定内存单元开始的 128 个内存单元的内容。如图 2.34 所示，在使用 d 1000:0 后，Debug 列出了 1000:0~1000:7F 中的内容。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE16.jpg"/> </div><br>
1. 中间是从指定地址开始的 128 个内存的单元的内容，用十六进制的格式输出，每行的输出从 16 的整数倍的地址开始，最多输出 16 个单元的内容。
2. 左边是每行的起始地址。
3. 右边是每个内存单元中的数据对应的可显示的 ASCII 码字符。



在以进入 Debug 后，用 D 命令直接查看，将列出 Debug 预设的地址出处的内容。在使用 "d 段地址:偏移地址" 之后，接着使用 D 命令，可列出后续的内容。也可以指定 D 命令的查看范围，此时采用 "d 段地址:偏移地址 结尾偏移地址" 的格式。比如要看 1000:0~1000:9 中的内容，可以用 "d 1000:0 9" 实现。



（6）用 Debug 的 E 命令改写内存中的内容。

（7）用 E 命令向内存中写入机器码，用 U 命令查看内存中机器码的含义，用 T 命令执行内存中的机器码。

（8）用 Debug 的 A 命令以汇编指令的形式在内存中写入机器指令。







### 第 3 章	寄存器（内存访问）

第 2 章钟，我们主要从 CPU 如何执行指令的角度讲解了 8086CPU 的逻辑结构、形成物理地址的方法、相关的寄存器以及一些指令。这一章中，我们从访问内存的角度继续学习几个寄存器。



#### 3.1	内存中字的存储

CPU 中，用 16 位寄存器来存储一个字。高 8 位存放高位字节，低 8 位存放低位字节。在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元来存放，这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。

我们提出字单元的概念：字单元，即存放一个字型数（16 位）的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。

在以后的课程中，我们将起始地址为 N 的字单元简称为 N 地址字单元。比如一个子单元由 2、3 两个内存单元组成，则这个字单元的起使地址为 2，我们可以说这是 2 地址字单元。



#### 3.2	DS 和 [address]

CPU 要读写一个内存单元的时候，必须先给出这个内存单元的地址，在 8086PC 中，内存地址由段地址和偏移地址组成。8086CPU 中有一个 DS 寄存器，DS（Data Segment）：数据段寄存器，通常用来存放要访问数据的段地址。比如我们要读取 10000H 单元的内容，可以用如下的程序段进行。

```assembly
mov bx,1000H
mov ds,bx
mov al,[0]
```



上面的 3 条指令将 1000H(1000:0) 地址中的数据读到 a1 中。

下面详细说明指令的含义。

mov a1,[0]

前面我们使用 mov 指令，可完成两种传送：1.将数据直接送入寄存器；2.将一个寄存器中的内存送入另一个寄存器。

也可以使用 mov 指令将一个内存单元中的内容送入一个寄存器中。从哪一个内存单元送到哪一个寄存器中呢？在指令中必须指明。寄存器用寄存器名来指明，内存单元则需用内存单元的地址来指明。显然，此时 mov 指令的格式应该是：mov 寄存器名，内存单元地址。

[...] 表示一个内存的那样，[...] 中的 0 表示内存单元的偏移地址。我们知道，只有偏移地址是不能定位一个内存单元的，那么内存单元的段地址是多少呢？指令执行时，8086CPU 自动取 ds 中的数据为内存单元的段地址。

因为 8086CPU 不支持将数据直接送入段寄存器的操作，ds 是一个段寄存器，所以 mov ds,1000H 这条指令是非法的。那么如何将 1000H 送入 ds 呢？只好用一个寄存器来进行中转，即先将 1000H 送入一个一般的寄存器，如 bx，再将 bx 中的内容送入 ds。





### 3.3	字 的 传 送

前面我们用 mov 指令在寄存器和内存之间进行字节型数据的传送。因为 8086CPU 是 16 位结构，有 16 根数据线，所以，可以一次性传送 16 位的数据，也就是说可以一次性传送一个字。只要在 mov 指令中给出 16 位的寄存器就可以进行 16 位数据的传送了。比如：

```assembly
mov bx,1000H
mov ds,bx
mov ax,[0]	;1000:0 处的字型数据送入 ax
mov [0],cx  ;cs 中的 16 位数据送到 1000:0 处
```



#### 3.4	mov、add、sub 指令

前面我们用到了 mov、add、sub 指令，它们都带有两个操作对象。

到现在，我们知道，mov 指令可以有以下几种形式。

mov	寄存器，数据			比如：mov ax,8

mov	寄存器，寄存器		比如：mov ax,bx

mov	寄存器，内存单元    比如：mov ax,[0]

mov	内存单元，寄存器	比如：mov [0],ax

mov	段寄存器，寄存器	比如：mov ds,ax

我们可以根据这些已知指令进行下面的推测。

（1）既然有 “mov 段寄存器，寄存器”，那么也该有 "mov 寄存器，段寄存器"。

（2）既然有 “mov 内存单元，寄存器”，那么也该有 "mov 内存单元，段寄存器"

（3）“mov 段寄存器，内存单元” 也应该可行。



add 和 sub 指令同 mov 一样，都有两个操作对象。它们也可以有以下几种形式。

add  寄存器，数据          	 比如：add ax,8

add  寄存器，寄存器           比如：add ax,bx 

add  寄存器，内存单元       比如：add ax,[0] 

add  内存单元，寄存器       比如：add [0],ax 

sub  寄存器，数据               比如：sub ax,9 

sub  寄存器，寄存器           比如：sub ax,bx 

sub  寄存器，内存单元       比如：sub ax,[0] 

sub  内存单元，寄存器       比如：sub [0],ax



#### 3.5	数 据 段

前面讲过（参见 2.8 节）。对于 8086PC 机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将一组长度为 N（N≤64KB）、地址连续、起始地址为 16 的倍数的内存单元当作专门存储数据的内存单元，从而定义了一个数据段。比如用 123B0H~123B9H 这段内存空间来存放数据，我们就可以认为，123B0H~123B9H 这段内存是一个数据段，它的段地址为 123BH，长度为 10 个字节。

如何访问数据段中的数据呢？将一段内存当作数据段，是我们在编程时的一种安排，可以在具体操作的时候，用 ds 存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。

比如，将 123B0H~123B9H 的内存单元定义为数据段。现在要累加这个数据段中的前 3 个单元中的数据，代码如下。

```assembly
mov ax,123BH
mov ds,ax		;将 123BH 送入 ds 中，作为数据段的段地址
mov al,0		;用 al 存放累加结果
add al,[0]		;将数据段第一个单元{偏移地址为 0}中的数值加到 al 中
add al,[1]		;将数据段第二个单元{偏移地址为 1}中的数值加到 al 中
add al,[2]		;将数据段第三个单元{偏移地址为 2}中的数值加到 al 中
```



#### 3.1~3.5	小	结

（1）字再内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。

（2）用 mov 指令访问内存单元，可以在 mov 指令中只给出单元的偏移地址，此时，段地址默认在 DS 寄存器中。

（3）[address] 表示一个偏移地址为 address 的内存单元。

（4）在内存和寄存器之间传送字型数据时，高地址单元和高 8 位寄存器、低地址单元和低 8 位寄存器相对应。

（5）mov、add、sub 是具有两个操作对象的指令。jmp 是具有一个操作对象的指令。

（6）可以根据自己的推测，在 Debug 中实验指令的新格式。





#### 3.6	栈

在这里，我们对栈的研究仅限于这个角度：栈是一种具有特殊的访问方式的存储空间。它的特殊性就在于，最后进入这个空间的数据，最先出去。

从程序化的角度来讲，应该有一个标记，这个标记一直指示着栈顶的元素。

栈有两个基本的操作：入栈和出栈。入栈就是将要给新的元素放到栈顶，出栈就是从栈顶取出一个元素。栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。栈的这种操作被称为LIFO（Last In First Out，后进先出）。



#### 3.7	CPU 提供的栈机制

现今的 CPU 中都有栈的设计，8086CPU 也不例外。8086CPU 提供相关的指令来以栈的方式访问内存空间。这意味着。在基于 8086CPU 编程的时候，可以将一段内存当作栈来使用。

8086CPU 提供入栈和出栈指令，最基本的两个是 PUSH（入栈）和 POP（出栈）。比如，push ax 表示将寄存器 ax 中的数据送入栈中，pop ax 表示从栈顶取出数据送入 ax。8086CPU 的入栈和出栈操作都是以字为单位进行的。

下面举例说明，我们可以将 10000H~1000FH 这段内存当作栈来使用。

图 3.9 描述了下面一段指令的执行过程。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE17.jpg"/> </div><br>
```assembly
mov ax,0123H
push ax
mov bx,2266H
push bx
mov cx,1122H
push cx
pop ax
pop bx
pop cx
```



注意，字型数据用两个单元存放，高地址存放高 8 位，低地址单元存放低 8 位。

读者看到图 3.9 所描述的 push 和 pop 指令的执行过程，是否有一些疑惑？总结一下，大概是这两个问题。

第一，我们将 10000H~1000FH 这段内存当作栈来使用，CPU 执行 push 和 pop 指令时，将对这段空间按照栈的后进先出的规则进行访问。但是，一个重要的问题是，CPU 如何知道 10000H~1000FH 这段空间被当作栈来使用？

第二，push ax 等入栈指令执行时，要将寄存器中的内容放入当前栈顶单元的上方，成为新的栈顶元素；pop ax 等指令执行时，要从栈顶单元中取出数据，送入寄存器中。显然，push、pop 在执行的时候，必须知道哪个单元是栈顶单元，可是，如何知道呢？

这不禁让我们想起另外一个讨论过的问题，就是，CPU 如何知道当前要执行的指令所在的位置？我们现在知道答案，那就是 CS、IP 中存放着当前指令的段地址和偏移地址。现在的问题是：CPU 如何知道栈顶的位置？显然，也应该有相应的寄存器来存放栈顶的地址，8086CPU 中，有两个寄存器，段寄存器 SS 和寄存器 SP，SS（Stack Segment）：堆栈寄存器，SP（Stack Pointer）：堆栈指针寄存器，栈顶的段地址存放在 SS 中，偏移地址存放在 SP 中。**任意时刻，SS:SP 指向栈顶元素**。push 指令和 pop 指令执行时，CPU 从 SS 和 SP 中得到栈顶的地址。

现在，我们可以完整地描述 push 和 pop 指令的功能了，例如 push ax。

push ax 的执行，由以下两步完成。

（1）SP=SP-2，SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；

（2）将 ax 中的内容送入 SS:SP 指向的内存单元处，SS:SP 此时指向新栈顶。

图 3.10 描述了 8086CPU 对 push 指令的执行过程。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE18.jpg"/> </div><br>
从图中我们可以看出，8086CPU 中，入栈时，栈顶从高地址向低地址方向增长。

接下来，我们描述 pop 指令的功能，例如 pop ax。

pop ax 的执行过程和 push ax 刚好相反，由以下两步完成。

（1）将 SS:SP 指向的内存单元处的数据送入 ax 中；

（2）SP=SP+2，SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。

图 3.12 描述了 8086CPU 对 pop 指令的执行过程。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE19.jpg"/> </div><br>
注意，图 3.12 中，出栈后，SS:SP 指向新的栈顶 1000EH，pop 操作前的栈顶元素，1000CH 处的 2266H 依然存在，但是，它已不在栈中。当再次执行 push 等入栈指令后，SS:SP 移至 1000CH，并在里面写入新的数据，它将被覆盖。





#### 3.8	栈顶超界的问题

我们现在知道，8086CPU 用 SS 和 SP 指示栈顶的地址，并提供 push 和 pop 指令实现入栈和出栈。

但是，还有一个问题需要讨论，就是 SS 和 SP 只是记录了栈顶的地址，依靠 SS 和 SP 可以保证在入栈和出栈时找到栈顶。可是，如何能够保证在入栈、出栈时，栈顶不会超出栈空间？

图 3.13 描述了在执行 push 指令后，栈顶超出栈空间的情况。图 3.14 描述了在执行 pop 指令后，栈顶超出栈空间的情况。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE20.jpg"/> </div><br>
上面描述了执行 push、pop 指令时，发生的栈顶超界问题。可以看到，当栈满的时候再使用 push 指令入栈，或栈空的时候再使用 pop 指令出栈，都将发生栈顶超界问题。

栈顶超界是最危险的，因为我们既然将一段空间安排为栈，那么在栈空间之外的空间里很可能存放了具有其他用途的数据、代码等，这些数据、代码可能是我们自己程序中的，也可能是别的程序中的（毕竟一个计算机系统中并不是只有我们自己的程序在运行）。但是由于我们在入栈出栈时的不小心，而将这些数据、代码意外地改写，将会引发一连串的错误。

我们当然希望 CPU 可以帮我们解决这个问题，比如说在 CPU 中有记录栈顶上限和栈底的寄存器，我们可以通过填写这些寄存器来指定栈空间的范围，然后，CPU 在执行 push 指令的时候靠检测栈顶上限寄存器、在执行 pop 指令的时候靠检测栈底寄存器保证不会超界。

不过，对于 8086CPU，这只是我们的一个设想（我们当然可以这样设想，如果 CPU 是我们设计的话，这也就不仅仅是一个设想）。实际的情况是，8086CPU 中并没有这样的寄存器。

8086CPU 不保证我们对栈的操作不会超界。这也就是说，8086CPU 只知道栈顶在何处（由 SS:SP 指示），而不知道我们安排的栈空间有多大。这点就好像 CPU 只知道当前要执行的指令在何处（由 CS:IP 指示），而不知道要执行的指令有多少。从这两点上我们可以看出 8086CPU 的工作机理，它只考虑当前的情况：当前的栈顶在何处、当前要执行的指令是哪一条。

我们在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致的超界；执行出栈操作的时候也要注意，以防栈空的时候继续出栈而导致的超界。



#### 3.9	push、pop 指令

前面我们一直在使用 push ax 和 pop ax，显然 push 和 pop 指令是可以在寄存器和内存（栈空间当然也是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间。）之间传送数据的。

push 和 pop 指令的格式可以是如下形式：

```assembly
push	寄存器		;将一个寄存器中的数据入栈
pop		寄存器		;出栈，用一个寄存器接收出栈的数据
```



当然也可以是如下形式：

```assembly
push	段寄存器	;将一个段寄存器中的数据入栈
pop		段寄存器	;出栈，用一个段寄存器接收出栈的数据
```



push 和 pop 也可以在内存单元和内存单元之间传送数据，我们可以：

```assembly
push	内存单元	 ;将一个内存字单元处的字入栈（注意：栈操作都是以字为单位）
pop		内存单元  	 ;出栈，用一个内存字单元接收出栈的数据
```



比如：

```assembly
mov ax,1000H
mov ds,ax		;内存单元的段地址要放在 ds 中
push [0]		;将 1000:0 处的字压入栈中
pop	 [2]		;出栈，出栈的数据送入 1000:2 处
```



指令执行时，CPU 要知道内存单元的地址，可以在 push、pop 指令中只给出内存单元的偏移地址，段地址在指令执行时，CPU 从 ds 中取得。

与 CS 一样，SS 不能直接通过 mov 传送数据，需要通过寄存器中转；但是与 IP 不一样，SP 可以直接用 mov 传送数据。

用栈来暂存以后需要恢复的寄存器中的内容时，出栈的顺序和入栈的顺序相反，因为最后入栈的寄存器的内容在栈顶，所以在恢复时，要最先出栈。

push、pop 指令实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与 mov 指令不同的是，push 和 pop 指令访问的内存单元的地址不是在指令中给出的，而是由 SS:SP 指出的。同时，push 和 pop 指令还要改变 SP 中的内容。

我们要十分清楚的是，push 和 pop 指令同 mov 指令不同，CPU 执行 mov 指令只需一步操作，就是传送，而执行 push、pop 指令却需要两步操作。执行 push 时，CPU 的两步操作是：先改变 SP，后向 SS:SP 处传送。执行 pop 时，CPU 的两步操作是：先读取 SS:SP 处的数据，后改变 SP。

注意，push，pop 等栈操作指令，修改的只是 SP。也就是说，栈顶的变化范围最大为：0~FFFFH。

提供：SS、SP 指示栈顶：改变 SP 后写内存的入栈ss指令；读内存后改变 SP 的出栈指令。这就是 8086CPU 提供的栈操作机制。



#### 栈 的 综 述

（1）8086CPU 提供了栈操作机制，方案如下。

在 SS、SP 中存放栈顶的段地址和偏移地址；

提供入栈和出栈指令，它们根据 SS:SP 指示的地址，按照栈的方式访问内存单元。

（2）push 指令的执行步骤：1.SP=SP-2；2.向 SS:SP 指向的字单元中传入数据。

（3）pop 指令的执行步骤：1.从 SS:SP 指向的字单元中读取数据；2.SP=SP+2。

（4）任意时刻，SS:SP 指向栈顶元素。

（5）8086CPU 只记录栈顶，栈空间的大小我们要自己管理。

（6）用栈来暂存以后需要恢复的寄存器的内容时，寄存器出栈的顺序要和入栈的顺序相反。

（7）push、pop 实质上是一种内存传送指令，注意它们的灵活应用。

栈是一种非常重要的机制，一定要深入理解，灵活掌握。





#### 3.10	栈	段

前面讲过（参见 2.8 节），对于 8086PC 机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为 N(N≤64KB，2^16^) 的一组地址连续、起始地址为 16 的倍数的内存单元，当作栈空间来用，从而定义了一个栈段。比如，我们将 10010H~1001FH 这段长度为 16 字节的内存空间当作栈来用，以栈的方式进行访问。这段空间就可以称为一个栈段，段地址为 1001H，大小为 16 字节。

将一段内存当作栈段，仅仅是我们在编程时的一种安排，CPU 并不会由于这种安排，就在执行 push、pop 等栈操作指令时自动地将我们定义的栈段当作栈空间来访问。如何使得如 push、pop 等栈操作指令访问我们定义的栈段呢？前面我们已经讨论过，就是要将 SS:SP 指向我们定义的栈段。



#### 问题	3.11

如果将 1000H~1FFFFH 这段空间当作栈段，初始这条栈是空的，此时，SS=1000H，SP=？

分析：

1.【1000H~1FFFFH 这段空间当作栈】

栈满时，栈顶标记指向 1000H。

栈为空的话，栈顶标记指向 1FFFFH+2=20000H

2.【初始状态是空的】

栈顶标记指向 20000H，SS=1000H，SP 肯定等于 0000H。因为栈顶的变化范围是：0~FFFFH。



#### 问题	3.12

一个栈段最大可以设为多少？为什么？

分析：这个问题显而易见，提出来只是为了提示我们将相关的知识融会起来。首先从栈操作指令所完成的功能的角度上来看，push、pop 等指令在执行的时候只修改 SP，所以栈顶的变化范围是 0~FFFFH，从栈空时候的 SP=0，一直压栈，直到栈满时 SP=0；如果再次压栈，栈顶将环绕，覆盖了原来栈中的内容。所以一个栈段的容量最大为 64KB。



#### 段 的 综 述

我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排。

我们可以用一个段存放数据，将它定义为 “数据段”。

我们可以用一个段存放代码，将它定义为 “代码段”。

我们可以用一个段当作栈，将它定义为 “栈段”。

我们可以这样安排，但若要让 CPU 按照我们的安排来访问这些段，就要：

对于数据段，将它的段地址放在 DS 中，用 mov、add、sub 等访问内存单元的指令时，CPU 就将我们定义的数据段中的内容当作数据来访问。

对于代码段，将它的段地址放在 CS 中，将段中的第一条指令的偏移地址放在 IP 中，这样CPU 就将执行我们定义的代码段中的指令。

对于栈段，将它的地址放在 SS 中，将栈顶单元的偏移地址放在 SP 中，这样 CPU 在需要进行栈操作的时候，比如执行 push、pop 指令等，就将我们定义的栈段当作栈空间来用。

可见，不管我们如何安排，CPU 将内存中的某段代码当作代码，是因 CS:IP 指向了哪里；CPU 将某段内容当作栈，是因为 SS:SP 指向了哪里。我们一定要清楚，什么是我们的安排，以及如何让 CPU 按我们的安排行事。要非常清楚 CPU 的工作机理，才能在控制 CPU 按照我们的安排运行的时候做到游刃有余。

比如我们将 10000H~1001FH 安排为代码段，并在里面存储如下代码：

```assembly
mov ax,1000H
mov ss,ax
mov sp,0029H	;初始化栈顶
mov ax,cs		
mov ds,ax		;设置数据段地址
mov ax,[0]
add ax,[2]
mov bx,[4]
add bx,[6]
push ax
push bx
pop ax
pop bx
```



设置 CS=1000H，IP=0，这段代码将得到执行。可以看到，在这段代码中，我们又将 10000H~1001FH 安排为栈段和数据段。10000H~1001FH 这段内存，既是代码段，又是栈段和数据段。

一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。关键在于 CPU 中寄存器的设置，即 CS、IP，SS、SP，DS 的指向。





#### 实验 2	用机器指令和汇编指令编程

**1.预备知识：Debug 的使用**

前面实验中，讲了 Debug 的一些主要命令的用法，这里，再补充一些关于 Debug 的知识。

（1）关于 D 命令。

从上次实验中，我们知道，D 命令是查看内存单元的命令，可以用：

“d 段地址:偏移地址” 的格式查看指定的内存单元的内容，上次实验中，D 命令后面的段地址和偏移地址都是直接给出的。

现在，我们知道段地址是放在段寄存器中的，在 D 命令后面直接给出段地址，是 Debug 提供的一种直观的操作方式。D 命令是由 Debug 执行的，Debug 在执行 “d 1000:0” 这样的命令时，也会先将段地址 1000H 送入段寄存器中。

Debug 是靠什么来执行 D 命令的？当然是一段程序。

谁来执行这段程序？当然是 CPU。

CPU 在访问内存单元的时候从哪里得到内存单元的段地址？从段寄存器中得到。

所以，Debug 在其处理 D 命令的程序段中，必须有将段地址送入段寄存器的代码。

段寄存器有 4 个：CS、DS、SS、ES，将段地址送入哪个段寄存器呢？

首先不能是 CS，因为 CS:IP 必须指向 Debug 处理 D 命令的代码，也不能是 SS，因为 SS:SP 要指向栈顶。这样只剩下了 DS 和 ES 可以选择，放在哪里呢？我们知道，访问内存的指令如 "mov ax,[0]" 等一般都默认段地址在 ds 中，所以 Debug 在执行如 "d 段地址:偏移地址" 这种 D 命令时，将段地址送入 ds 中比较方便。

D 命令也提供了一种符合 CPU 机理的格式：“d 段寄存器:偏移地址”，以段寄存器中的数据为段地址 SA，列出从 SA:偏移地址开始的内存区间中的数据。以下是几个例子。

```assembly
-r ds
:1000
-d ds:0			;查看从 1000:0 开始的内存区间中的内容

-r ds
:1000
-d ds:10 18		;查看 1000:10~1000:18 中的内容

-d cs:0			;查看当前代码段中的指令代码
-d ss:0			;查看当前栈段中的内容
```



（2）在 E、A、U 命令中使用段寄存器。

在 E、A、U 这些可以带有内存单元地址的命令中，也可以同 D 命令一样，用段寄存器表示内存单元的段地址，以下是几个例子。

```assembly
-r ds
:1000
-e ds:0 11 22 33 44 55 66	;在从 1000:0 开始的内存区间中写入数据

-u cs:0						;以汇编指令的形式，显示当前代码段中的代码，0 代码的偏移地址

-r ds
:1000
-a ds:0						;以汇编指令的形式，向从 1000:0 开始的内存的那样中写入指令
```



（3）下一条指令执行了吗

在 Debug 中，用 A 命令写一段程序：

```assembly
mov ax,2000
mov ss,ax
mov sp,10		;安排 2000:0000~2000:000F 为栈空间，初始化栈顶

mov ax,3123
push ax
mov ax,3366
push ax			;在栈中压入两个数据
```



仔细看一下图 3.18 中单步执行的结果，你发现了什么问题？

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE21.jpg"/> </div><br>
在用 T 命令单步执行 mov ax,2000 后，显示出当前 CPU 各个寄存器的状态和下一步要执行的指令：mov ss,ax；

在用 T 命令单步执行 mov ss,ax 后，显示出当前 CPU 各个寄存器的状态和下一步要执行的指令……，在这里我们发现了一个问题：mov ss,ax 的下一条指令应该是 mov sp,10，怎么变成了 mov ax,3123？

mov sp,10 到哪里去了？它被执行了吗？

我们再仔细观察，发现：

在程序执行前，ax=0000，ss=0b39，sp=ffee

在用 T 命令单步执行 mov ax,2000 后，ax=2000；ss=0b39；sp=ffee

在用 T 命令单步执行 mov ss,ax 后，ax=2000；ss=2000；sp=0010

注意，在用 T 命令单步执行 mov ss,ax 前，ss=0b39，sp=ffee，而执行后 ss=2000，sp=0010。
ss 变为 2000 是正常的，这正是 mov ss,ax 的执行结果。可是 sp 变为 0010 是怎么回事？在这期间，能够将 sp 设为 0010 的只有指令 mov sp,10，看来，mov sp,10 一定是得到了执行。

那么，mov sp,10 是在什么时候被执行的呢？当然是在 mov ss,ax 之后，因为它就是 mov ss,ax 的下一条指令。显然，在用 T 命令执行 mov ss,ax 的时候，它的下一条指令 mov sp,10 也紧接着执行了。

整理一下我们分析的结果：在用 T 命令执行 mov ss,ax 的时候，它的下一条指令 mov sp,10 也紧接着执行了。一般情况下，用 T ml执行一条指令后，会停止继续执行，显示出当前 CPU 各个寄存器的状态和下一步要执行的指令，但 T 命令执行 mov ss,ax 的时候，没有做到这一点。

不单是 mov ss,ax，对于如 mov ss,bx，mov ss,[0]，pop ss 等指令都会发生上面的情况，这些指令有哪些共性呢？它们都是修改栈段寄存器 SS 的指令。

为什么会这样呢？要想彻底说清楚这里面的来龙去脉，在这里还为时过早，因为这涉及我们在以后的课程中要深入研究的内容：中断机制，它是我们后半部分课程的一个主要主题。现在我们只要知道这一点就可以了：Debug 的 T 命令在执行修改寄存器 SS 的指令时，下一条指令也紧接着被执行。





### 第 4 章	第一个程序

终于可以编写第 1 个完整的程序了，我们以前都是在 Debug 中写一些指令，在 Debug 中执行。现在我们将开始编写完整的汇编语言程序，用编译和连接程序将它们编译连接成为可执行文件（如 *.exe 文件），在操作系统中运行。这一章中，我们将编写第一个这样的程序。为了能够透彻地理解一个完整的程序（尽管它看上去十分简单），我们将经历一个漫长的过程。



#### 4.1	一个源程序从写出到执行的过程

图 4.1 描述了一个汇编语言程序从写出到最终执行的简要过程。具体说明如下。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE22.jpg"/> </div><br>
第一步：编写汇编源程序。

使用文本编辑器，用汇编语言编写汇编程序。

这一步工作的结果是产生了一个存储源程序的文本文件。

第二步：对源程序进行编译连接。

使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件；再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件。

可执行文件包含两部分内容。

- 程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）
- 相关的描述信息（比如，程序有多大、要占用多少内存空间等）

这一步工作的结果：产生了一个可在操作系统中运行的可执行文件。

第三步：执行可执行文件中的程序。

在操作系统中，执行可执行文件中的程序。

操作系统按照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如蛇者 CS:IP 指向第一条要执行的指令），然后由 CPU 执行程序。

下面我们将通过学习一个简单的程序来经历图 4.1 中所描述的过程。



#### 4.2	源	程	序

下面就是一段简单的汇编语言源程序。

**程序	4.1**

```assembly
assume cs:codesg
codesg segment
		mov ax,0123H
		mov bx,0456H
		add ax,bx
		add ax,ax
		
		mov ax,4c00H
		int 21H
		
codesg ends
end
```



下面对程序进行说明。

**1.伪指令**

在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为 CPU 所执行。而伪指令没有对应的机器指令，最终不被 CPU 所执行。那么谁来执行伪指令呢？伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。

程序 4.1 中出现了 3 种伪指令。

（1）XXX segment

​		  ...

​		  XXX ends

segment 和 ends 是一对成对使用的伪指令，这是在写可变编译器编译的汇编程序时，必须要用到的一对伪指令。segment 和 ends 的功能是定义一个段，segment 说明一个段开始，ends 说明一个段结束。一个段必须有一个名称来标识，使用格式为：

段名 segment

...

段名 ends



比如，程序 4.1 中的：

codesg segment	；定义一个段，段的名称为 "codesg"，这个段从此开始

..

codesg ends			;名称为 "codesg" 的段到此结束

一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。我们在前面的课程中所讲解的段的概念，在汇编源程序中得到了应用与体现，一个源程序中所有将被计算机所处理的信息：指令、数据、栈，被划分到了不同的段中。

一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。

我们可以看到，程序 4.1 中，在 codesg segment 和 codesg ends 之间写的汇编指令是这个段中存放的内容，这是一个代码段（其中还有我们不认识的指令，后面会进行讲解）。



（2）end

end 是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令 end，就结束对源程序的编译。所以，在我们写程序的时候，如果程序写完了，要在结尾处加上伪指令 end。否则，编译器在编译程序时，无法知道程序在何处结束。

注意，不要搞混了 end 和 ends，ends 是和 segment 成对使用的，标记一个段的结束，ends 的含义可理解为 “end segment”。我们这里讲的 end 的作用是标记整个程序的结束。



（3）assume

这条伪指令的含义为 “假设”。它假设某一段寄存器和程序中的某一个用 segment..ends 定义的段相关联。通过 assume 说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。assume 并不是一条非要深入理解不可的伪指令，以后我们编程时，记着用 assume 将有特定用途的段和相关的段寄存器关联起来即可。

比如，在程序 4.1 中，我们用 codesg segment ... codesg ends 定义了一个名为 codesg 的段，在这个段中存放代码，所以这个段是一个代码段。在程序的开头，用 assume cs:codesg 将用作代码段的段 codesg 和 CPU 中的段寄存器 cs 联系起来。



**2.源程序中的程序**

用汇编语言写的源程序，包括伪指令和汇编指令，我们编程的最终目的是让计算机完成一定的任务。源程序中的汇编指令组成了最终由计算机执行的程序，而源程序中的伪指令是由编译器来处理的，它们并不实现我们编程的最终目的。这里所说的程序就是值源程序中最终由计算机来执行、处理的指令或数据。

注意，以后可以将源程序文件中得所有内容称为源程序，将源程序中最终由计算机执行、处理的指令或数据，称为程序。程序最先以汇编指令得形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中。这个过程如图 4.2 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE23.jpg"/> </div><br>
**3.标号**

汇编源程序中，除了汇编指令和伪指令外，还有一些标号，比如 “codesg”。一个标号指代了一个地址。比如 codesg 在 segment 的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。



**4.程序的结构**

我们现在讨论一下汇编程序的结构。在前 3 章中，我们都是通过直接在 Debug 中写入汇编指令来写汇编程序，对于十分简短的程序这样做的确方便。可对于大一些的程序，就不能如此了。我们需要写出能让编译器进行编译的源程序，这样的源程序应该聚呗起码的结构。

源程序是一些段构成的。我们可以在这些段中存放代码、数据、或将某个段当作栈空间。我们现在来一步步地完成一个小程序，从这个过程中体会一下汇编程序中的基本要素和汇编程序的简单框架。

任务：编程运算 2^3。源程序应该怎样来写呢？

（1）我们要定义一个段，名称为 abc。

```assembly
abc segment

..

abc ends
```



（2）在这个段中写入汇编指令，来实现我们的任务。

```assembly
abc segment
 mov ax,2
 add ax,ax
 add ax,ax
abc ends
```



（3）然后，要指出程序在何处结束。

```assembly
abc segment
 mov ax,2
 add ax,ax
 add ax,ax
abc ends 

end
```



（4）abc 被当作代码段来用，所以，应该将 abc 和 cs 联系起来。（当然，对于这个程序，也不是非这样做不可。）

```assembly
assume cs:abc

abc segment
 mov ax,2
 add ax,ax
 add ax,ax
abc ends 

end
```



最终写成的程序如程序 4.2 所示。

**程序 4.2**

```assembly
assume cs:abc

abc segment
 mov ax,2
 add ax,ax
 add ax,ax
abc ends 

end
```



**5.程序返回**

我们的程序最先以汇编指令的形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中，那么，它怎样得到运行呢？

下面我们在 DOS（一个单任务操作系统）的基础上，简单地讨论一下这个问题。

一个程序 P2 在可执行文件中，则必须有一个正在运行地程序 P1，将 P2 从可执行文件中加载入内存后，将 CPU 的控制权交给 P2，P2 才能得以运行。P2 开始运行后，P1 暂停运行。

而当 P2 运行完毕后，应该将 CPU 的控制权交还给使它得以运行的程序 P1，此后，P1 继续运行。

现在，我们知道，一个程序结束后，将 CPU 的控制权交还给使它得以运行的程序，我们称这个过程为：**程序返回**。那么，如何返回呢？应该在程序的末尾添加返回的程序段。

我们回过头来，看一下程序 4.1 中的两条指令：

```assembly
mov ax,4c00H
int 21H
```



这两条指令所实现的功能就是程序返回。

在目前阶段，我们不必去理解 int 21H 指令的含义，和为什么要在这条指令的前面加上指令 mov ax,4c00H。我们只要知道，在程序的末尾使用这两条指令就可以实现程序返回。

到目前为止，我们好像已经遇到了几个和结束相关的内容：段结束、程序结束、程序返回。表 4.1 展示了它们的区别。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE24.png"/> </div><br>
**6.语法错误和逻辑错误**

可见，程序 4.2 在运行时会引发一些问题，因为程序没有返回。当然，这个错误在编译的时候是不能表现出来的，也就是说，程序 4.2 对于编译器来说是正确的程序。

一般说来，程序在编译时被编译器发现的错误是语法错误。

在源程序编译后，在运行时发生的错误是逻辑错误。语法错误容易发现，也容易解决。而逻辑错误通常不容易被发现。





#### 4.3	编辑源程序

可以用任意的文本编辑器来编辑源程序，只要最终将其存储为纯文本文件即可。在我们的课程中，使用 DOS 下的 Edit。以程序 4.1 为例，说明工作过程。

（1）进入 dosbox，运行 Edit。

（2）在 Edit 中编辑程序，如下所示：

```assembly
assume cs:codesg
codesg segment
	mov ax,0124h
	mov bx,0456h
	add ax,bx
	add ax,ax
	
	mov ax,4c00h
	int 21h

codesg ends
ends
```



（3）将程序保存为文件 c:\1.asm 后，退出 Edit，结束对源程序的编辑。



#### 4.4	编	译

在前一节中，完成对源程序的编辑后，得到一个源程序文件。可以对其进行编译，生成包含机器代码的目标文件。

在编译一个源程序之前首先要找到一个相应的编译器。在我们的课程中，采用微软的 masm5.0 汇编编译器，文件名为 masm.exe。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE25.jpg"/> </div><br>
图 4.5 中，运行 masm 后，首先显示出一些版本信息，然后提示输入将要被扁你的源程序文件的名称。注意，“[.ASM]” 提示我们，默认的文件扩展名是 asm，比如，要编译的源程序文件名是 “p1.asm”，只要在这里输入 “p1” 即可。可如果源程序文件不是以 asm 为扩展名的话，就要输入它的全名。比如源程序文件名为 “p1.txt”，就要输入全名。

在输入源程序文件名的时候一定要指明它所在的路径。如果文件就在当前路径下，只输入文件名就可以，可如果文件在其他的目录中，则要输入路径，比如，要编译的文件 p1.txt 在 “c:\” 下，则要输入 “c:\p1.txt”。

这里，我们要编译的文件是 C 盘根目录下的 1.asm，所以此处输入 “c:\1.asm”。



（2）输入要编译的源程序文件名后，按 Enter 键，屏幕显示如图 4.6 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE26.jpg"/> </div><br>
图 4.6 中，在输入源程序文件名后，程序继续提示我们输入要编译出的目标文件的名称，目标文件是我们对一个源程序继续编译要得到的最终结果。因为我们已经输入了源程序文件名为 1.asm，编译程序已经默认要输出的目标文件名为 1.obj，所以可以不必再另行指定文件名。直接按 Enter 键，编译程序将在当前的目录下，生成 1.obj 文件。

这里，也可以指定生成的目标文件所在的目录，比如，想让编译程序在 “c:\windows\desktop” 下生成目标文件 1.obj，则可输入 “c:\windows\desktop\1”。

我们直接按 Enter 键，使用编译程序设定的目标文件名。



（3）确定了目标文件的名称后，屏幕显示如图 4.7 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE27.jpg"/> </div><br>
图 4.7 中，编译程序提示输入列表文件的名称，这个文件是编译器将源程序编译为目标文件的过程中产生的中间结果，可以让编译器不生成这个文件，直接按 Enter 键即可。



（4）忽略了列表文件的生成后，屏幕显示如图 4.8 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE28.jpg"/> </div><br>
图 4.8 中，编译程序提示输入交叉引用文件的名称，这个文件同列表文件一样，是编译器将源程序编译为目标文件过程中产生的中间结果。可以让编译器不生产这个文件，直接按 Enter 键即可。



（5）忽略了交叉引用文件的生成后，屏幕显示如图 4.9 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE29.jpg"/> </div><br>
图 4.9 中，对源程序的编译结束，编译器输出的最后两行告诉我们这个源程序没有警告错误和必须要改正的错误。

上面我们通过对 C 盘根目录下的 1.asm 进行编译的过程，展示了使用汇编编译器对源程序进行编译的方法。按照上面的过程就行了编译之后，在编译器 masm.exe 运行的目录 c:\masm 下，将出现一个新的文件：1.obj，这是对源程序 1.asm 进行编译所得到的结果。当然，如果编译得过程中出现错误，那么将得不到目标文件。一般来说，有两类错误使我们得不到所期望的目标文件：

（1）程序中有 “Severe Errors”；

（2）找不到所给出的源程序文件。

注意，在编译的过程中，我们提供了一个输入，即源程序文件。最多可以得到 3 个输出：目标文件（.obj）、列表文件（.lst）、交叉引用文件（.crf），这 3 个输出文件中，目标文件是我们最终要得到的结果，而另外两个只是中间结果，可以让编译器忽略对它们的生成。在汇编课程中，我们不讨论这两类文件。



#### 4.5	连	接

在对源程序进行编译得到目标文件后，我们需要对目标文件进行连接，从而得到可执行文件。持续上一节的过程，我们已经对 c:\1.asm 进行编译得到 c:\1.obj，现在再将 c:\1.obj 连接为 c:\1.exe。

我们使用微软的 Overlay linker3.60 连接器，文件名为 link.exe.

生成执行文件的过程与上面类似。

（3）确定了可执行文件的名称后，屏幕显示如图 4.12 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE30.jpg"/> </div><br>
图 4.12 中，连接持续提示输入映像文件的名称，这个文件是连接程序将目标文件连接为可执行文件过程中产生的中间结果，可以让连接程序不生产这个文件，直接按 Enter 键即可。



（4）忽略了映像文件的生成后，屏幕显示如图 4.13 所示。

图 4.13 中，连接程序提示输入库文件的名称。库文件里面包含了一些可以调用的子程序，如果程序中调用了某一个库文件中的子程序，就需要在连接的时候，将这个库文件和目标文件连接到一起，生成可执行文件。但是，这个程序中没有调用任何子程序，所以，这里忽略库文件名的输入，直接按 Enter 键即可。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE31.jpg"/> </div><br>
（5）忽略了库文件的连接后，屏幕显示如图 4.14 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE32.jpg"/> </div><br>
图 4.14 中，对目标文件的连接结束，连接程序输出的最后一行告诉我们，这个程序中有一个警告错误：“没有栈段”，这里我们不理会这个错误。

上面我们通过对当前路径下的 1.obj 进行连接的过程，展示了使用链接起对目标文件进行连接的方法。按照上面的过程进行了连接之后，在连接器 link.exe 进行的目录下，将出现一个新的文件：1.exe，这是对目标文件 1.obj 进行连接所得到的结果。当然，如果连接过程中出现错误，那么将得不到可执行文件。

连接的作用是什么呢？

对于连接，我们也不想过多地讨论。实际上，在汇编课程中，我们将会接触到许多知识、概念，对于这些，我们并不是都有深入讨论的必要。

这里再次强调一下，我们学习汇编的主要目的，就是通过用汇编语言进行编程而深入地理解计算机底层的基本工作机理，达到可以随心所欲地控制计算机地目的。基于这种考虑，我们的编程活动，大都是直接对硬件进行的。我们希望直接对硬件编程，却并不希望用机器码编程。我们用汇编语言编程，就要用到编辑器（Edit）、编译器（masm）、连接器（link）、调式工具（Debug）等所有工具，而这些工具都是在操作系统之上运行的程序，所以我们的学习过程必须在操作系统的环境中进行。我们在一个操作系统环境中，使用了许多工具，这势必要牵扯到操作系统、编译原理等方面的知识和原理。我们只是利用这些环境、工具来方便我们的学习，而不希望这些东西分散了我们的注意力。所以，对于涉及而又不在我们学习的主要内容之中的东西，我们只做简单的解释。

好了，我们简单地讲连接的作用，连接的作用有以下几个。

（1）源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件；

（2）程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起去，生成一个可执行文件；

（3）一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。

注意，对于连接的过程，可执行文件是我们要得到的最终结果。



#### 4.6	以简化的方式进行编译和连接

在前面的内容里，介绍了如何使用 masm 和 link 进行编译和连接。可以看出，我们编译、连接的最终目的是用源程序文件生成可执行文件。在这个过程中所产生的中间文件都可以忽略。我们可以用一种较为简捷的方式进行编译、连接。

直接使用命令 “masm c:\1;”，“link 1;”，在 masm 后面加上被编译的源程序文件的路径、文件名，在命令行的结尾再加上分号，按 Enter 键后，编译器就对 c:\1.asm 进行编译，在当前路径下生成目标文件 1.obj，并在编译的过程中自动忽略中间文件的生成。link 同理。



#### 4.7	1.exe 的执行

现在，终于将我们的第一个汇编程序加工成了一个可在操作系统下执行的程序文件，在命令行输入 “1”，点击 Enter 键执行 1.exe，图 4.17 展示了 1.exe 的执行情况。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE33.jpg"/> </div><br>
程序运行后，没有任何结果，因为我们没有向显示器输出任何信息。程序执行完成后，返回，屏幕上再次出现操作系统的提示符。



#### 4.8	谁将可执行文件中的程序装载进入内存并使它运行？

我们在前面讲过，在 DOS 中，可执行文件中的程序 P1 若要运行，必须有一个正在运行的程序 P2，将 P1 从可执行文件中加载入内存，将 CPU 的控制权交给它，P1 才能得以运行；当 P1 运行完毕后，应该将 CPU 的控制权交换给使它得以运行的程序 P2。

按照上面的原理，再来看一下 4.7 节中的 1.exe 的执行过程（思考相关的问题）。



#### 操作系统的外壳

操作系统是由多个功能模块组成的庞大、复杂的软件系统。任何通用的操作系统，都要提供要给称为 shell（外壳）的程序，用户（操作人员）使用这个程序来操作计算机系统进行工作。

DOS 中有一个程序 command.com，这个程序在 DOS 中称为命令解释器，也就是 DOS 系统的 shell。

DOS 启动时，先完成其他重要的初始化工作，然后运行 command.com，command.com 运行后，执行完其他的相关任务后，在屏幕上显示出由当前盘符和当前路径组成的提示符，比如：“c:\” 或 "c:\windows" 等，然后等待用户的输入。

用户可以输入所要执行的命令，比如，cd、dir、type 等，这些命令由 command 执行，command 执行完这些命令后，再次显示出由当前盘符和当前路径组成的提示符，等待用户的输入。

如果用户要执行一个程序，则输入该程序的可执行文件的名称，command 首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载入内存，设置 CS:IP 指向程序的入口。此后，command 暂停运行，CPU 运行程序。程序运行结束后，返回到 command 中，command 再次显示由当前盘符和当前路径组成的提示符，等待用户的输入。

在 DOS 中，command 处理各种输入：命令或要执行的程序的文件名。我们就是通过 command 来进行工作的。



#### 问题 4.1

此时，有一个正在运行的程序将 1.exe 中的程序加载入内存，这个正在运行的程序是什么？它将程序加载入内存后，如何使程序得以运行？



#### 问题 4.2

程序运行结束后，返回到哪里？



（1）在 DOS 中直接执行 1.exe 时，是正在运行的 command，将 1.exe 中的程序加载入内存；

（2）command 设置 CPU 的 CS:IP 指向程序的第一条指令（即程序的入口），从而使程序得以运行；

（3）程序运行结束后，返回到 command 中，CPU 继续运行 command。





#### 4.9	程序执行过程的跟踪

可以用 Debug 来跟踪一个程序的运行过程，这通常是必须要做的工作。我们写的程序在逻辑上不一定总是正确，对于简单的错误，仔细检查一下源程序就可以发现：而对于隐藏较深的错误，就必须对程序的执行过程进行跟踪分析才容易发现。

下面以在前面的内容中生成的可执行文件 1.exe 为例，讲解如何用 Debug 对程序的执行过程进行跟踪。

现在我们知道，在 DOS 中运行一个程序的时候，是由 command 将持续从可执行文件中加载入内存，并使其得以执行。但是，这样我们不能逐条指令地看到程序的执行过程，因为 command 的程序加载，设置 CS:IP 指向程序的入口的操作是连续完成的，而当 CS:IP 一指向程序的入口，command 就放弃了 CPU 的控制权，CPU 立即开始运行程序，直至程序结束。

为了观察程序的运行过程，可以使用 Debug。Debug 可以将程序加载入内存，设置 CS:IP 指向程序的入口，但 Debug 并不放弃对 CPU 的控制，这样，我们就可以使用 Debug 的相关命令来单步执行程序，查看每一条指令的执行结果。

具体方法如图 4.18 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE34.jpg"/> </div><br>
在提示符后输入 “debug 1.exe”，按 Enter 键，Debug 将程序从 1.exe 中加载入内存，进行相关的初始化后设置 CS:IP 指向程序的入口。

接下来可以用 R 命令看一下各个寄存器的设置情况，如图 4.19 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE35.jpg"/> </div><br>
可以看到，Debug 将程序从可执行文件加载入内存后，cx（count）：计数寄存器中存放的是程序的长度。1.exe 中程序的机器码共有 15 个字节。则 1.exe 加载后，cx 中的内容为 000FH。

现在程序已从 1.exe 中装入内存，接下来查看一下它的内容，可是我们查看哪里的内容呢？程序被装入内存的什么地方？我们如何得知？

这里，需要讲解一下在 DOS 系统中 .EXE 文件中的程序的加载过程。图 4.20 针对我们的问题，简要地展示了这个过程。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE36.jpg"/> </div><br>
program segment prefix，简称PSP（程序段前缀）。

注意，有一步称为重定位的工作在图 4.20 中没有讲解，因为这个问题和操作系统的关系较大，我们不作讨论。

那么，我们的程序被装入内存的什么地方？我们如何得知？从图 4.20 中我们知道以下的信息。

（1）程序加载后，ds 中存放着程序所在内存区的段地址，这个内存区的偏移地址为 0，则程序所在的内存区的地址为 ds:0;

（2）这个内存区的前 256 个字节中存放的是 PSP，DOS 用来和程序进行通信。从 256 字节处向后的空间存放的是程序。

所以，从 ds 中可以得到 PSP 的段地址 SA，PSP 的偏移地址为 0，则物理地址为 SA×16+0。

因为 PSP 占 256（100H）字节，所以程序的物理地址是：SA+10H:0。

现在，我们看一下图 4.19 中 DS 的值，DS=129E，则 PSP 的地址为 129E:0，程序的地址为 12AE:0（即 129E+10:0）。

图 4.19 中，CS=12AE，IP=0000，CS:IP 指向程序的第一条指令。注意，源程序中的指令是 mov ax,0123H，在 Debug 中记为 mov ax,0123，这是因为 Debug 默认所有数据都用十六进制表示。

可以用 U 指令看一下其他指令，如图 4.21 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE37.jpg"/> </div><br>
可以看到，从 12AE:0000~12AE:000E 都是程序的机器码。

现在，我们可以开始跟踪了，用 T 命令单步执行程序中的每一条指令，并观察每条指令的执行结果，到了 int 21，我们要用 P 命令执行，如图 4.22 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE38.jpg"/> </div><br>
图 4.22 中，int 21 执行后，显示出 “Peogram terminated normally”，返回到 Debug 中。表示程序正常结束。注意，要使用 P 命令执行 int 21。这里不必考虑是为什么，只要记住这一点就可以了。

需要注意的是，在 DOS 中运行程序时，是 command 将程序加载入内存，所以程序运行结束后返回到 command 中，而在这里是 Debug 将程序加载入内存，所以程序运行结束后要返回到 Debug 中。p

使用 Q 命令退出 Debug，将返回到 command 中，因为 Debug 是由 command 加载运行的。在 DOS 中用 “debug 1.exe” 运行 Debug 对 1.exe 进行跟踪时，程序加载的顺序是：command 加载 Debug，Debug 加载 1.exe。返回的顺序是：从 1.exe 中的程序返回到 Debug，从 Debug 返回到 command。



#### 实验 3	编程、编译、连接、跟踪

（1）将下面的程序保存为 t1.asm 文件，将其生成可执行文件 t1.exe。

```assembly
assume cs:codesg

codesg segment

	mov ax,2000H
	mov ss,ax
	mov sp,10
	pop ax
	pop bx
	push ax
	push bx
	pop ax
	pop bx
	
	mov ax,4c00H
	int 21H
	
codesg ends

end
```



（2）用 Debug 跟踪 t1.exe 的执行过程，写出每一步执行后，相关寄存器中的内容和栈顶的内容。

ax=ffff	bx=0000	ss=0769	sp=0000

ds=075A	cs=076A	ip=0000



ax=2000	bx=0000	ss=0769	sp=0000

ds=075A	cs=076A	ip=0003



ax=2000	bx=0000	ss=0769	sp=0000

ds=075A	cs=076A	ip=0003



ax=2000	bx=0000	ss=2000	sp=000A

ds=075A	cs=076A	ip=0008



2000:a  0000	2000:c 0000

ax=0000	bx=0000



ax=2000	bx=0000	ss=2000	sp=000A

ds=075A	cs=076A	ip=0009



ax=0000	bx=0000	ss=2000	sp=000C

ds=075A	cs=076A	ip=000A



ax=0000	bx=0000	ss=2000	sp=000E

ds=075A	cs=076A	ip=000B



ax=0000	bx=0000	ss=2000	sp=000C

ds=075A	cs=076A	ip=000C



ax=0000	bx=0000	ss=2000	sp=000A

ds=075A	cs=076A	ip=000D



ax=0000	bx=0000	ss=2000	sp=000C

ds=075A	cs=076A	ip=000E



ax=4c00	bx=0000	ss=2000	sp=000E

ds=075A	cs=076A	ip=0011



（3）PSP 的头两个字节是 CD 20，用 Debug 加载 t1.exe，查看 PSP 的内容。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE39.jpg"/> </div><br>
### 第 5 章	[BX] 和 loop 指令

**1.[bx] 和内存单元的描述**

[bx] 是什么呢？和 [0] 有些类似，[0] 表示内存单元，它的偏移地址是 0。比如在下面的指令中，（在 Debug 中使用）：

mov ax,[0]

将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址为 0，段地址在 ds 中。

mov al,[0]

将一个内存单元的内容送入 al，这个内存单元的长度为 1 字节（字节单元），存放一个字节，偏移地址为 0，段地址在 ds 中。

要完整地描述一个内存单元，需要两种信息：（1）内存单元的地址；（2）内存单元的长度（类型）。

用 [0] 表示一个内存单元时，0 表示内存单元的偏移地址，段地址默认在 ds 中，单元的长度（类型）可以由具体指令中的其他操作对象（比如说寄存器）指出。

[bx] 同样也表示一个内存单元，它的偏移地址在 bx 中，比如下面的指令：

mov ax,[bx]

将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址在 bx 中，段地址在 ds 中。

mov al,[bx]

将一个内存单元的内容送入 al，这个内存单元的长度为 1 字节，存放一个字节，偏移地址在 bx 中，段地址在 ds 中。



**2.loop**

英文单词 "loop" 有循环的含义，显然这个指令和循环有关。

我们在这一章，讲解 [bx] 和 loop 指令的应用、意义和相关的内容。



**3.我们定义的描述性的符号：“()”**

为了描述上的简洁，在以后的课程中，我们将使用一个描述性的符号 “()” 来表示一个寄存器或一个内存单元中的内容。比如：

(ax) 表示 ax 中的内容、(al) 表示 al 中的内容；

(20000H) 表示内存 20000H 单元的内容（括号中的内存单元的地址为物理地址）；

((ds)*16+(bx)) 表示：

ds 中的内容为 ADR1，bx 中的内容为 ADR2，内存 ADR1×16+ADR2 单元的内容。

也可以理解为：ds 中的 ADR1 作为段地址，bx 中的 ADR2 作为偏移地址，内存 ADR1:ADR2 单元的内容。

注意，“()” 中的元素可以有 3 种类型：（1）寄存器名；（2）段寄存器名；（3）内存单元的物理地址（一个 20 位数据）。比如：

(ax)、(ds)、(al)、(cx)、(20000H)、(ds)*16、(bx) 等是正确的用法：

(2000:0)、((ds):1000H)  等是不正确的用法。

我们看一下 (x) 的应用，比如，

（1）ax 中的内容为 0010H，可以这样来描述：(ax)=0010H;

（2）2000:1000 处的内容为 0010H，可以这样来描述：(21000H)=0010H;

（3）对于 mov ax,[2] 的功能，可以这样来描述：(ax)=((ds)*16+2);

（4）对于 mov [2],ax 的功能，可以这样来描述：((ds)*16+2)=(ax);

（5）对于 add ax,2 的功能，可以这样来描述：(ax)=(ax)+2;

（6）对于 add ax,bx 的功能，可以这样来描述：(ax)=(ax)+(bx);

（7）对于 push ax 的功能，可以这样来描述：

​			(sp)=(sp)-2

​			((ss)*16+(sp))=(ax)

（8）对于 pop ax 的功能，可以这样来描述：

​			(ax)=((ss)*16+(sp))

​			(sp)=(sp)+2



"(x)" 所表示的数据有两种类型：（1）字节;（2）字。是哪种类型由寄存器名或具体的运算决定，比如：

 (al)、(bl)、(cl) 等得到的数据为字节型；(ds)、(ax)、(bx) 等得到的数据为字型。

(al)=(20000H)，则 (20000H) 得到的数据为字节型；(ax)=(20000H)，则 (20000H) 得到的数据为字型。



**4.约定符号 idata 表示常量**

我们在 Debug 中写过类似的指令：mov ax,[0]，表示将 ds:0 处的数据送入 ax 中。指令中，在 “[...]” 里用一个常量 0 表示内存单元的偏移地址。以后，我们用 idata 表示常量。比如：

mov ax,[idata] 就代表 mov ax,[1] 、mov ax,[2]、mov ax,[3] 等。

mov bx,idata 就代表 mov bx,1、mov bx,2、mov bx,3 等。

mov ds,idata 就代表 mov ds,1、mov ds,2 等，它们都是非法指令。





#### 5.1	[BX]

看一看下面指令的功能。

mov ax,[bx]

功能：bx 中存放的数据作为一个偏移地址 EA，段地址 SA 默认在 ds 中，将 SA:EA 处的数据送入 ax 中。即：(ax)=((ds)*16+(bx))。

mov [bx],ax

功能：bx 中存放的数据作为一个偏移地址 EA，段地址 SA 默认在 ds 中，将 ax 中的数据送入内存 SA:EA 处。即：((ds)*16+(bx))=(ax)



#### 5.2	Loop 指令

loop 指令的格式是：loop 标号，CPU 执行 loop 指令的时候，要进行两步操作，（1）(cx)=(cx)-1;

（2）判断 cx 中的值，不为零则转至标号处执行程序，如果为零则向下执行。

cx（count）：计数寄存器中存放的是程序的长度。

从上面的描述中，可以看到，cx 中的值影响着 loop 指令的执行结果。通常（注意，我们说的是通常）我们用 loop 指令来实现循环功能，cx 中存放循环次数。

这里讲解 loop 指令的功能，关于 loop 指令如何实现转至标号处的细节，将在后面的课程中讲解。下面我们通过一个程序来看一下 loop 指令的具体应用。

任务 1：编程计算 2^2，结果存在 ax 中。

分析：设 (ax)=2，可计算 (ax)=(ax)*2，最后  (ax) 中为 2^2 的值。N *2 可用 N+N 实现，程序如下。

```assembly
assume cs:code
code segment
 mov ax,2
 add ax,ax
 
 mov ax,4c00h
 int 21h
code ends
end
```



按照我们的算法，计算 2^12 需要 11 条重复的指令 add ax,ax。我们显然不希望这样来写程序，这里，可用 loop 来简化我们的程序。



#### 程序 5.1

```assembly
assume cs:code
code segmetn
	mov ax,2
	mov cx,11
s:	add ax,ax
	loop s
	mov ax,4c00h
	int 21h
code ends
end
```



下面分析一下程序 5.1

（1）标号

在汇编语言中，标号代表一个地址，程序 5.1 中有一个标号 s。它实际上标识了一个地址，这个地址处有一条指令：add ax,ax。

（2）loop s

CPU 执行 loop s 的时候，要进行两步操作：

1. (cx)=(cx)-1;

2. 判断 cx 中的值，不为 0 则转至标号 s 所标识的地址处执行（这里的指令是 add ax,ax），如果为零则执行下一条指令（下一条指令是 mov ax,4c00h）。

3. 以下 3 条指令

   ```assembly
   	mov cx,11
   s:	add ax,ax
   	loop s
   ```

   

执行 loop s 时，首先要将 (cx) 减 1，然后若 (cx) 不为 0，则向前转至 s 处执行 add ax,ax。所以，可以利用 cx 来控制 add ax,ax 的执行次数。

从上面的过程中，我们可以总结出用 cs 和 loop 指令相配合实现循环功能的 3 个要点。

（1）在 cx 中存放循环次数；

（2）loop 指令中的标号所标识地址要在前面；

（3）要循环执行的程序段，要写在标号和 loop 指令的中间。

用 cx 和 loop 指令相配合实现循环功能的程序框架如下。

​	mov cx,循环次数

s:

​	循环执行的程序段

​	loop s





#### 5.3	在 Debug 中跟踪用 loop 指令实现的循环程序

考虑这样一个问题，计算 ffff:0006 单元中的数乘以 3，结果存储在 dx 中。

我们分析一下。

（1）运算后的结果是否会超出 dx 所能存储的范围？

ffff:0006 单元中的数是一个字节型的数据，范围在 0~255 之间，则用它和 3 相乘结果不会大于 65535，可以在 dx 中存放下。

（2）用循环累加来实现乘法，用哪个寄存器进行累加？

将 ffff:0006 单元中的数赋值给 ax，用 ds 进行累加。先设 (dx)=0，然后做 3 次 (dx)=(dx)+(ax)。

（3）ffff:6 单元是一个字节单元，ax 是一个 16 位寄存器，数据的长度不一样，如何赋值？

注意，我们说的是 “赋值”，就是说，让 ax 中的数据的值（数据的大小）和 ffff:0006 单元中的数据的值（数据的大小）相等。8 位数据 01H 和 16 位数据 0001H 的数据长度大小不一样，但它们的值是相等的。

那么我们如何赋值？设 ffff:0006 单元中的数据是 XXH，若要 ax 中的值和 ffff:0006 单元中的相等，ax 中的数据应为 00XXH。所以，若实现 ffff:0006 单元向 ax 赋值，应该令 (ah)=0，(al)=(ffff6H)。

想清楚以上的 3 个问题之后，编写程序如下。



#### 程序 5.3

```assembly
assume cs:code
code segment
	mov ax,0ffffh
	mov ds,ax
	mov bx,6		;以上，设置 ds:bx 指向 ffff:6
	
	mov al,[bx]
	mov ah,0		;以上，设置 (al)=((ds*16)+(bx)), (ah)=0
	
	mov dx,0		;累加寄存器清 0
	
	mov cs,3		;循环 3 次
  s:add dx,ax
    loop s			;以上累加计算 (ax)*3
    
    mov ax,4c00h
    int 21h			;程序返回
    
code ends
end
```



注意程序中的第一条指令 mov ax,0ffffh。我们知道，大于 9FFFH 的十六进制数据 A000H、A0001H...FFFEH、FFFFH 等，在书写的时候都是以字母开头的。而在**汇编源程序中，数据不能以字母开头**，所以要再前面加 0。比如，9138h 在汇编源程序中可以直接写为 “9138h”，而 A000h 在汇编源程序中要写为 "0A000h"。



使用 g 命令直接给 ip 赋值，程序会直接执行到指定位置处，格式形如 “g 0016”。

使用 p 命令来跳过循环，遇到 loop 指令时，使用 p 命令来执行，Debug 就会自动重复执行循环中的指令，直到 (cx)=0 为止。



#### 5.4	Debug 和汇编编译器 masm 对指令的不同处理

本节知识点为下面课程的顺利进行提供一点预备知识。

我们在 Debug 中写过类似的指令：

mov ax,[0]

表示将 ds:0 处的数据送入 ax 中。

但是在汇编源程序中，指令 "mov ax,[0]" 被编译器当作指令 “mov ax,0” 处理。

下面通过具体的例子来看一下 Debug 和汇编编译器 masm 对形如 “mov ax,[0]” 这类指令的不同处理。

任务：将内存 2000:0、2000:1、2000:2、2000:3 单元中的数据送入 al,bl,cl,dl 中。

（1）在 Debug 中编程实现：

```assembly
mov ax,2000
mov ds,ax
mov al,[0]
mov bl,[1]
mov cl,[2]
mov dl,[3]
```



（2）汇编源程序实现：

```assembly
assume cs:code
code segment

    mov ax,2000h
    mov ds,ax
    mov al,[0]
    mov bl,[1]
    mov cl,[2]
    mov dl,[3]

code ends
end
```



我们看一下两种实现的实际实施情况：

（1）Debug 中的情况如图 5.16 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE40.jpg"/> </div><br>
（2）将汇编源程序存储为 compare.asm，用 masm、link 生成 compare.exe，用 Debug 加载 compare.exe，如图 5.17 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE41.jpg"/> </div><br>
从图 5.16，图 5.17 中我们可以明显地看出，Debug 和编译器 masm 对形如 “mov ax,[0]” 这类指令在解释上的不同。我们在 Debug 中和源程序中写入同样形式的指令：“mov al,[0]”、“mov bl,[1]”，但 Debug 和编译器对这些指令中的 “[idata]” 却有不同的解释。Debug 将它解释为 “[idata]” 是一个内存单元，“idata” 是内存单元的偏移地址；而编译器将 “[idata]” 解释为 “idata”。

那么我们如何在源程序中实现将内存  2000:0、2000:1、2000:2、2000:3 单元中的数据送入 al,bl,cl,dl 中呢？

目前的方法是，可将偏移地址送入 bx 寄存器中，用 [bx] 的方式来访问内存单元。比如我们可以这样访问 2000:0 单元：

```assembly
mov ax,2000h
mov ds,ax		;段地址 2000h 送入 ds
mov bx,0		;偏移地址 0 送入 bx
mov al,[bx]		;ds:bx 单元中的数据送入 al
```



这样做是可以，可是比较麻烦，我们要用 bx 来间接地给出内存单元的偏移地址。我们还是希望能够像在 Debug 中那样，在 "[ ]" 中直接给出内存单元的偏移地址。这样做，在汇编源程序中也是可以的，只不过，要在 "[ ]" 的前面显式地给出段地址所在地段寄存器。比如我们可以这样访问 2000:0 单元：

```assembly
mov ax,2000h
mov ds,ax
mov al,ds:[0]
```

 

比较一下汇编源程序中以下指令的含义。

"mov al,[0]"，含义：(al)=0，将常量 0 送入 al 中（与 mov al,0 含义相同）；

"mov al,ds:[0]"，含义：(al)=((ds)*16+0)，将内存单元中的数据送入 al 中；

"mov al,[bx]"，含义：(al)=((ds)*16+(bx))，将内存单元中的数据送入 al 中；

"mov al,ds:[bx]"，含义：与 “mov al,[bx]” 相同；

从上面的比较中可以看出：

（1）在汇编源程序中，如果用指令访问一个内存单元，则在指令中必须用 “[...]” 来表示内存单元，如果在 “[]” 里用一个常量 idata 直接给出内存单元的偏移地址，就要在 “[]” 的前面显式地给出段地址所在的段寄存器，比如

mov al,ds:[0]

如果没有在 ”[]“ 的前面显式地给出段地址所在的段寄存器，比如

mov al,[0]

那么，编译器 masm 将把指令中的 "[idata]" 解释为 ”idata“。



（2）如果在 ”[]“ 里用寄存器，比如 bx，间接给出内存单元的偏移地址，则段地址默认在 ds 中，当然，也可以显式地给出段地址所在的段寄存器。





#### 5.5	loop 和 [bx] 的联合应用

考虑这样一个问题，计算 ffff:0~ffff:b 单元中的数据的和，结果存储在 dx 中。

我们还是先分析一下。

（1）运算后的结果是否会超出 dx 所能存储的范围？

ffff:0~ffff:b 内存单元中的数据是字节型数据，范围在 0~255 之间，12 个这样的数据相加，结果不会大于 65535，可以在 dx 中存放下。

（2）我们能否将 ffff:0~ffff:b 中的数据直接累加到 dx 中？

当然不行，因为 ffff:0~ffff:b 中的数据是 8 位的，不能直接加到 16 位寄存器 dx 中。

（3）我们能否将 ffff:0~ffff:b 中的数据累加到 dl 中，并设置 (dh)=0，从而实现累加到 dx 中？

这也不行，因为 dl 是 8 位寄存器，能容纳的数据的范围在 0~255 之间，ffff:0~ffff:b 中的数据也都是 8 位，如果仅向 dl 中累加 12 个 8 位数据，很有可能造成进位丢失。

（4）我们到底怎样将 ffff:0~ffff:b 中的 8 位数据，累加到 16 位寄存器 dx 中？

从上面的分析中，可以看到，这里面有两个问题：类型的匹配和结果的不超界。具体的说，就是在做加法的时候，我们有两种方法：

1. (dx)=(dx)+内存中的 8 位数据；

2. (dl)=(dl)+内存中 8 位数据。



第一种方法中问题是两个运算对象的类型不匹配，第二种分分钟的问题是结果有可能超界。

怎样解决这两个看似矛盾的问题？目前的方法（在后面的课程中我们还有别的方法）就是得用一个 16 位寄存器来做中介。将内存单元中的 8 位数据赋值到一个 16 位寄存器 ax 中，再将 ax 中的数据加到 dx 上，从而使两个运算对象的类型匹配并且结果不会超界。





#### 5.6	段	前	缀

指令 "mov ax,[bx]" 中，内存单元的偏移地址由 bx 给出，而段地址默认在 ds 中。我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器。比如：

（1）mov ax,ds:[bx]

将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址在 bx 中，段地址在 ds 中。

（2）mov ax,cs:[bx]

将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址在 bx 中，段地址在 cs 中。

（3）mov ax,ss:[bx]

将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址在 bx 中，段地址在 ss 中。

（4）mov ax,es:[bx]

将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址在 bx 中，段地址在 es 中。

（5）mov ax,ss:[0]

将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址为 0，段地址在 ss 中。

（6）mov ax,cs:[0]

将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址为 0，段地址在 cs 中。

这些出现在访问内存单元的指令中，用于显式地指明内存单元地段地址的 ”ds:“ "cs:" "ss:" "es:"，在汇编语言中称为**段前缀**。



#### 5.7	一段安全的空间

在 8060 模式中，随意向一段内存空间写入内容是很危险的，因为这段空间中可能存放着重要的系统数据库或代码。比如下面的指令：

```assembly
mov ax,1000h
mov ds,ax
mov al,0
mov ds:[0],al
```



我们以前在 Debug 中，为了讲解上的方便，写过类似的指令。但这种做法是不合理的，因为之前我们并没有论证过 1000:0 中是否存放着重要的系统数据或代码。如果 1000:0 存放着重要的系统数据或代码，”mov ds:[0],al‘ 将其改写，将引发错误。



#### 程序 5.7

```assembly
assume cs:code
code segment

	mov ax,0
	mov ds,ax
	mov ds:[26h],ax
	
	mov ax,4c00h
	int 21h
	
code ends
end
```



在虚拟 DOS 方式中，代码会报错。如果在实模式（即纯 DOS 方式）下执行程序，将会引起死机。产生这种结果的原因是 0:0026 处存放着重要的系统数据，而 ”mov [0026],ax“ 将其改写。

可见，在不能确定一段内存空间中是否存放着重要的数据或代码的时候，不能随意向其中写入内容。

不要忘记，我们是在操作系统的环境中工作，操作系统管理所有的资源，也包括内存。如果我们需要向内存空间写入数据的话，要使用操作系统给我们分配的空间，而不应直接用地址任意指定内存单元，向里面写入。下一章我们会对 ”使用操作系统给我们分配的空间“ 有所认识。

但是，同样不能忘记，我们正在学习的是汇编语言，要通过它来获得底层的编程体验，理解计算机底层的基本工作机理。所以我们尽量直接对硬件编程，而不去理会操作系统。

我们似乎面临一种选择，是在操作系统中安全、规矩地编程，还是自由、直接地用汇编语言去操作真实的硬件，了解哪些早已被层层系统软件遮盖的真相？在大部分的情况下，我们选择后者，除非我们就是在学习操作系统本身的内容。

注意，我们在纯 DOS 方式（实模式）下，可以不理会 DOS，直接用汇编语言去操作真实的硬件，因为运行在 CPU 实模式下的 DOS，没有能力对硬件系统进行全面、严格地管理。但在 Windows 2000、Unix 这些运行于 CPU 保护模式下的操作系统中，不理会操作系统，用汇编语言去操作真实的硬件，是根本不可能的。硬件已被这些操作系统利用 CPU 保护模式所提供的功能全面而严格地管理了。

在后面的课程中，我们需要直接向内存中写入内容，可我们又不希望发生上面的情况，所以要找到一段安全的空间供我们使用。在一般的 PC 机中，DOS 方式下，DOS 和其他合法的程序一般都不会使用 0:200~0:2ff(00200h ~ 002ffh) 的 256 个字节的空间，所以，我们使用这段空间是安全地。不过为了谨慎起见，在进入 DOS 后，我们可以先用 Debug 查看以下，如果 0:200~0:2ff 单元的内容都是 0 的话，则证明 DOS 和其他合法的程序没有使用这里。

为什么 DOS 和其他合法的程序一般都不会使用 0:200~0:2ff 这段空间？我们将在以后的课程中讨论这个问题。

好了，我们总结一下：

（1）我们需要直接向一段内存中写入内容；

（2）这段内存空间不应存放系统或其他程序的数据或代码，否则写入操作很可能引发错误；

（3）DOS 方式下，一般情况，0:200~0:2ff 空间中没有系统或其他程序的数据或代码；

（4）以后，我们需要直接向一段内存中写入内容时，就使用 0:200~0:2ff 这段空间。



#### 5.8	段前缀的使用

我们考虑一个问题，将内存 ffff:0~ffff:b 单元中的数据复制到 0:200~0:20b 单元中。

分析一下：

（1）0:200~0:20b 单元等同于 0020:0~0020:b 单元，它们描述的是同一段内存空间。

（2）复制的过程应用循环实现，简要描述如下：

​       初始化：

​       x=0

​       循环12次：

​       将 ffff:x 单元中的数据送入 0020:x（需要用一个寄存器中转，因为没有 mov 内存单元,内存单元）

（3）在循环中，源始单元 ffff:x 和目标单元 0020:x 的偏移地址 x 是变量。我们用 bx 来存放。

（4）将 0:200~0:20b 用 0020:0~0020:b 描述，就是为了使目标单元的偏移地址和源始单元的偏移地址从同一数值 0 开始。

 

#### 程序 5.8

```assembly
assume cs:code
code segment

    mov bx,0
    mov cx,12
    
s:  mov ax,0ffffh
    mov ds,ax
    mov dl,[bx]

    mov ax,002h
    mov ds,ax
    mov [bx],dl

    inc bx
    loop s
    
    mov ax,4c00h
    int 21h
    
code ends
end

```



因源始单元 ffff:x 和目标单元 0020:x 相距大于 64KB，在不同的 64KB 段里，程序 5.8 中，每次循环要设置两次 ds。这样做是正确的，但是效率不高。我们可以使用两个段寄存器分别存放源始单元 ffff:x 和目标单元 0020:x 的段地址，这样就可以省略循环中需要重复做 12 次的设置 ds 的程序段。



#### 程序 5.9

```assembly
assume cs:code
code segment

    mov ax,0ffffh
    mov ds,ax
    
    mov ax,0020h
    mov es,ax
    
    mov bx,0
    mov cx,12
    
s:	mov dl,[bx]    
    mov es:[bx],dl
    inc bx
    loop s
    
    mov ax,4c00h
    int 21h
    
code ends
end

```



使用 es 存放目标空间 0020:0~0020:b 的段地址，用 ds 存放源始空间 ffff:0~ffff:b 的段地址。在访问内存单元的指令 “mov es:[bx],al” 中，显式地用段前缀 “es:” 给出单元的段地址，这样就不必在循环中重复设置 ds。



#### 实验 4	[bx] 和 loop 的使用

（1）编程，向内存 0:200~0:23F 依次送入数据 0~63(3FH)。

（2）编程，向内存 0:200~0:23F 依次送入数据 0~63(3FH)，程序中只能使用 9 条指令，9 条指令中包括 ”mov ax,4c00h“ 和 ”int 21h‘。

```assembly
assume cs:code
code segment

    mov ax,0020h
    mov ds,ax
    
    mov bx,0
    
    mov cx,40H		//mov cx,64 也可以
    
s:	mov [bx],bl     
    inc bx
    loop s
    
    mov ax,4c00h
    int 21h
    
code ends
end
```



（3）下面的程序的功能是将 “mov ax,4c00h’ 之前的指令复制到内存 0:200 处，补全程序。上机调试，跟踪运行结果。

```assembly
assume cs:code
code segment

	mov ax,
	mov ds,ax
	mov ax,0020h
	mov es,ax
	mov bx,0
	mov cx,
  s:mov al,[bx]
    mov es:[bx],al
    inc bx
    loop s
    mov ax,4c00h
    int 21h
    
code ends
end
```



程序分析：

（1）使用 debug 调试一个 exe 文件时候，使用 r 命令查看寄存器状态，其中 cx 寄存器的值（初始值）就是该程序代码的大小（按照字节数）。我们可以通过运行 debug 程序来调式生成的 exe 文件，前提是先将程序补全，填写临时的值。

（2）cs 段寄存器中存储的是指向程序代码段的段地址。此实验是将程序的代码（按字节）赋值，故将 cs 寄存器中的指向代码的段地址赋值给 ax，再通过 ax 寄存器赋值给 ds 段寄存器。（为什么不能支持从段寄存器 cs 直接赋值给段寄存器 ds 呢？回忆下，在 8086CPU 中，ds、ss、cs、es 四个段寄存器存放的都是段地址，在 CPU 和我们看来。其他的寄存器一般存放的都是数据。 这 4 个段寄存器支持从其他寄存器中赋值，但不允许立即数直接赋值给段寄存器。）

（3）[bx] 作为偏移地址为 bx 的内存单元，它支持的段地址默认是存储在 ds 段寄存器中的。 本例中 ds：[bx] 指向的是存储代码段的内存单元（源内存段）。由于 ds 被占用了，故被写入的内存单元的段地址就没有存储的段寄存器了，es 寄存器上场了，es 存储了地址为 0020H 的段地址（目标内存段），那么同样使用 [bx] 偏移地址的话，必须明确的指出它的前缀，故 es：[bx] 就指向了内存是 0200H 的内存单元地址段。



**实验步骤如下：**

（1）首先使用debug调试该程序：假如这个可执行程序（经编译、连接无误后的）为test.exe

**debug  test.exe**  



（2）使用r命令显示寄存器状态，显示整个程序代码所占字节数。

-r

AX=0000  BX=0000  CX=001C  DX=0000  SP=0000  BP=0000  SI=0000  DI=0000

DS=0B55  ES=0B55  SS=0B65  CS=0B65  IP=0000   NV UP EI PL NZ NA PO NC

0B65:0000 8CC8          MOV     AX,CS

这里我们发现 CX=001CH。



（3）使用u命令显示汇编指令，求出需要复制的机器码字节数。

-u cs:0000

0B65:0000 8CC8          MOV     AX,CS

0B65:0002 8ED8          MOV     DS,AX

0B65:0004 B82000        MOV     AX,0020

0B65:0007 8EC0          MOV     ES,AX

0B65:0009 BB0000        MOV     BX,0000

0B65:000C B90300        MOV     CX,0003

0B65:000F 8A07          MOV     AL,[BX]

0B65:0011 26            ES:

0B65:0012 8807          MOV     [BX],AL

0B65:0014 43            INC     BX

0B65:0015 E2F8          LOOP    000F

0B65:0017 B8004C        MOV     AX,4C00

0B65:001A CD21          INT     21



我们发现 mov ax,4cooH/int 21H 它们共占用了 5 个字节。所以在本实验中我们需要复制的代码字节数是 001CH-0005H=0017H=23 个字节，故 cx 计数寄存器赋值为 23 或 17H。



（4）完整的汇编代码如下：

```assembly
assume cs:code

code segment

    mov ax,cs       ;将 cs 段地址赋值给 ax
    mov ds,ax       ;用 cs 寄存器中的值初始化 ds 段寄存器，

    mov ax,0020H
    mov es,ax       ;es 指向 0020H 内存段
    
    mov bx,0        ;偏移地址寄存器清零
    mov cx,17H      ;此处是循环次数:程序机器码的字节数，存储在 CX 中

  s:mov al,[bx]     ;将 [bx] 按照字节单元传送给 al
    mov es:[bx],al  ;复制到 es 段内存中
    inc bx
    
    loop s

    mov ax,4c00H
    int 21H

code ends

end
```





**实验结果测试：**

-d 20:0

0020:0000  8C C8 8E D8 B8 20 00 8E-C0 BB 00 00 B9 17 00 8A   ..... ..........

0020:0010  07 26 88 07 43 E2 F8 00-00 00 00 00 00 00 00 00   .&..C...........

……

我们发现偏移地址从 0000H~0017H 存储了程序的执行代码。与程序执行代码存储的内存单元比较，我们发现是一样的。

-d cs:0

0B65:0000  8C C8 8E D8 B8 20 00 8E-C0 BB 00 00 B9 17 00 8A   ..... ..........

0B65:0010  07 26 88 07 43 E2 F8 B8-00 4C CD 21 FF 06 48 91   .&..C....L.!..H.





### 第 6 章	包含多个段的程序

前面的程序中，只有一个代码段。现在有一个问题是，如果程序需要用其他空间来存放数据，使用哪里呢？第 5 章中，我们讲到要使用一段安全的空间。可哪里安全呢？第 5 章中，我们说 0:200~0:2FF 是相对安全的，可这段空间的容量只有 256 个字节，如果我们需要的空间超过 256 个字节该怎么办呢？

在操作系统的环境中，合法地通过操作系统取得的空间都是安全的，因为操作系统不会让一个程序所用的空间和其他程序以及系统自己的空间相冲突。在操作系统运行的情况下，程序可以取得任意容量的空间。

程序取得所需空间的方法有两种，一是在加载程序的时候为程序分配，再就是程序在执行的过程中向系统申请。在我们的课程中，不讨论第二种方法。

加载程序的时候为程序分配空间，我们在前面已经有所体验，比如我们的程序在加载的时候，取得了代码段中的代码的存储空间。

我们若要一个程序在被加载的时候取得所需的空间，则必须要在源程序中做出说明。我们通过在源程序中定义段来进行内存空间的获取。

上面是从内存空间获取的角度上，谈定义段的问题。我们再从程序规划的角度来谈一下定义段的问题。大多数有用的程序，都要处理数据，使用栈空间，当然也都必须有指令，为了程序设计上的清晰和方便，我们一般也都定义不同的段来存放它们。

对于使用多个段的问题，我们先简单说到这里，下面我们将以这样的顺序来深入地讨论多个段的问题：

（1）在一个段中存放数据、代码、栈，我们先来体会一下不使用多个段时的情况；

（2）将数据、代码、栈放入不同的段中。



#### 6.1	在代码段中使用数据

考虑这样一个问题，编程计算以下 8 个数据的和，结果存在 ax 寄存器中：

0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h

在前面的课程中，我们都是累加某些内存单元中的数据，并不关心数据本身。可现在要累加的就是已经给定了数值的数据。我们可以将它们一个一个地加到 ax 寄存器中，但是，我们希望可以用循环的方法来进行累加，所以在累加前，要将这些数据存储在一组地址连续的内存单元中。如何将这些数据存储在一组地址连续的内存单元中呢？我们可以用指令一个一个地将它们送入地址连续的内存单元中，可是这样又有一个问题，到哪里去找这段内存空间呢？

从规范的角度来讲，我们是不能自己随便决定哪段空间可以使用的，应该让系统来为我们分配。我们可以在程序中，定义我们希望处理的数据，这些数据就会被编译、连接程序作为程序的一部分写到可执行文件中。当可执行文件中的程序被加载入内存时，这些数据也同时被加载入内存中。与此同时，我们要处理的数据也就自然而然地获得了内存空间。

具体的做法看下面的程序。



##### 程序 6.1

```assembly
assume cs:code
code segment

    dw 0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h
    mov bx,0
    mov ax,0

    mov cx,8
  s:add ax,cs:[bx]
    add bx,2
    loop s
    
    mov ax,4c00h
    int 21h
    
code ends
end
```



解释一下，程序第一行中的 “dw” 的含义是定义字型数据。dw 即 “define word‘。在这里，使用 dw 定义了 8 个字型数据（数据之间以逗号分隔），它们所占的内存空间的大小为 16 个字节。

程序中的指令就要对这 8 个数据进行累加，可这 8 个数据在哪里呢？由于它们在代码段中程序在运行的时候 CS 中存放代码段的段地址，所以可以从 CS 中得到它们的段地址。它们的偏移地址是多少呢？因为用 dw 定义的数据处于代码段的最开始，所以偏移地址为 0，这 8 个数据就在代码段的偏移 0、2、4、6、8、A、C、E 处。程序运行时，它们的地址就是 cs:0、cs:2、cs:4、cs:6、cs:8、cs:A、cs:C、cs:E。

程序中，用 bx 存放 2 递增的偏移地址，用循环来进行累加。在循环开始前，设置 (bx)=0，cs:bx 指向第一个数据所在的字单元。每次循环中 (bx)=(bx)+2，cs:bx 指向下一个数据所在的字单元。

将程序 6.1 编译、链接为可执行文件 p61.exe，先不要运行，用 Debug 加载查看一下，情况如图 6.1 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE42.jpg"/> </div><br>
图 6.1 中，通过 ”DS=0B2D“，可知道程序从 0B3D:0000 开始存放。用 u 命令从 0B3D:000 查看程序，却看到了一些让人读不懂的指令。

为什么没有看到程序中的指令呢？实际上用 u 命令从 0B3d:0000 查看到的也是程序中的内容，只不过不是源程序中的汇编指令所对应的机器码，而是源程序中，在汇编指令前面，用 dw 定义的数据。实际上，在程序中，有一个代码段，在代码段中，前面的 16 个字节是用 ”dw’ 定义的数据，从第 16 个字节开始菜是汇编指令所对应的机器码。

可以用 d 命令更清楚地查看一下程序中前 16 个字节的内容，如图 6.2 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE44.jpg"/> </div><br>
可以从 0B3D:0010 查看程序中要执行的机器指令，如图 6.3 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE43.jpg"/> </div><br>
从图 6.2 和 6.3 中，我们可以看到程序加载到内存中后，所占内存空间的前 16 个单元存放着源程序中用 “dw” 定义的数据，后面的单元存放源程序中汇编指令所对应的机器指令。

怎样执行程序中的指令呢？用 Debug 加载后，可以将 IP 设置为 10h，从而使 CS:IP 指向程序中的第一条指令。然后再用 t 命令、p 命令，或者是 g 命令执行。

可是这样依赖，我们就必须用 Debug 来执行程序。程序 6.1 编译、连接成可执行文件后，在系统中直接运行可能会出现问题，因为程序的入口处不是我们所希望执行的指令。如何让这个程序在编译、连接后可以在系统中直接运行呢？我们可以在源程序中指明程序的入口所在，具体做法如下。



##### 程序 6.2

```assembly
assume cs:code
code segment

    dw 0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h
    start:  mov bx,0
            mov ax,0

            mov cx,8
        s:  add ax,cs:[bx]
            add bx,2
            loop s

            mov ax,4c00h
            int 21h
    
code ends
end start
```



注意在程序 6.2 中加入的新内容，在程序的第一条指令的前面加上了一个标号 start，而这个标号在伪指令 end 的后面出现。这里，我们要再次探讨 end 的作用。end 除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。在程序 6.2 中我们用 end 指令指明了程序的入口在标号 start 处，也就是说，“mov bx,0” 是程序的第一条指令。

在前面的课程中（参见 4.8 节），我们已经知道在单任务系统中，可执行文件中的程序执行过程如下。

（1）由其他的程序（Debug、command 或其他程序）将可执行文件中的程序加载入内存；

（2）设置 CS:IP 指向程序的第一条要执行的指令（即程序的入口），从而使程序得以运行；

（3）程序运行结束后，返回到加载者。

现在的问题是，根据什么设置 CPU 的 CS:IP 指向程序的第一条要执行的指令？也就是说，如何知道哪一条指令是程序的第一条要执行的指令。这一点，是由可执行文件中的描述信息指明的。我们知道可执行文件由描述信息和程序组成，程序来自于远程中的汇编指令和定义的数据；描述信息则主要是编译、连接程序对源程序中相关伪指令进行处理所得到的信息。我们在程序 6.2 中，用伪指令 end 描述了程序的结束和程序的入口。在编译、连接后，由 “end start” 指明的程序入口，被转化为一个入口地址，存储在可执行文件的描述信息中。在程序 6.2 生成的可执行文件中，这个入口地址的偏移地址部分为：10H。当程序被加载入内存之后，加载者从程序的可执行文件的描述信息中读到程序的入口地址，设置 CS:IP。这样 CPU 就从我们希望的地址处开始执行。

归根结底，我们若要 CPU 从何处开始执行程序，只要在源程序中用 “end 标号” 指明就可以了。

有了这种方法，就可以这样来安排程序的框架：

```assembly
assume cs:code
code segmetn

	数据

start:

	代码
	
code ends
end start
```





#### 6.2	在代码段中使用栈

完成下面的程序，利用栈，将程序中定义的数据逆序存放。

```assembly
assume cs:codesg
codesg segment

    dw 0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h
	  ?
    
codesg ends
end start
```



程序的思路大致如下。

程序运行时，定义的数据存放在 cs:0~cs:F 单元中，共 8 个字单元。依次将这 8 个字单元中的数据入栈，然后再依次出栈到这 8 个字单元中，从而实现数据的逆序存放。

问题是，我们首先要有一段可当作栈的内存空间。如前所述，这段空间应该由系统来分配。可以在程序中通过定义数据来取得一段空间，然后将这段空间当作栈空间来用。程序如下。



##### 程序 6.3

```assembly
assume cs:codesg
codesge segment
	dw 0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h
	dw 0、0、0、0、0、0、0、0、0、0、0、0、0、0、0、0
	;用 dw 定义 16 个字型数据，在程序加载后，将取得 16 个字的内存空间，存放这 16 个数据。
	;在后面的程序中将这段空间当作栈来使用
	
start:	mov ax,cs
		mov ss,ax
		mov sp,30h		;将设置栈顶 ss:sp 指向 cs:30
		
		mov bx,0
		mov cx,8
	s:  push cs:[bx]
		add bx,2
		loop s			;以上将代码段 0~15 的单元中的 8 个字型数据依次入栈
		
		mov bx,0
		mov cx,8
	s0: pop cs:[bx]
    	add bx,2
    	loop s0			;以上依次出栈 8 个字型数据到代码段 0~15 单元中
    	
    	mov ax,4c00h
    	int 21h
    	
codesg ends
end start				;指明程序的入口在 start 处
```



注意程序 6.3 中的指令：

mov ax,cs

mov ss,ax

mov sp,30h



我们要将 cs:10~cs:2F 的内存空间当作栈来用，初始状态下栈为空，所以 ss:sp 要指向栈底，则设置 ss:sp 指向 cs:30。

在代码段中定义了 16 个字型数据，它们的数值都是 0。这 16 个字型数据的值是多少，对程序来说没有意义。我们用 dw 定义 16 个数据，即在程序中写入了 16 个字型数据，而程序在加载后，将用 32 个字节的内存空间来存放它们。这段内存空间是我们所需要的，程序将它用作栈空间。可见，我们定义这些数据的最终目的是，通过它们取得一定容量的内存空间。所以我们在描述 ds 的作用时，可以说用它定义数据，也可以说用它开辟内存空间。比如对于：

dw 0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h

可以说，定义了 8 个字型数据，也可以说，开辟了 8 个字的内存空间，这段空间中每个字单元的数据依次是：0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h。因为它们最终的效果是一样的。





#### 6.3	将数据、代码、栈放入不同的段

在前面的内容中，我们在程序中用到了数据和栈，将数据、栈和代码都放到了一个段里面。我们在编程的时候要注意何处是数据，何处是栈，何处是代码。这样做显然有两个问题：

（1）把它们放到一个段中使程序显得混乱；

（2）前面程序中处理的数据很少，用到的栈空间也小，加上没有多长的代码，放到一个段里面没有问题。但如果数据、栈和代码需要的空间超过 64KB，就不能放在一个段中（一个段地容量不能大于 64KB，是我们在学习中所用的 8086 模式的限制，并不是所有的处理器都这样）。

所以，应该考虑用多个段来存放数据、代码和栈。

怎样做呢？我们用和定义代码段一样的方法来定义多个段，然后在这些段里面定义需要的数据，或通过定义数据来取得栈空间。具体做法如下面的程序所示，这个程序实现了和程序 6.3 一样的功能，不同之处在于它将数据、栈和代码放到了不同的段中。



##### 程序 6.4

```assembly
assume cs:code,ds:data,ss:stack
data segment
	dw 0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h
data ends

stack segment
	dw 0、0、0、0、0、0、0、0、0、0、0、0、0、0、0、0
stack ends

code segment
start:	mov ax,stack
		mov ss,ax
		mov sp,20h		;设置栈顶 ss:sp 指向 stack:20
		
		mov ax,data		
		mov ds,ax		;ds 指向 data 段
		
		mov bx,0		;ds:bx 指向 data 段中的第一个单元
		mov cx,8
		
	s:  push [bx]
		add bx,2
		loop s			;以上将 data 段 0~15 单元中的 8 个字型数据依次入栈
		
		mov bx,0
		mov cx,8
		
	s0: pop [bx]
    	add bx,2
    	loop s0			;以上依次出栈 8 个字型数据到 data 段 0~15 单元中
    	
    	mov ax,4c00h
    	int 21h
    	
code ends
end start				
```



下面对程序 6.4 做出说明。

（1）定义多个段的方法

这点，我们从程序中可明显地看出，定义一个段的方法和前面所讲的定义代码段的方法没有区别，只是对于不同的段，要有不同的段名。

（2）对段地址的引用

现在，程序中有多个段了，如何访问段中的数据呢？当然要通过地址，而地址是分为两部分的，即段地址和偏移地址。如何指明要访问的数据的段地址呢？在程序中，段名就相当于一个标号，它代表了段地址。所以指令 “mov ax,data” 的含义就是将名称为 “data” 的段的段地址送入 ax。一个段中的数据的段地址可由段名代表，偏移地址就要看它在段中的位置了。程序中 “data” 段中的数据 “0abch” 的地址就是：data:6。要将它送入 bx 中，就要用如下的代码：

mov ax,data

mov ds,ax

mov bs,ds:[6]

我们不能用下面的指令：

mov ds,data

mov bx,ds:[6]

其中指令 “mov ds,data” 是错误地，因为 8086CPU 不允许将一个数值直接送入段寄存器中。程序中对段名的引用，如指令 “mov ds,data” 中的 “data”，将被编译器处理为一个表示段地址的数值。

（3）“代码段‘、”数据段“、”栈段“ 完全是我们的安排

现在，我们以一个具体的程序来再次讨论一下所谓的 “代码段‘、”数据段“、”栈段“。在汇编源程序中，可以定义许多的段，比如在程序 6.4 中，定义了 3 个段，”code“、”data“ 和 "stack"。我们可以分别安排它们存放代码、数据和栈。那么我们如何让 CPU 按照我们这种安排来执行这个程序呢？下面来看看源程序中对这 3 个段所做的处理。

1. 我们在源程序中为这 3 个段起了具有含义的名称，用来放数据的段我们将其命名为 ”data“，用来放代码的段我们将其命名为 ”code“，用作栈空间的段命名为 ”stack“。

   这样命名了之后，CPU 是否就去执行 ”code“ 段中的内容，处理 ”data“ 段中的数据，将 ”stack“ 当作栈了呢？

   当然不是，我们这样命名，仅仅是为了使程序便于阅读。这些名称同 ”start“、”s“、”s0“ 等标号一样，仅在源程序中存在，CPU 并不知道它们。

2. 我们在源程序中用伪指令 ”assume cs:code,ds:data,ss:stack“ 将 cs、ds 和 ss 分别和 ”code“、”data“ 和 "stack" 段相连。这样做了之后。CPU 是否就会将 cs 指向 code，ds 指向 data，ss 指向 stack，从而按照我们的意图来处理这些段呢？

   当然也不是，要知道 assume 是伪指令，是由编译器执行的，也是仅在源程序中存在的信息，CPU 并不知道它们。我们不必深究 assume 的作用，只要知道需要用它将你定义的具有一定用途的段和相关的寄存器联系起来就可以了。

3. 若要 CPU 按照我们的安排行事，就要用机器指令控制它，源程序中的汇编指令是 CPU 要执行的内容。CPU 如何知道去执行它们？我们在源程序的最后用 ”end start“ 说明了程序的入口，这个入口将被写入可执行文件的描述信息，可执行文件中的程序被加载入内存后，CPU 的 CS:IP 被设置指向这个入口，从而开始执行程序中的第一条指令。标号 ”start“ 在 ”code“ 段中，这样 CPU 就将 code 段中的内容当作指令来执行了。我们在 code 段中，使用指令：

   mov ax,stack

   mov ss,ax

   mov sp,20h

   设置 ss 指向 stack，设置 ss:sp 指向 stack:20，CPU 执行这些指令后，将把 stack 段当作栈空间来用。CPU 若要访问 data 段中的数据，则可用 ds 指向 data 段，用其他的寄存器（如 bx）来存放 data 段中数据的偏移地址。

   

总之，CPU 到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，还是当作栈空间，完全是靠程序中具体的汇编指令，和汇编指令对 CS:IP、SS:SP、DS 等寄存器的设置来决定的。完全可以将程序 6.4 写成下面的样子，实现同样的功能。

```assembly
assume cs:b,ds:a,ss:c
a segment
	dw 0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h
a ends

c segment
	dw 0、0、0、0、0、0、0、0、0、0、0、0、0、0、0、0
c ends

b segment
d:		mov ax,c
		mov ss,ax
		mov sp,20h		;希望用 c 段当作栈空间，设置栈顶 ss:sp 指向 c:20
		
		mov ax,a	
		mov ds,ax		;希望用 ds:bx 访问 a 段中的数据，ds 指向 a 段
		
		mov bx,0		;ds:bx 指向 a 段中的第一个单元
		mov cx,8
		
	s:  push [bx]
		add bx,2
		loop s			;以上将 a 段 0~15 单元中的 8 个字型数据依次入栈
		
		mov bx,0
		mov cx,8
		
	s0: pop [bx]
    	add bx,2
    	loop s0			;以上依次出栈 8 个字型数据到 a 段 0~15 单元中
    	
    	mov ax,4c00h
    	int 21h
    	
b ends
end d					;d 处是要执行的的第一条指令，即程序的入口
```





### 第 7 章	更灵活的定位内存地址的方法

前面，我们用 [0]、[bx] 的方法，在访问内存的指令中，定位内存单元的地址。本章我们主要通过具体的问题来讲解一些更灵活的定位内存地址的方法和相关的编程方法。我们的讲解将通过具体的问题来进行。



#### 7.1	and 和 or 指令

首先，介绍两条指令 and 和 or，因为我们下面的例程中要用到它们。、

（1）and 指令：逻辑与指令，按位进行与运算。

例如指令：

mov al,01100011B

and  al,00111011B

执行后：al=00100011B

通过改指令可将操作对象的相应位设为 0，其他位不变。



（2）or 指令：逻辑或指令，按位进行或运算。

例如指令：

mov al,01100011B

or     al,00111011B

执行后：al=01111011B

通过该指令可将操作对象的相应位设为 1，其他位不变。



#### 7.2	关于 ASCII 码

略





#### 7.3	以字符形式给出的数据

我们可以在汇编程序中，用 '........' 的方式指明数据是以字符的形式给出的，编译器将把它们转化为相对应的 ASCII 码。



#### 7.4	大小写转换的问题

如果一个问题的解决方案，使我们陷入一种矛盾之中。那么，很可能是我们考虑问题的出发点有了问题，或是说，我们起初运用的规律并不合适。



#### 7.5	[bx+idata]

在前面，我们用 [bx] 的方式来指明一个内存单元，还可以用一种更为灵活的方式来指明内存单元：[bx+idata] 表示一个内存单元，它的偏移地址为 (bx)+idata（bx 中的数值加上 idata）。

我们看一下指令 mov ax,[bx+200] 的含义：

将一个内存单元的内容送入 ax，这个内存单元的长度为 2 个字节（字单元），存放一个字，偏移地址为 bx 中的数值加上 200，段地址在 ds 中。

数字化的描述为：(ax)=((ds)*16+(bx)+200)

该指令也可以写成如下格式（常用）：

mov ax,[200+bx]

mov ax,200[bx]

mov ax,[bx] .200





#### 7.6	用 [bx+idata] 的方式进行数组的处理

有了 [bx+idata] 这种表示内存单元的方式，我们就可以用更高级的结构来看待所要处理的数据。



c 语言：a[i]，b[i]

汇编语言：0[bx]，5[bx]

通过比较，我们可以发现，[bx+idata] 的方式为高级语言实现数组提供了便利机制。





#### 7.7	SI 和 DI

SI（Source Index）：源变址寄存器

DI（Destination Index）：目的变址寄存器

si 和 di 是 8086CPU 中和 bx 功能相近的寄存器，si 和 di 不能够分成两个 8 位寄存器来使用。下面的 3 组指令实现了相同的功能。

(1) mov bx,0

​	 mov ax,[bx]

(2) mov si,0

​     mov ax,[si]

(3) mov di,0

​	  mov ax,[di]

下面的 3 组指令实现了相同的功能。

(1) mov bx,0

​	  mov ax,[bx+123]

(2) mov si,0

​	  mov ax,[si+123]

(3) mov di,0

​	  mov ax,[di+123]





#### 7.8	[bx+si] 和 [bx+di]

略





#### 7.9	[bx+si+idata] 和 [bx+di+idata]

该指令也可以写成如下格式（常用）：

mov ax,[bx+200+si]

mov ax,[200+bx+si]

mov ax,200[bx] [si]

mov ax,[bx] .200[si]

mov ax,[bx] [si] .200





#### 7.10	不同的寻址方式的灵活应用

如果我们比较一下前面用到的几种定位内存地址的方法（可称为寻址方式），就可以发现：

(1) [idata] 用一个常量来表示地址，可用于直接定位一个内存单元；
(2) [bx] 用一个变量来表示内存地址，可用于间接定位一个内存单元；
(3) [bx+idata] 用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；
(4) [bx+si] 用两个变量表示地址；
(5) [bx+si+idata] 用两个变量和一个常量表示地址。

可以看到，从 [idata] 到 [bx+si+idata]，我们可以用更加灵活的方式来定位一个内存单元的地址。这使我们可以从更加结构化的角度来看待所要处理的数据。


我们在这里讨论的问题是，程序中经常需要进行数据的暂存，怎样做将更为合理。这些数据可能是寄存器中的，也可能是内存中的。我们可以用寄存器暂存它们，但是这不是一个一般化的解决方案，因为寄存器的数量有限，每个程序中可使用的寄存器都不一样。我们希望寻找一个通用的方案，来解决这种在编程中经常会出现的问题。

显然，我们不能选择寄存器，那么可以使用的就是内存了。可以考虑将需要暂存的数据放到内存单元中，需要使用的时候，再从内存单元中恢复。这样我们就需要开辟一段内存空间。

我们使用内存来暂存数据，这一点是确定了的，但是值得推敲的是，我们用怎样的结构来保存这些数据，而使得我们的程序更加清晰。**一般来说，在需要暂存数据的时候，我们都应该使用栈**。





### 第 8 章	数据处理的两个基本问题

本章对前面的所有内容是具有总结性的。我们知道，计算机是继续数据处理、运算的机器，那么有两个基本的问题就包含在其中：

（1）处理的数据在什么地方？

（2）要处理的数据有多长？

这两个问题，在机器指令中必须给以明确或隐含的说明，否则计算机就无法工作。本章中，我们就要针对 8086CPU 对这两个基本问题进行讨论。虽然讨论是在 8086CPU 的基础上进行的，但是这两个基本问题确实普遍的，对任何一个处理机都存在。

我们定义的描述性符号：reg 和 sreg。

为了描述上的简洁，在以后的课程中，我们将使用两个描述性的符号 reg 来表示一个寄存器，用 sreg 表示一个段寄存器。

reg 的集合包括：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di；

sreg 的集合包括：ds、ss、cs、es。



#### 8.1	bx、si、di 和 bp

前 3 个寄存器我们已经用过了，现在我们进行一下总结。

（1）在 8086CPU 中，只有这 4 个寄存器可以用在 “[...]” 中来进行内存单元的寻址。比如下面的指令都是正确的：

mov ax,[bx]

mov ax,[bx+si]

mov ax,[bx+di]

mov ax,[bp]

mov ax,[bp+si]

mov ax,[bp+di]

而下面的指令是错误的：

mov ax,[cx]

mov ax,[ax]

mov ax,[dx]

mov ax,[ds]



（2）在 [...] 中，这 4 个寄存器可以单个出现，或只能以 4 种组合出现：bx 和 si、bx 和 di、bp 和 si、bp 和 di。比如下面的指令是正确的：

mov ax,[bx]

mov ax,[si]

mov ax,[di]

mov ax,[bp]

mov ax,[bx+si]

mov ax,[bx+di]

mov ax,[bp+si]

mov ax,[bp+di]

mov ax,[bx+si+idata]

mov ax,[bx+di+idata]

mov ax,[bp+si+idata]

mov ax,[bp+di+idata]

下面的指令是错误的：

mov ax,[bx+bp]

mov ax,[si+di]



（3）只要在 [...] 中使用寄存器 bp，而指令中没有显性地给出段地址，段地址就默认在 ss 中。比如下面的指令。

mov ax,[bp]						含义：(ax)=((ss)*16+(bp))

mov ax,[bp+idata]			 含义：(ax)=((ss)*16+(bp)+idata)

mov ax,[bp+si]			   	含义：(ax)=((ss)*16+(bp)+(si))

mov ax,[bp+si+idata]		含义：(ax)=((ss)*16+(bp)+(si)+idata)





#### 8.2	机器指令处理的数据在什么地方

绝大部分机器指令都是进行数据处理的指令，处理大致可分为 3 类：读取、写入、运算。在机器指令这一层来讲，并不关心数据的值是多少，而关心**指令执行前一刻**，它将要处理的数据所在的位置。指令在执行前，所要处理的数据可以在 3 个地方：CPU 内部、内存、端口（端口将在后面的课程中进行讨论），比如表 8.1 中所列的指令。









#### 8.3	汇编语言中数据位置的表达

在汇编语言中如何表达数据的位置？汇编语言中用 3 个概念来表达数据的位置。

（1）立即数（idata）

对于直接包含在机器指令中的数据（执行前在 CPU 的指令缓冲器中），在汇编语言中称为：立即数（idata），在汇编指令中直接给出。

例：mov ax,1

​		add bx,2000h

​		or	bx,00010000b

​		mov al,'a'



（2）寄存器

指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。

例：mov ax,bx

​		mov ds,ax

​		push bx

​		mov ds:[0],bx

​		push ds

​		mov ss,ax

​		mov sp,ax



（3）段地址（SA）和偏移地址（EA）

偏移地址(Offset Address = OA)，又叫有效地址(Effective Address = EA)。

指令要处理的数据在内存中，在汇编指令中可用 [X] 的格式给出 EA，SA 在某个段寄存器中。

存放段地址的寄存器可以是默认的，比如：

mov ax,[0]

mov ax,[di]

mov ax,[bx+8]

mov ax,[bx+si]

mov ax,[bx+si+8]

等指令，段地址默认在 ds 中：

mov ax,[bp]

mov ax,[bp+8]

mov ax,[bp+si]

mov ax,[bp+si+8]

等指令，段地址默认在 ss 中。

存放段地址的寄存器也可以是显性给出的，比如以下的指令。

mov ax,ds:[bp]				 含义：(ax)=((ds)*16+(bp))

mov ax,es:[bx]				 含义：(ax)=((es)*16+(bx))

mov ax,ss:[bx+si]			含义：(ax)=((ss)*16+(bx)+(si))

mov ax,cs:[bx+si+8]	    含义：(ax)=((cs)*16+(bx)+(si)+8)





#### 8.4	寻址方式

当数据存放在内存中的时候，我们可以用多种方式来给定这个内存单元的偏移地址，这种定位内存单元的方法一般被称为寻址方式。

8086CPU 有多种寻址方式，我们在前面的课程中都已经用到了，这里进行一下总结，如表 8.2 所列。









#### 8.5	指令要处理的数据有多长

8086CPU 的指令，可以处理两种尺寸的数据，byte 和 word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。对于这个问题，汇编语言中用以下方法处理。

（1）通过寄存器指明要处理的数据的尺寸。

例如，下面的指令中，寄存器指明了指令进行的是字操作。

mov ax,1

mov bx,ds:[0]

mov ds,ax

mov ds:[0],ax

inc ax

add ax,1000



下面的指令中，寄存器指明了指令进行的是字节操作。

mov al,1

mov al,bl

mov al,ds:[0]

mov ds:[0],al

inc al

add al,100



（2）在没有寄存器名存在的情况下，用操作符 X ptr 指明内存的那与的长度，X 在汇编指令中可以为 word 或 byte。

例如，下面的指令中，用 word ptr 指明了指令访问的内存单元是一个字单元。

mov word ptr ds:[0],1

inc word ptr [bx]

inc word ptr ds:[0]

add word ptr [bx],2

下面的指令中，用 byte ptr 指明了指令访问的内存单元是一个字节单元。

mov byte ptr ds:[0],1

inc byte ptr [bx]

inc byte ptr ds:[0]

add byte ptr [bx],2

在没有寄存器参与的内存单元访问指令中，用 word ptr 或 byte ptr 显性地指明所要访问地内存单元地长度是很必要的。否则，CPU 无法得知所要访问的单元是字单元，还是字节单元。假设我们用 Debug 查看内存的结果如下：

2000:	1000	FF	FF	FF	FF	FF	FF	....

那么指令：

mov ax,2000H

mov ds,ax

mov byte ptr [1000H],1

将使内存中的内容变为：

2000:	1000	01	FF	FF	FF	FF	FF	....

而指令：

mov ax,2000H

mov ds,ax

mov word ptr [1000H],1

将使内存中的内容变为：

2000:	1000	01	00	FF	FF	FF	FF	....



（3）其他方法

有些指令默认了访问的是字单元还是字节单元，比如，push [1000H] 就不用指明访问的是字单元还是字节单元，因为 push 指令只进行字操作。





#### 8.6	寻址方式的综合应用

下面我们通过一个问题来进一步讨论一下各种寻址方式的作用。

关于 DEC 公司的一条记录（1982 年）如下。

公司名称：DEC

总裁姓名：Ken Olsen

排名：137

收入：40（40 亿美元）

著名产品：PDP（小型机）

这些数据在内存中以图 8.1 所示的方式存放。

可以看到，这些数据被存放在 seg 段中从偏移地址 60H 起使的位置，从 seg:60 起始以 ASCII 字符的形式存储了 3 个字节的公司名称：从 seg:60+3 起始以 ASCII 字符的形式存储了 9 个字节的总裁姓名：从 seg:60+0C 起始存放了一个字型数据，总裁在富翁榜上的排名：从 seg:60+0E 起始存放了一个字型数据，公司的收入；从 seg:60+10 起使以 ASCII 字符的形式存储了 3 个字节的产品名称。



我们可以看到，8086CPU 提供的如 [bx+si+idata] 的寻址方式为结构化数据的处理提供了方便。使得我们可以在编程的时候，从结构化的角度去看待所要处理的数据。从上面可以看到，一个结构化的数据包含了多个数据项，而数据项的类型又不相同，有的是字符型数据，有的是字节型数据，有的是数组（字符串）。一般来说，我们可以用 [bx+idata+si] 的方式来访问结构体中的数据。用 bx 定位整个结构体，用 idata 定位结构体中的某一个数据项，用 si 定位数组项中的每个元素。为此，汇编语言提供了更为贴切的书写方式，如：[bx].idata、[bx].idata[si]。

在 C 语言中我们看到，如：dex.cp[i]，dec 是一个变量名，指明了结构体的地址，cp 是一个名称，指明了数据项 cp 的地址，而 i 用来定位 cp 中的每一个字符。汇编语言中的做法是：bx.10h[si]。看一下，是不是很相似？





#### 8.7	div 指令

div 是除法指令，使用 div 做除法的时候应注意以下问题。

（1）除数：有 8 位和 16 位两种，在一个 reg 或内存单元中。

（2）被除数：默认放在 AX 或 DX 和 AX 中，如果除数为 8 位，被除数则为 16 位，默认在 AX 中存放；如果除数为 16 位，被除数为 32 位，在 DX 和 AX 中存放，DX 存放高 16 位，AX 存放低 16 位。

（3）结果：如果除数为 8 位，则 AL 存储除法操作的商，AH 存储除法操作的余数；如果除数为 16 位，则 AX 存储除法操作的商，DX 存储除法操作的余数。

格式如下：

div reg

div 内存单元

现在，我们可以用多种方法来表示一个内存单元了，比如下面的例子：

div byte ptr ds:[0]
    (al)=(ax)/((ds)*16+0)的商
    (ah)=(ax)/((ds)*16+0)的余数

div word ptr es:[0]
          （高十六位）+(低十六位)
    (ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商
    (dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数

div byte ptr [bx+si+8]
(al)=(ax)/((ds)*16+(bx)+(si)+8)的商
        (ah)=(ax)/((ds)*16+(bx)+(si)+8)的余数

div word ptr [bx+si+8]

​		高十六位)+(低十六位)

​		(ax)=[(dx)*10000H+(ax)]/((ds)*16+(bx)+(si)+8)的商
​        (dx)=[(dx)*10000H+(ax)]/((ds)*16+(bx)+(si)+8)的余数





#### 8.8	伪指令 dd

前面我们用 ds 和 dw 定义字节型数据和字型数据。dd 是用来定义 dword（double word，双字）型数据的。比如：

data segment

​	db 1

​	dw 1

​	dd 1

data ends



在 data 段中定义了 3 个数据：

第一个数据为 01H，在 data:0 处，占 1 个字节；

第二个数据为 0001H，在 data:1 处，占 1 个字；

第三个数据为 00000001H，在 data:3 处，占 2 个字。





#### 8.9	dup

dup 是一个操作符，在汇编语言中同 db、dw、dd 等一样，也是由编译器识别处理的符号。它是和 db、dw、dd 等数据定义伪指令配合使用的，用来进行数据的重复。比如：

db 3 dup (0)

定义了 3 个字节，它们的值都是 0，相当于 db 0,0,0。

db 3 dup (0,1,2)

定义了 9 个字节，它们是 0、1、2、0、1、2、0、1、2，相当于 db 0,1,2,0,1,2,0,1,2。

db 3 dup ('abc','ABC')

定义了 18 个字节，它们是 'abcABCabcABCabcABC'，相当于 db 'abcABCabcABCabcABC'。

可见，dup 的使用格式如下。

db 重复的次数 dup (重复的字节型数据)

dw 重复的次数 dup (重复的字型数据)

dd 重复的次数 dup (重复的双字型数据)


















































































































































































































































































































