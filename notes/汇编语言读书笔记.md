## 汇编语言读书笔记

### 第 1 章	基础知识

汇编语言是直接在硬件之上工作的编程语言，我们首先要了解硬件系统的结构，才能有效地应用汇编语言对其编程。



#### 1.1 机器语言

机器语言是机器指令的集合。机器指令展开来讲就是一台机器可以正确执行的命令。电子计算机的机器指令是一列二进制数字。计算机将之转变为一列高低电平，以使计算机的电子器件受到驱动，进行运算。

上面所说的计算机指的是可以执行机器指令，进行运算的机器。在我们常用的 PC 机中，有一个芯片来完成上面所说的计算机的功能。这个芯片就是我们常说的 CPU（Central Processing Unit，中央处理单元），CPU 是一种微处理器。以后我们提到的计算机是指由 CPU 和其他受 CPU 直接或间接控制的芯片、器件、设备组成的计算机系统，比如我们最常见的 PC 机。

每一种微处理器，由于硬件设计和内部结构的不同，就需要用不同的电平脉冲来控制，使它工作。所以每一种微处理器都有自己的机器指令集，也就是机器语言。



#### 1.2 汇编语言的产生

由于机器语言的晦涩难懂和不易查错，给整个产业的发展带来了障碍，汇编语言产生了。

汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令是机器指令便于记忆的书写格式。如下例所示：

操作：寄存器 BX 的内容送到 AX 中

机器指令：1000100111011000

汇编指令：mov ax,bx



寄存器，简单地讲是 CPU 中可以存储数据的器件，一个 CPU 中有多个寄存器。AX 和 bX 是寄存器的代号。

我们需要编译器将汇编语言解读成计算机能读懂的机器指令。图 1.1 描述了这个工作过程。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE5.jpg"/> </div><br>
#### 1.3 汇编语言的组成

汇编语言有以下 3 类指令组成。

（1）汇编指令：机器码的助记符，有对应的机器码。

（2）伪指令：没有对应的机器码，由编译器执行，计算机并不执行。

（3）其他符号：如 +、-、*、/ 等，由编译器识别，没有对应的机器码。

汇编语言的核心是汇编指令，它决定了汇编语言的特性。



#### 1.4 存储器

CPU 是计算机的核心部件，它控制整个计算机的运作并进行运算。要想让一个 CPU 工作，就必须向它提供指令和数据。指令和数据在存储器中存放，也就是我们平时所说的内存。磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被 CPU 使用。要灵活地利用汇编语言编程，我们首先要了解 CPU 是如何从内存中读取信息，以及向内存中写入信息的。



#### 1.5 指令和数据

指令和数据是应用上的概念。在内存或磁盘上，指令和数据没有任何区别，都是二进制信息。CPU 在工作的时候把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同的意义。

例如，内存中的二进制信息 1000100111011000，计算机可以把它看作大小为 89D8H 的数据来处理，也可以将其看作指令 mov ax,bx 来执行。

```assembly
1000100111011000 ——> 89D8H（数据）
1000100111011000 ——> mov ax,bx（程序）
```



#### 1.6 存储单元

存储器被划分成若干个存储单元，每个存储单元从 0 开始顺序编号，例如一个存储器有 128 个存储单元，编号从 0~127，如图 1.2 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE1.jpg"/> </div><br>
那么一个存储单元能存储多少信息呢？我们知道电子计算机的最小信息单位是 bit（音译为比特），也就是一个二进制位。8 个 bit 组成一个 Byte，也就是通常讲的一个字节。微型机存储器的存储单元可以存储一个 Byte，即 8 个二进制位。一个存储器有 128 个存储单元，它可以存储 128 个 Byte。

微机存储器的容量是以字节为最小单位来计算的。对于拥有 128 个存储单元的存储器，我们可以说，它的容量是 128 个字节。

对于大容量的存储器一般还用以下单位来计量容量（以下用 B 来代表 Byte）

1KB=1024B	1MB=1024KB	1GB=1024MB	1TB=1024GB

磁盘的容量单位同内存的一样，实际上以上单位是微机中常用的计量单位。



#### 1.7 CPU 对存储器的读写

CPU 要从内存中读数据，首先要指定存储单元的地址。另外，在一台微机中，不止有存储器这一种器件。CPU 在读写时还要指明，它要对哪一个器件进行操作，进行哪种操作，是从中读出数据，还是向里面写入数据。

可见，CPU 要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行下面 3 类信息的交互。

- 存储单元的地址（地址信息）；
- 器件的选择，读或写的命令（控制信息）；
- 读或写的数据（数据信息）。

那么 CPU 是通过什么将地址、数据和控制信息传到存储器芯片中的呢？电子计算机能处理、传输的信息都是电信号，电信号当然要用导线传送。在计算机中专门有连接 CPU 和其他芯片的导线，通常称为总线。总线从物理上来讲，就是一根根导线的集合。根据传送信息的不同，总线从逻辑上又分为 3 类，地址总线、控制总线和数据总线。

CPU 从 3 号单元中读取数据的过程（见图 1.3）如下。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE2.jpg"/> </div><br>
（1）CPU 通过地址线将地址信息 3 发出。

（2）CPU 通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。

（3）存储器将 3 号单元中的数据 8 通过数据线送入 CPU。



对于 8086CPU，下面的机器码，能够完成从 3 号单元读数据。

机器码：	101000010000001100000000

含义：		从 3 号单元读取数据送入寄存器 AX

CPU 接收这条机器码后将完成我们上面所述的读写工作。

机器码难于记忆，用汇编指令来表示，情况如下。

机器码：	10100001 00000011 00000000

对应的汇编指令：MOV AX,[3]

含义：		传送 3 号单元的内容入 AX



#### 1.8 地址总线

现在我们知道，CPU 是通过地址总线来指定存储器多纳伊的。可见地址总线上能传送多少个不同的信息，CPU 就可以对多少个存储单元进行寻址。

现假设，一个 CPU 有 10 根地址总线，让我们来看一下它的寻址情况。我们知道，在电子计算机中，一根导线可以传送的稳定状态只有两种，高电平或是低电平。用二进制表示就是 1 或 0，10 根导线可以传送 10 位二进制数据。而 10 位二进制数可以表示多少个不同的数据呢？2 的 10 次方个。最小数为 0，最大数为 1023。

一个 CPU 有 N 根地址线，则可以说这个 CPU 的地址总线的宽度为 N。这样的 CPU 最多可以寻找 2 的 N 次方个内存单元。



#### 1.9 数据总线

CPU 与内存或其他器件之间的数据传送是通过数据总线来进行的。数据总线的宽度决定了 CPU 和外界的数据传送速度。8 根数据总线一次可传送一个 8 位二进制数据（即一个字节）。16 根数据总线一次可传送两个字节。

8088CPU 的数据总线宽度为 8，8086CPU 的数据总线宽度为 16。我们来分别看一下它们向内存中写入数据 89D8H 时，是如何通过数据总线传送数据的。图 1.5 展示了 8088CPU 数据总线上的数据传送情况；图 1.6 展示了 8086CPU 数据总线上的数据传送情况。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE3.jpg"/> </div><br>
<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE4.jpg"/> </div><br>
8086 有 16 根数据线，可一次传送16 位数据，所以可一次传送数据 89D8H；而 8088 只有 8 根数据线，一次只能传 8 位数据，所以向内存写入数据 89D8H 时需要进行两次数据传送。



#### 1.10 控制总线

CPU 对外部器件的控制是通过控制总线来进行的。在这里控制总线是个总称，控制总线是一些不同控制线的集合。有多少根控制总线，就意味着 CPU 提供了对外部器件的多少种控制。所以，控制总线的宽度决定了 CPU 对外部器件的控制能力。

前面所讲的内容读或写命令是由几根控制线综合发出的，其中有一根称为 “读信号输出” 的控制线负责由 CPU 向外传送读信号，CPU 向该控制线上输出低电平表示将要读取数据；有一根称为 “写信号输出” 的控制线则负责传送写信号。



#### 1.1~1.10 小结

（1）汇编指令是机器指令的助记符，同机器指令一一对应。

（2）每一种 CPU 都有自己的汇编指令集。

（3）CPU 可以直接使用的信息在存储器中存放。

（4）在存储器中指令和数据没有任何区别，都是二进制信息。

（5）存储单元从零开始顺序编号。

（6）一个存储单元可以存储 8 个 bit，即 8 位二进制数。

（7）1KB=1024B	1MB=1024KB	1GB=1024MB	1TB=1024GB

（8）每一个 CPU 芯片都有许多管脚，这些管脚和总线相连。也可以说，这些管脚引出总线。一个 CPU 可以引出 3 种总线的宽度标志了这个 CPU 的不同方面的性能：

​	地址总线的宽度决定了 CPU 的寻址能力；

​	数据总线的宽度决定了 CPU 与其他器件进行数据传送时的一次数据传送量；

​	控制总线的宽度决定了 CPU 对系统中其他器件的控制能力。



#### 监测点 1.1

1. 1 个 CPU 的寻址能力为 8KB，那么它的地址总线的宽度为____。
   **13**
   解析：CPU 在内存中寻址的最小单位是 Byte（字节），8KB = 2^13^ B，因此地址总线的宽度为 13。
2. 1KB 的存储器有____个存储单元。存储单元的编号从____到____。
   **1024 0 1023**
3. 1KB 的存储器可以存储____个 bit，____个 Byte。
   **2^13^ 2^10^**
4. 1GB、1MB、1KB分别是____________Byte
   **2^30^ 2^20^ 2^10^**
5. 8080、8088、80286、80386 的地址总线宽度分别为 16 根、20 根、24 根、32 根，则他们的寻址能力分别为____（KB）、____（MB）、____（MB）、____（GB）。
   **64 1 16 4**
6. 8080、8088、8086、80286、80386 的数据总线宽度分别为 8 根、8 根、16 根、16 根、32 根。则它们一次可以传送的数据为：____（B）、____（B）、____（B）、____（B）、____（B）。
   **1 1 2 2 4**
7. 从内存中读取 1024 字节的数据，8086 至少要读取____次，80386 至少要读取____次。
   **512 256**
8. 在存储器中，数据和程序以____形式存放。
   **二进制**





#### 1.11	内存地址空间（概述）

什么是内存地址空间呢？举例来讲，一个 CPU 的地址总线宽度为 10，那么可以寻址 1024 个内存单元，这 1024 个可寻到的内存单元就构成这个 CPU 的内存地址空间。下面进行深入讨论。首先需要介绍两部分基本知识，主板和接口卡。



#### 1.12	主	板

在每一台 PC 机中，都有一个主板，主板上有核心器件和一些主要器件，这些器件通过总线（地址总线、数据总线、控制总线）相连。这些器件有 CPU、存储器、外围芯片组、扩展插槽等。扩展插槽上一般插有 RAM 内存条和各类接口卡。



#### 1.13	接	口	卡

计算机系统中，所有可用程序控制其工作的设备，必须受到 CPU 的控制。CPU 对外部设备都不能直接控制，如显示器、音箱、打印机等。直接控制这些设备进行工作的是插在扩展插槽上的接口卡。扩展插槽通过总线和 CPU 相连，所以接口卡也通过总线同 CPU 相连。CPU 可以直接控制这些接口卡，从而实现 CPU 对外设的间接控制。简单地讲，就是 CPU 通过总线向接口卡发送命令，接口卡根据 CPU 的命令控制外设进行工作。



#### 1.14	各类存储器芯片

一台 PC 机中，装有多个存储器芯片，这些存储器芯片从物理连接上看是独立的、不同的器件。从读写属性上看分为两类：随机存储器（RAM）和只读存储器（ROM）。随机存储器可读可写，但必须带电存储，关机后存储的内容丢失；只读存储器只能读取不能写入，关机后其中的内容不丢失。这些存储器从功能和连接上又可以分为以下几类。

- 随机存储器

  用于存放供 CPU 使用的绝大部分程序和数据，主随机存储器一般由两个位置上的 RAM 组成，装在主板上 RAM 和插在扩展插槽上的 RAM。

- 装有 BIOS（Basic Input/Output System，基本输入/输出系统）的 ROM

   BIOS 是由主板和各类接口卡（如显卡、网卡等）厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应 BIOS 的 ROM。例如，主板上的 ROM 中存储着主板的 BIOS（通常称为系统 BIOS）；显卡上的 ROM 中存储着显卡的 BIOS；如果网卡上装有 ROM，那其中就可以存储网卡的 BIOS。

- 接口卡上的 RAM

   某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有 RAM。最典型的是显示卡上的 RAM，一般称为显存。显示卡随时将显存中的数据向显示器上输出。换句话说，我们将需要显示的内容写入显存，就会出现在显示器上。

   

图 1.7 展示了 PC 系统中各类存储器的逻辑连接情况。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE6.jpg"/> </div><br>
#### 1.15	内存地址空间

上述的那些存储器，在物理上是独立的器件，但是在以下两点上相同。

- 都和 CPU 的总线相连。
- CPU 对它们进行读或写的时候，都通过控制线发出内存读写命令。

这也就是说，CPU 在操控它们的时候，把它们都当作内存来对待，把它们总的看作一个由若干存储单元组成的**逻辑存储器**，这个逻辑存储器就是我们所说的内存地址空间。在汇编这门课中，我们所面对的是内存地址空间。

图 1.8 展示了 CPU 将系统中各类存储器看作一个逻辑存储器的情况。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE7.jpg"/> </div><br>
在图 1.8 中，所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU 在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。

假设，图 1.8 中的内存地址空间的地址段分配如下：

地址 0~7FFFH 的 32KB 为主随机存储器的地址空间；

地址 8000H~9FFFH 的 8KB 空间为显存地址空间；

地址 A000H~FFFF 的 24KB 空间为各个 ROM 的地址空间。

 这样，CPU 向内存地址为 1000H 的内存单元中写入数据，这个数据就会被写入主随机存储器中。CPU 向内存地址为 8000H 的内存单元中写入数据，这个数据就被写入到显存中，然后会被显卡输出到显示器上。CPU 向内存地址为 C000H 的内存单元中写入数据的操作，是没有任何结果的。C000H 单元中的内容不会被改变，C000H 单元实际上就是 ROM 存储器中的一个单元。

内存地址空间的大小受 CPU 地址总线宽度的限制。8086CPU 的地址总线宽度为 20，可以传送 2^20^ 个不同的地址信息（大小从 0 至 2^20^ - 1）。即可以定位 2^20^ 个内存单元，则 8086PC 的内存地址空间大小为 1MB。同理，80386CPU 的地址空间宽度为 32，则内存地址空间最大为 4GB。

我们在基于一个计算机硬件系统编程的时候，必须知道这个系统中的内存地址空间分配情况。因为当我们想在某类存储器中读写数据的时候，必须知道它的第一个单元的地址和最后一个单元的地址，才能保证读写操作是在预期的存储器中进行。比如，我们希望向显示器输出一段信息，那么必须将这段信息写到显存中，显卡才能将它输出到显示器上，要向显存中写入数据，必须知道显存在内存地址空间中的地址。

不同的计算机系统的内存地址空间的分配情况是不同的，图 1.9 展示了 8086PC 机内存地址空间分配的基本情况。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE8.jpg"/> </div><br>
图 1.9 告诉我们，从地址 0 ~ 9FFFF 的内存单元中读取数据，实际上就是在读取主随机存储器中的数据；向地址 A0000 ~ BFFFF 的内存单元中写数据，就是向显存中写入数据，这些数据会被显示卡输出到显示器上；我们向地址 C0000 ~ FFFFF 的内存单元中写入数据的操作是无效的，因为这等于改写只读存储器中的内容。

最终运行程序的是 CPU，我们用汇编语言编程的时候，必须要从 CPU 的角度考虑问题。对 CPU 来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受 CPU 寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间。

https://docs.qq.com/sheet/DREhUSENWaWtGRWp3?tab=j37kf8&c=K37B0M0



### 第 2 章	寄存器

一个典型的 CPU 由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。前一章所说的总线，相对于 CPU 内部来说是外部总线。内部总线实现 CPU 内部各个器件之间的联系，外部总线实现 CPU 和主板上其他器件的联系。简单地说，在 CPU 中：

- 运算器进行信息处理；
- 寄存器进行信息存储；
- 控制器控制各种器件进行工作；
- 内部总线连接各种器件，在它们之间进行数据的传送。

对于一个汇编程序员来说，CPU 中的主要部件是寄存器。寄存器是 CPU 中程序员可以用指令读写的部件。程序员通过改变各种寄存器中的内容来实现对 CPU 的控制。

不同的 CPU，寄存器的个数、结构是不相同的。8086CPU 有 14 个寄存器，每个寄存器都有一个名称。这些寄存器是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。



AH&AL = AX（accumulator）：累加寄存器

BH&BL = BX（base）：基址寄存器

CH&CL = CX（count）：计数寄存器

DH&DL = DX（data）：数据寄存器

SP（Stack Pointer）：堆栈指针寄存器

BP（Base Pointer）：基址指针寄存器

SI（Source Index）：源变址寄存器

DI（Destination Index）：目的变址寄存器

IP（Instruction Pointer）：指令指针寄存器

CS（Code Segment）：代码段寄存器

DS（Data Segment）：数据段寄存器

SS（Stack Segment）：堆栈寄存器

ES（Extra Segment）：附加段寄存器 OF





#### 2.1	通用寄存器

8086CPU 的所有寄存器都是 16 位的，可以存放两个字节。AX、BX、CX、DX 这 4 个寄存器通常用来存放一般性的数据，被称为通用寄存器。

以 AX 为例，寄存器的逻辑结构如图 2.1 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE9.jpg"/> </div><br>
8086CPU 的上一代 CPU 中的寄存器都是 8 位的，为了保证兼容，使原来基于上代 CPU 编写的程序稍加修改就可以运行在 8086 之上，8086CPU 的 AX、BX、CX、DX 这 4 个寄存器都可分为可独立使用的 8 位寄存器来用：

- AX 可分为 AH 和 AL；

- BX 可分为 BH 和 BL；

- CX 可分为 CH 和 CL；

- DX 可分为 DH 和 DL。

  

以 AX 为例，8086CPU 的 16 位寄存器分为两个 8 位寄存器的情况如图 2.3 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE10.jpg"/> </div><br>
AX 的低 8 位（0 位 ~ 7 位）构成了 AL 寄存器，高 8 位（8 位 ~ 15 位）构成了 AH 寄存器。AH 和 AL 寄存器是可以独立使用的 8 位寄存器。图 2.4 展示了 16 位寄存器及它所分成的两个 8 位寄存器的数据存储的情况。

一个 16 位寄存器可以存储的数据最大值为 65535，一个 8 位寄存器可以存储的数据最大值为 255。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE11.jpg"/> </div><br>
#### 2.2	字在寄存器中的存储

出于对兼容性的考虑，8086CPU 可以一次性处理以下两种尺寸的数据。

- 字节：记为 byte，一个字节由 8 个 bit 组成，可以存在 8 位寄存器中。
- 字：记为 word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节，如图 2.5 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE12.jpg"/> </div><br>
一个字可以存在一个 16 位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高 8 位寄存器和低 8 位寄存器中。如图 2.4 所示，一个字型数据 20000，存在 AX 寄存器中，在 AH 中存储了它的高 8 位，在 AL 中存储了它的低 8 位。AH 和 AL 中的数据，既可以看成是一个字型数据的高 8 位和低 8 位，这个字型数据的大小是 20000；又可以看成是两个独立的字节型数据，它们的大小分别是 78 和 32。





#### 2.3	几条汇编指令

通过汇编指令控制 CPU 进行工作，看一下表 2.1 中的几条指令。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE13.jpg"/> </div><br>
注意，为了使具有高级语言基础的读者更好地理解指令的含义，有时会用文字描述和高级语言描述这两种方式来描述一条汇编指令的含义。在写一条汇编指令或一个寄存器的名称时不区分大小写。如：mov ax,18 和 MOV AX,18 的含义相同：bx 和 BX 的含义相同。





#### 2.4	物理地址

我们知道，CPU 访问内存单元时，要给出内存单元的地址。所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址。

CPU 通过地址总线送入存储器的，必须是一个内存单元的物理地址。在 CPU 向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址。不同的 CPU 可以有不同的形成物理地址的方式。我们现在讨论 8086CPU 是如何在内部形成内存单元的物理地址的。





#### 2.5	16 位结构的 CPU

我们说 8086CPU 的上一代 CPU（8080、8085）等是 8 位机，而 8086 是 16 位机，也可以说 8086 是 16 位结构的 CPU。那么什么是 16 位结构的 CPU 呢？

概括地讲，16 位结构（16 位机、字长为 16 位等常见说法，与 16 位结构的含义相同）描述了一个 CPU 具有下面几方面的结构特性。

- 运算器一次最多可以处理 16 位的数据；

- 寄存器的最大宽度为 16 位；

- 寄存器和运算器之间的通路为 16 位。

  

8086 是 16 位机构的 CPU，这也就是说，在 8086 内部，能够一次性处理、传输、暂时存储的信息的最大长度是 16 位的。内存单元的地址在送上地址总线之前，必须在 CPU 中处理、传输、暂时存放，对于 16 位 CPU，能一次性处理、传输、暂时存储 16 位的地址。





#### 2.6	8086CPU 给出物理地址的方法

8086CPU 有 20 位地址总线，可以传送 20 位地址，达到 1MB 寻址能力。8086CPU 又是 16 位结构，在内部一次性处理、传输、暂时存储的地址为 16 位。从 8086CPU 的内部结构来看，如果将地址从内部简单地发出，那么它只能送出 16 位的地址，表现出的寻址能力只有 64KB。

8086CPU 采用一种在内部用两个 16 位地址合成的方法来形成一个 20 位的物理地址。

8086CPU 相关部件的逻辑结构如图 2.6 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE14.jpg"/> </div><br>
如图 2.6 所示，当 8086CPU 要读写内存时：

（1）CPU 中的相关部件提供两个 16 位的地址，一个称为段地址，另一个称为偏移地址；

（2）段地址和偏移地址通过内部总线送入一个称为地址加法器的部件；

（3）地址加法器将两个 16 位地址合成为一个 20 位的物理地址；

（4）地址加法器通过内部总线将 20 位物理地址送入输入输出控制电路；

（5）输入输出控制电路将 20 位物理地址送上地址总线；

（6）20 位物理地址被地址总线传送到存储器。



地址加法器采用**物理地址=段地址✖16 + 偏移地址**的方法用段地址和偏移地址合成物理地址。





#### 2.7	“段地址✖16 + 偏移地址=物理地址” 的本质含义

注意，这里讨论的是 8086CPU 段地址和偏移地址的本质含义，而不是为了解决具体的问题，而在本质含义之上引申出来的更高级的逻辑意义。不管以多少种不同的逻辑意义去看待 “段地址×16+偏移地址=物理地址” 的寻址模式，一定要清楚地知道它的本质含义，这样才能更灵活地利用它来分析解决问题。如果只拘泥于某一种引申出来的逻辑含义，而模糊本质含义的话，将从意识上限制对这种寻址功能的灵活应用。

“段地址×16+偏移地址=物理地址” 的本质含义是：CPU 在访问内存时，用一个基础地址（段地址×16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。

更一般地说，8086CPU 的这种寻址功能是 **“基础地址+偏移地址=物理地址”** 寻址模式的一种具体实现方案。8086CPU中，段地址×16可看做是基础地址。





#### 2.8	段的概念

我们注意到，“段地址” 这个名称中包含着 “段” 的概念。这种说法可能对一些学习者产生了误导，使人误以为内存被划分成了一个一个的段，每一个段有一个段地址。如果我们在一开始形成了这种认识，将影响以后对汇编语言的深入理解和灵活应用。

其实，内存并没有分段，段的划分来自于 CPU，由于 8086CPU 用 “基础地址（段地址✖16）+偏移地址=物理地址” 的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存。如图 2.9 所示，我们可以认为：地址 10000H~100FFH 的内存单元组成一个段，该段的起始地址（基础地址）为 10000H，段地址为 1000H，大小为 100H；我们也可以认为地址：10000H ~ 1007FH、10080H ~ 100FFH 的内存单元组成两个段，它们的起始地址（基础地址）为：10000H 和 10080H，段地址为：1000H 和 1008H，大小都为 80H。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE15.jpg"/> </div><br>
以后，在编程时可以根据需要，将若干地址连续的内存单元看作一个段，用段地址✖16 定位段的起始地址（基础地址），用偏移地址定位段中的内存单元。有两点需要注意：段地址✖16 必然是 16 的倍数，所以一个段的起始地址也一定是 16 的倍数；偏移地址为 16 位，16 位地址的寻址能力为 64KB，所以一个段的长度最大为 64KB。

CPU 访问内存单元时，必须向内存提供内存的那样的物理地址。8086CPU 在内部用段地址和偏移地址移位相加的方法形成最终的物理地址。

（1）CPU 可以用不同的段地址和偏移地址形成同一个物理地址。

（2）如果给定一个段地址，仅通过变化偏移地址来进行寻址，最多可定位多少个内存单元？

偏移地址 16 位，变化范围为 0~FFFFH，仅用偏移地址来寻址最多可寻 64KB 个内存单元。

在 8086PC 机中，存储单元的地址用两个元素来描述，即段地址和偏移地址。

“数据在 21F60H 内存单元中。” 这句话对于 8086PC 机一般不这样讲，取而代之的是两种类似的说法：（1）数据存在内存 2000:1F60 单元中；（2）数据存在内存的 2000H 段中的 1F60H 单元中。这两种描述都表示 ”数据在内存 21F60H 单元中“。

可以根据需要，将地址连续、起始地址为 16 的倍数的一组内存单元定义为一个段。



#### 2.9	段寄存器

我们前面讲到，8086CPU 在访问内存时要由相关部件提供内存单元的段地址和偏移地址，送入地址加法器合成物理地址。这里，需要看一下，是什么部件提供段地址。段地址在 8086CPU 的段寄存器中存放。8086CPU 有 4 个段寄存器：CS、DS、SS、ES。

CS（Code Segment）：代码段寄存器

DS（Data Segment）：数据段寄存器

SS（Stack Segment）：堆栈寄存器

ES（Extra Segment）：附加段寄存器 OF

当 8086CPU 要访问内存时由这 4 个段寄存器提供内存单元的段地址。本章中只看一下 CS。



#### 2.10	CS 和 IP

CS（Code Segment）代码段寄存器和 IP（Instruction Pointer）指令指针寄存器是 8086CPU 中两个最关键的寄存器，它们指示了 CPU 当前要读取指令的地址。CS 为代码段寄存器，IP 为指令指针寄存器，从名称上我们可以看出它们和指令的关系。

在 8086PC 机中，任意时刻，设 CS 中的内容为 M，IP 中的内容为 N，8086CPU 将从内存 M✖16+N 单元开始，读取一条指令并执行。

也可以这样表述：8086 机中，任意时刻，CPU 将 CS:IP 指向的内容当作指令执行。

图太多了，略。

通过上面的过程展示，8086 CPU 的工作过程可以简要描述如下。

（1）从 CS:IP 指向的内存单元读取指令，读取的指令进入指令缓冲器；

（2）IP=IP+所读取指令的长度，从而指向下一条指令；

（3）执行指令。转到步骤（1），重复这个过程。

在 8086CPU 加电启动或复位后（即 CPU 刚开始工作时）CS 和 IP 被设置为 CS=FFFFH，IP=0000H，即在 8086PC 机刚启动时，CPU 从内存 FFFF0H 单元中读取指令执行。FFFF0H 单元中的指令是 8086PC 机开机后执行的第一条指令。

现在，我们更清楚了 CS 和 IP 的重要性，它们的内容提供了 CPU 要执行指令的地址。

我们在第 1 章中讲过，在内存中，指令和数据没有任何区别，都是二进制信息，CPU 在工作的时候把有的信息看作指令，有的信息看作数据。现在，如果提出一个问题：CPU 根据什么将内存中的信息看作指令？如何回答？我们可以说，CPU 将 CS:IP 指向的内存单元中的内容看作指令，因为，在任何时候，CPU 将 CS、IP 中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行。如果说，内存中的一段信息曾被 CPU 执行过的话，那么，它所在的内存单元必然被 CS:IP 指向过。 



#### 2.11	修改 CS、IP 的指令

在 CPU 中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对 CPU 的控制。CPU 从何处执行指令是由 CS、IP 中的内容决定的，程序员可以通过改变 CS、IP 中的内容来控制 CPU 执行目标指令。

8086CPU 大部分寄存器的值，都可以用 mov 指令来改变，mov 指令被称为传送指令。但是，mov 指令不能用于设置 CS、IP 的值，原因很简单，因为 8086CPU 没有提供这样的功能。8086CPU 为 CS、IP 提供了另外的指令来改变它们的值。能够改变 CS、IP 的内容的指令被统称为转移指令。我们现在介绍一个最简单的可以修改 CS、IP 的指令：jmp 指令。

若想同时修改 CS、IP 的内容，可用形如 “jmp 段地址：偏移地址” 的指令完成，如

jmp 2AE3:3，执行后：CS=2AE3H，IP=0003H，CPU 将从 2AE33H 处读取指令。

jmp 3:0B16，执行后：CS=0003H，IP=0B16H，CPU 将从 00B46H 处读取指令。

"jmp 段地址：偏移地址" 指令的功能为：用指令中给出的段地址修改 CS，偏移地址修改 IP。

若想仅修改 IP 的内容，可用形如 "jmp 某一合法寄存器" 的指令完成，如

jmp ax，指令执行前：ax=1000H，CS=2000H，IP=0003H

​				指令执行后：ax=1000H，CS=2000H，IP=1000H

jmp bx，指令执行前：bx=0B16H，CS=2000H，IP=0003H

​				指令执行后：bx=0B16H，CS=2000H，IP=0B16H

"jmp 某一合法寄存器" 指令的功能为：用寄存器中的值修改 IP。

jmp ax，在含义上好似：mov IP,ax。

注意，我们在适当的时候，会用已知的汇编指令的语法来描述新学的汇编指令的功能。采用一种 "用汇编解释汇编" 的方法来使读者更好地理解汇编指令的功能，这样做有助于读者进行知识的相互融会。要强调的是，我们是用 "已知的汇编指令的语法" 进行描述，并不是用 "已知的汇编指令" 来描述，比如，我们用 mov IP,ax 来描述 jmp ax，并不是说真有 mov IP,ax 这样的指令，而是用 mov 指令的语法来说明 jmp 指令的功能。我们可以用同样的方法描述 jmp 3:01B6 的功能：jmp 3:01B6 在含义上好似 mov CS,3  mov IP,01B6。



#### 2.12	代码段

前面讲过，对于 8086PC 机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为 N（N≤64KB）的一组代码，存放一组地址连续、起始地址为 16 的倍数的内存单元中，我们可以认为，这段内存是用来存放代码的，从而定义了一个代码段。

```assembly
mov ax,0000   (B8 00 00)
add ax,0123H  (05 23 01)
mov bx,ax     (8B D8)
jmp bx        (FF E3)
```



这段长度为 10 个字节的指令，存放在 123B0H~123B9H 的一组内存单元中，我们就可以认为，123B0H~123B9H 这段内存是用来存放代码的，是一个代码段，它的段地址为 123BH，长度为 10 个字节。

如何使得代码段中的指令被执行呢？将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU 并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。CPU 只认被 CS:IP 指向的内存单元中的内容为指令。所以，要让 CPU 执行我们放在代码段中的指令，必须要将 CS:IP 指向所定义的代码段中的第一条指令的首地址。如上面的例子，我们将一段代码存放在 123B0H~123B9H 内存单元中，将其定义为代码段，如果要让这段代码得到指向，可设 CS=123BH、IP=0000H。



#### 实验 1	查看 CPU 和内存，用机器指令和汇编指令编程

（1）什么是 Debug？

Debug 是 DOS、windows 都提供的实模式（8086 方式）程序的调试工具。使用它，可以查看 CPU 各种寄存器中的内容、内存的情况和在机器码级跟踪程序的运行。

（2）我们用到的 Debug 功能。

- 用 Debug 的 R 命令查看、改变 CPU 寄存器的内容；

- 用 Debug 的 D 命令查看内存中的内容；

- 用 Debug 的 E 命令改写内存中的内容；

- 用 Debug 的 U 命令将内存中的机器指令翻译成汇编指令；

- 用 Debug 的 T 命令执行一条机器指令；

- 用 Debug 的 A 命令以汇编指令的格式在内存中写入一条机器指令。

  

Debug 的命令比较多，共有 20 多个，但这 6 个命令是和汇编学习密切相关的。在以后的实验中，我们还会用到一个 P 命令。

（3）进入 Debug

高等级的 win10 系统不支持 Debug，需要下载安装 DOSBox。



（4）用 R 命令查看、改变 CPU 寄存器的内容。

（5）用 Debug 的 D 命令查看内存中的内容。

要查看内存 10000H 处的内容，首先将这个地址表示为段地址:偏移地址的格式，可以是 1000:0，然后用 “d 1000:0” 列出 1000:0 处的内容。

使用 "d 段地址:偏移地址" 的格式，Debug 将列出从指定内存单元开始的 128 个内存单元的内容。如图 2.34 所示，在使用 d 1000:0 后，Debug 列出了 1000:0~1000:7F 中的内容。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE16.jpg"/> </div><br>
1. 中间是从指定地址开始的 128 个内存的单元的内容，用十六进制的格式输出，每行的输出从 16 的整数倍的地址开始，最多输出 16 个单元的内容。
2. 左边是每行的起始地址。
3. 右边是每个内存单元中的数据对应的可显示的 ASCII 码字符。



在以进入 Debug 后，用 D 命令直接查看，将列出 Debug 预设的地址出处的内容。在使用 "d 段地址:偏移地址" 之后，接着使用 D 命令，可列出后续的内容。也可以指定 D 命令的查看范围，此时采用 "d 段地址:偏移地址 结尾偏移地址" 的格式。比如要看 1000:0~1000:9 中的内容，可以用 "d 1000:0 9" 实现。



（6）用 Debug 的 E 命令改写内存中的内容。

（7）用 E 命令向内存中写入机器码，用 U 命令查看内存中机器码的含义，用 T 命令执行内存中的机器码。

（8）用 Debug 的 A 命令以汇编指令的形式在内存中写入机器指令。







### 第 3 章	寄存器（内存访问）

第 2 章钟，我们主要从 CPU 如何执行指令的角度讲解了 8086CPU 的逻辑结构、形成物理地址的方法、相关的寄存器以及一些指令。这一章中，我们从访问内存的角度继续学习几个寄存器。



#### 3.1	内存中字的存储

CPU 中，用 16 位寄存器来存储一个字。高 8 位存放高位字节，低 8 位存放低位字节。在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元来存放，这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。

我们提出字单元的概念：字单元，即存放一个字型数（16 位）的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。

在以后的课程中，我们将起始地址为 N 的字单元简称为 N 地址字单元。比如一个子单元由 2、3 两个内存单元组成，则这个字单元的起使地址为 2，我们可以说这是 2 地址字单元。



#### 3.2	DS 和 [address]

CPU 要读写一个内存单元的时候，必须先给出这个内存单元的地址，在 8086PC 中，内存地址由段地址和偏移地址组成。8086CPU 中有一个 DS 寄存器，DS（Data Segment）：数据段寄存器，通常用来存放要访问数据的段地址。比如我们要读取 10000H 单元的内容，可以用如下的程序段进行。

```assembly
mov bx,1000H
mov ds,bx
mov al,[0]
```



上面的 3 条指令将 1000H(1000:0) 地址中的数据读到 a1 中。

下面详细说明指令的含义。

mov a1,[0]

前面我们使用 mov 指令，可完成两种传送：1.将数据直接送入寄存器；2.将一个寄存器中的内存送入另一个寄存器。

也可以使用 mov 指令将一个内存单元中的内容送入一个寄存器中。从哪一个内存单元送到哪一个寄存器中呢？在指令中必须指明。寄存器用寄存器名来指明，内存单元则需用内存单元的地址来指明。显然，此时 mov 指令的格式应该是：mov 寄存器名，内存单元地址。

[...] 表示一个内存的那样，[...] 中的 0 表示内存单元的偏移地址。我们知道，只有偏移地址是不能定位一个内存单元的，那么内存单元的段地址是多少呢？指令执行时，8086CPU 自动取 ds 中的数据为内存单元的段地址。

因为 8086CPU 不支持将数据直接送入段寄存器的操作，ds 是一个段寄存器，所以 mov ds,1000H 这条指令是非法的。那么如何将 1000H 送入 ds 呢？只好用一个寄存器来进行中转，即先将 1000H 送入一个一般的寄存器，如 bx，再将 bx 中的内容送入 ds。





### 3.3	字 的 传 送

前面我们用 mov 指令在寄存器和内存之间进行字节型数据的传送。因为 8086CPU 是 16 位结构，有 16 根数据线，所以，可以一次性传送 16 位的数据，也就是说可以一次性传送一个字。只要在 mov 指令中给出 16 位的寄存器就可以进行 16 位数据的传送了。比如：

```assembly
mov bx,1000H
mov ds,bx
mov ax,[0]	;1000:0 处的字型数据送入 ax
mov [0],cx  ;cs 中的 16 位数据送到 1000:0 处
```



#### 3.4	mov、add、sub 指令

前面我们用到了 mov、add、sub 指令，它们都带有两个操作对象。

到现在，我们知道，mov 指令可以有以下几种形式。

mov	寄存器，数据			比如：mov ax,8

mov	寄存器，寄存器		比如：mov ax,bx

mov	寄存器，内存单元    比如：mov ax,[0]

mov	内存单元，寄存器	比如：mov [0],ax

mov	段寄存器，寄存器	比如：mov ds,ax

我们可以根据这些已知指令进行下面的推测。

（1）既然有 “mov 段寄存器，寄存器”，那么也该有 "mov 寄存器，段寄存器"。

（2）既然有 “mov 内存单元，寄存器”，那么也该有 "mov 内存单元，段寄存器"

（3）“mov 段寄存器，内存单元” 也应该可行。



add 和 sub 指令同 mov 一样，都有两个操作对象。它们也可以有以下几种形式。

add  寄存器，数据          	 比如：add ax,8

add  寄存器，寄存器           比如：add ax,bx 

add  寄存器，内存单元       比如：add ax,[0] 

add  内存单元，寄存器       比如：add [0],ax 

sub  寄存器，数据               比如：sub ax,9 

sub  寄存器，寄存器           比如：sub ax,bx 

sub  寄存器，内存单元       比如：sub ax,[0] 

sub  内存单元，寄存器       比如：sub [0],ax



#### 3.5	数 据 段

前面讲过（参见 2.8 节）。对于 8086PC 机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将一组长度为 N（N≤64KB）、地址连续、起始地址为 16 的倍数的内存单元当作专门存储数据的内存单元，从而定义了一个数据段。比如用 123B0H~123B9H 这段内存空间来存放数据，我们就可以认为，123B0H~123B9H 这段内存是一个数据段，它的段地址为 123BH，长度为 10 个字节。

如何访问数据段中的数据呢？将一段内存当作数据段，是我们在编程时的一种安排，可以在具体操作的时候，用 ds 存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。

比如，将 123B0H~123B9H 的内存单元定义为数据段。现在要累加这个数据段中的前 3 个单元中的数据，代码如下。

```assembly
mov ax,123BH
mov ds,ax		;将 123BH 送入 ds 中，作为数据段的段地址
mov al,0		;用 al 存放累加结果
add al,[0]		;将数据段第一个单元{偏移地址为 0}中的数值加到 al 中
add al,[1]		;将数据段第二个单元{偏移地址为 1}中的数值加到 al 中
add al,[2]		;将数据段第三个单元{偏移地址为 2}中的数值加到 al 中
```



#### 3.1~3.5	小	结

（1）字再内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。

（2）用 mov 指令访问内存单元，可以在 mov 指令中只给出单元的偏移地址，此时，段地址默认在 DS 寄存器中。

（3）[address] 表示一个偏移地址为 address 的内存单元。

（4）在内存和寄存器之间传送字型数据时，高地址单元和高 8 位寄存器、低地址单元和低 8 位寄存器相对应。

（5）mov、add、sub 是具有两个操作对象的指令。jmp 是具有一个操作对象的指令。

（6）可以根据自己的推测，在 Debug 中实验指令的新格式。





#### 3.6	栈

在这里，我们对栈的研究仅限于这个角度：栈是一种具有特殊的访问方式的存储空间。它的特殊性就在于，最后进入这个空间的数据，最先出去。

从程序化的角度来讲，应该有一个标记，这个标记一直指示着栈顶的元素。

栈有两个基本的操作：入栈和出栈。入栈就是将要给新的元素放到栈顶，出栈就是从栈顶取出一个元素。栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。栈的这种操作被称为LIFO（Last In First Out，后进先出）。



#### 3.7	CPU 提供的栈机制

现今的 CPU 中都有栈的设计，8086CPU 也不例外。8086CPU 提供相关的指令来以栈的方式访问内存空间。这意味着。在基于 8086CPU 编程的时候，可以将一段内存当作栈来使用。

8086CPU 提供入栈和出栈指令，最基本的两个是 PUSH（入栈）和 POP（出栈）。比如，push ax 表示将寄存器 ax 中的数据送入栈中，pop ax 表示从栈顶取出数据送入 ax。8086CPU 的入栈和出栈操作都是以字为单位进行的。

下面举例说明，我们可以将 10000H~1000FH 这段内存当作栈来使用。

图 3.9 描述了下面一段指令的执行过程。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE17.jpg"/> </div><br>
```assembly
mov ax,0123H
push ax
mov bx,2266H
push bx
mov cx,1122H
push cx
pop ax
pop bx
pop cx
```



注意，字型数据用两个单元存放，高地址存放高 8 位，低地址单元存放低 8 位。

读者看到图 3.9 所描述的 push 和 pop 指令的执行过程，是否有一些疑惑？总结一下，大概是这两个问题。

第一，我们将 10000H~1000FH 这段内存当作栈来使用，CPU 执行 push 和 pop 指令时，将对这段空间按照栈的后进先出的规则进行访问。但是，一个重要的问题是，CPU 如何知道 10000H~1000FH 这段空间被当作栈来使用？

第二，push ax 等入栈指令执行时，要将寄存器中的内容放入当前栈顶单元的上方，成为新的栈顶元素；pop ax 等指令执行时，要从栈顶单元中取出数据，送入寄存器中。显然，push、pop 在执行的时候，必须知道哪个单元是栈顶单元，可是，如何知道呢？

这不禁让我们想起另外一个讨论过的问题，就是，CPU 如何知道当前要执行的指令所在的位置？我们现在知道答案，那就是 CS、IP 中存放着当前指令的段地址和偏移地址。现在的问题是：CPU 如何知道栈顶的位置？显然，也应该有相应的寄存器来存放栈顶的地址，8086CPU 中，有两个寄存器，段寄存器 SS 和寄存器 SP，SS（Stack Segment）：堆栈寄存器，SP（Stack Pointer）：堆栈指针寄存器，栈顶的段地址存放在 SS 中，偏移地址存放在 SP 中。**任意时刻，SS:SP 指向栈顶元素**。push 指令和 pop 指令执行时，CPU 从 SS 和 SP 中得到栈顶的地址。

现在，我们可以完整地描述 push 和 pop 指令的功能了，例如 push ax。

push ax 的执行，由以下两步完成。

（1）SP=SP-2，SS:SP 指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；

（2）将 ax 中的内容送入 SS:SP 指向的内存单元处，SS:SP 此时指向新栈顶。

图 3.10 描述了 8086CPU 对 push 指令的执行过程。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE18.jpg"/> </div><br>
从图中我们可以看出，8086CPU 中，入栈时，栈顶从高地址向低地址方向增长。

接下来，我们描述 pop 指令的功能，例如 pop ax。

pop ax 的执行过程和 push ax 刚好相反，由以下两步完成。

（1）将 SS:SP 指向的内存单元处的数据送入 ax 中；

（2）SP=SP+2，SS:SP 指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。

图 3.12 描述了 8086CPU 对 pop 指令的执行过程。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE19.jpg"/> </div><br>
注意，图 3.12 中，出栈后，SS:SP 指向新的栈顶 1000EH，pop 操作前的栈顶元素，1000CH 处的 2266H 依然存在，但是，它已不在栈中。当再次执行 push 等入栈指令后，SS:SP 移至 1000CH，并在里面写入新的数据，它将被覆盖。





#### 3.8	栈顶超界的问题

我们现在知道，8086CPU 用 SS 和 SP 指示栈顶的地址，并提供 push 和 pop 指令实现入栈和出栈。

但是，还有一个问题需要讨论，就是 SS 和 SP 只是记录了栈顶的地址，依靠 SS 和 SP 可以保证在入栈和出栈时找到栈顶。可是，如何能够保证在入栈、出栈时，栈顶不会超出栈空间？

图 3.13 描述了在执行 push 指令后，栈顶超出栈空间的情况。图 3.14 描述了在执行 pop 指令后，栈顶超出栈空间的情况。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE20.jpg"/> </div><br>
上面描述了执行 push、pop 指令时，发生的栈顶超界问题。可以看到，当栈满的时候再使用 push 指令入栈，或栈空的时候再使用 pop 指令出栈，都将发生栈顶超界问题。

栈顶超界是最危险的，因为我们既然将一段空间安排为栈，那么在栈空间之外的空间里很可能存放了具有其他用途的数据、代码等，这些数据、代码可能是我们自己程序中的，也可能是别的程序中的（毕竟一个计算机系统中并不是只有我们自己的程序在运行）。但是由于我们在入栈出栈时的不小心，而将这些数据、代码意外地改写，将会引发一连串的错误。

我们当然希望 CPU 可以帮我们解决这个问题，比如说在 CPU 中有记录栈顶上限和栈底的寄存器，我们可以通过填写这些寄存器来指定栈空间的范围，然后，CPU 在执行 push 指令的时候靠检测栈顶上限寄存器、在执行 pop 指令的时候靠检测栈底寄存器保证不会超界。

不过，对于 8086CPU，这只是我们的一个设想（我们当然可以这样设想，如果 CPU 是我们设计的话，这也就不仅仅是一个设想）。实际的情况是，8086CPU 中并没有这样的寄存器。

8086CPU 不保证我们对栈的操作不会超界。这也就是说，8086CPU 只知道栈顶在何处（由 SS:SP 指示），而不知道我们安排的栈空间有多大。这点就好像 CPU 只知道当前要执行的指令在何处（由 CS:IP 指示），而不知道要执行的指令有多少。从这两点上我们可以看出 8086CPU 的工作机理，它只考虑当前的情况：当前的栈顶在何处、当前要执行的指令是哪一条。

我们在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安排栈的大小，防止入栈的数据太多而导致的超界；执行出栈操作的时候也要注意，以防栈空的时候继续出栈而导致的超界。



#### 3.9	push、pop 指令

前面我们一直在使用 push ax 和 pop ax，显然 push 和 pop 指令是可以在寄存器和内存（栈空间当然也是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间。）之间传送数据的。

push 和 pop 指令的格式可以是如下形式：

```assembly
push	寄存器		;将一个寄存器中的数据入栈
pop		寄存器		;出栈，用一个寄存器接收出栈的数据
```



当然也可以是如下形式：

```assembly
push	段寄存器	;将一个段寄存器中的数据入栈
pop		段寄存器	;出栈，用一个段寄存器接收出栈的数据
```



push 和 pop 也可以在内存单元和内存单元之间传送数据，我们可以：

```assembly
push	内存单元	 ;将一个内存字单元处的字入栈（注意：栈操作都是以字为单位）
pop		内存单元  	 ;出栈，用一个内存字单元接收出栈的数据
```



比如：

```assembly
mov ax,1000H
mov ds,ax		;内存单元的段地址要放在 ds 中
push [0]		;将 1000:0 处的字压入栈中
pop	 [2]		;出栈，出栈的数据送入 1000:2 处
```



指令执行时，CPU 要知道内存单元的地址，可以在 push、pop 指令中只给出内存单元的偏移地址，段地址在指令执行时，CPU 从 ds 中取得。

与 CS 一样，SS 不能直接通过 mov 传送数据，需要通过寄存器中转；但是与 IP 不一样，SP 可以直接用 mov 传送数据。

用栈来暂存以后需要恢复的寄存器中的内容时，出栈的顺序和入栈的顺序相反，因为最后入栈的寄存器的内容在栈顶，所以在恢复时，要最先出栈。

push、pop 指令实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，与 mov 指令不同的是，push 和 pop 指令访问的内存单元的地址不是在指令中给出的，而是由 SS:SP 指出的。同时，push 和 pop 指令还要改变 SP 中的内容。

我们要十分清楚的是，push 和 pop 指令同 mov 指令不同，CPU 执行 mov 指令只需一步操作，就是传送，而执行 push、pop 指令却需要两步操作。执行 push 时，CPU 的两步操作是：先改变 SP，后向 SS:SP 处传送。执行 pop 时，CPU 的两步操作是：先读取 SS:SP 处的数据，后改变 SP。

注意，push，pop 等栈操作指令，修改的只是 SP。也就是说，栈顶的变化范围最大为：0~FFFFH。

提供：SS、SP 指示栈顶：改变 SP 后写内存的入栈ss指令；读内存后改变 SP 的出栈指令。这就是 8086CPU 提供的栈操作机制。



#### 栈 的 综 述

（1）8086CPU 提供了栈操作机制，方案如下。

在 SS、SP 中存放栈顶的段地址和偏移地址；

提供入栈和出栈指令，它们根据 SS:SP 指示的地址，按照栈的方式访问内存单元。

（2）push 指令的执行步骤：1.SP=SP-2；2.向 SS:SP 指向的字单元中传入数据。

（3）pop 指令的执行步骤：1.从 SS:SP 指向的字单元中读取数据；2.SP=SP+2。

（4）任意时刻，SS:SP 指向栈顶元素。

（5）8086CPU 只记录栈顶，栈空间的大小我们要自己管理。

（6）用栈来暂存以后需要恢复的寄存器的内容时，寄存器出栈的顺序要和入栈的顺序相反。

（7）push、pop 实质上是一种内存传送指令，注意它们的灵活应用。

栈是一种非常重要的机制，一定要深入理解，灵活掌握。





#### 3.10	栈	段

前面讲过（参见 2.8 节），对于 8086PC 机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为 N(N≤64KB，2^16^) 的一组地址连续、起始地址为 16 的倍数的内存单元，当作栈空间来用，从而定义了一个栈段。比如，我们将 10010H~1001FH 这段长度为 16 字节的内存空间当作栈来用，以栈的方式进行访问。这段空间就可以称为一个栈段，段地址为 1001H，大小为 16 字节。

将一段内存当作栈段，仅仅是我们在编程时的一种安排，CPU 并不会由于这种安排，就在执行 push、pop 等栈操作指令时自动地将我们定义的栈段当作栈空间来访问。如何使得如 push、pop 等栈操作指令访问我们定义的栈段呢？前面我们已经讨论过，就是要将 SS:SP 指向我们定义的栈段。



#### 问题	3.11

如果将 1000H~1FFFFH 这段空间当作栈段，初始这条栈是空的，此时，SS=1000H，SP=？

分析：

1.【1000H~1FFFFH 这段空间当作栈】

栈满时，栈顶标记指向 1000H。

栈为空的话，栈顶标记指向 1FFFFH+2=20000H

2.【初始状态是空的】

栈顶标记指向 20000H，SS=1000H，SP 肯定等于 0000H。因为栈顶的变化范围是：0~FFFFH。



#### 问题	3.12

一个栈段最大可以设为多少？为什么？

分析：这个问题显而易见，提出来只是为了提示我们将相关的知识融会起来。首先从栈操作指令所完成的功能的角度上来看，push、pop 等指令在执行的时候只修改 SP，所以栈顶的变化范围是 0~FFFFH，从栈空时候的 SP=0，一直压栈，直到栈满时 SP=0；如果再次压栈，栈顶将环绕，覆盖了原来栈中的内容。所以一个栈段的容量最大为 64KB。



#### 段 的 综 述

我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排。

我们可以用一个段存放数据，将它定义为 “数据段”。

我们可以用一个段存放代码，将它定义为 “代码段”。

我们可以用一个段当作栈，将它定义为 “栈段”。

我们可以这样安排，但若要让 CPU 按照我们的安排来访问这些段，就要：

对于数据段，将它的段地址放在 DS 中，用 mov、add、sub 等访问内存单元的指令时，CPU 就将我们定义的数据段中的内容当作数据来访问。

对于代码段，将它的段地址放在 CS 中，将段中的第一条指令的偏移地址放在 IP 中，这样CPU 就将执行我们定义的代码段中的指令。

对于栈段，将它的地址放在 SS 中，将栈顶单元的偏移地址放在 SP 中，这样 CPU 在需要进行栈操作的时候，比如执行 push、pop 指令等，就将我们定义的栈段当作栈空间来用。

可见，不管我们如何安排，CPU 将内存中的某段代码当作代码，是因 CS:IP 指向了哪里；CPU 将某段内容当作栈，是因为 SS:SP 指向了哪里。我们一定要清楚，什么是我们的安排，以及如何让 CPU 按我们的安排行事。要非常清楚 CPU 的工作机理，才能在控制 CPU 按照我们的安排运行的时候做到游刃有余。

比如我们将 10000H~1001FH 安排为代码段，并在里面存储如下代码：

```assembly
mov ax,1000H
mov ss,ax
mov sp,0029H	;初始化栈顶
mov ax,cs		
mov ds,ax		;设置数据段地址
mov ax,[0]
add ax,[2]
mov bx,[4]
add bx,[6]
push ax
push bx
pop ax
pop bx
```



设置 CS=1000H，IP=0，这段代码将得到执行。可以看到，在这段代码中，我们又将 10000H~1001FH 安排为栈段和数据段。10000H~1001FH 这段内存，既是代码段，又是栈段和数据段。

一段内存，可以既是代码的存储空间，又是数据的存储空间，还可以是栈空间，也可以什么也不是。关键在于 CPU 中寄存器的设置，即 CS、IP，SS、SP，DS 的指向。





#### 实验 2	用机器指令和汇编指令编程

**1.预备知识：Debug 的使用**

前面实验中，讲了 Debug 的一些主要命令的用法，这里，再补充一些关于 Debug 的知识。

（1）关于 D 命令。

从上次实验中，我们知道，D 命令是查看内存单元的命令，可以用：

“d 段地址:偏移地址” 的格式查看指定的内存单元的内容，上次实验中，D 命令后面的段地址和偏移地址都是直接给出的。

现在，我们知道段地址是放在段寄存器中的，在 D 命令后面直接给出段地址，是 Debug 提供的一种直观的操作方式。D 命令是由 Debug 执行的，Debug 在执行 “d 1000:0” 这样的命令时，也会先将段地址 1000H 送入段寄存器中。

Debug 是靠什么来执行 D 命令的？当然是一段程序。

谁来执行这段程序？当然是 CPU。

CPU 在访问内存单元的时候从哪里得到内存单元的段地址？从段寄存器中得到。

所以，Debug 在其处理 D 命令的程序段中，必须有将段地址送入段寄存器的代码。

段寄存器有 4 个：CS、DS、SS、ES，将段地址送入哪个段寄存器呢？

首先不能是 CS，因为 CS:IP 必须指向 Debug 处理 D 命令的代码，也不能是 SS，因为 SS:SP 要指向栈顶。这样只剩下了 DS 和 ES 可以选择，放在哪里呢？我们知道，访问内存的指令如 "mov ax,[0]" 等一般都默认段地址在 ds 中，所以 Debug 在执行如 "d 段地址:偏移地址" 这种 D 命令时，将段地址送入 ds 中比较方便。

D 命令也提供了一种符合 CPU 机理的格式：“d 段寄存器:偏移地址”，以段寄存器中的数据为段地址 SA，列出从 SA:偏移地址开始的内存区间中的数据。以下是几个例子。

```assembly
-r ds
:1000
-d ds:0			;查看从 1000:0 开始的内存区间中的内容

-r ds
:1000
-d ds:10 18		;查看 1000:10~1000:18 中的内容

-d cs:0			;查看当前代码段中的指令代码
-d ss:0			;查看当前栈段中的内容
```



（2）在 E、A、U 命令中使用段寄存器。

在 E、A、U 这些可以带有内存单元地址的命令中，也可以同 D 命令一样，用段寄存器表示内存单元的段地址，以下是几个例子。

```assembly
-r ds
:1000
-e ds:0 11 22 33 44 55 66	;在从 1000:0 开始的内存区间中写入数据

-u cs:0						;以汇编指令的形式，显示当前代码段中的代码，0 代码的偏移地址

-r ds
:1000
-a ds:0						;以汇编指令的形式，向从 1000:0 开始的内存的那样中写入指令
```



（3）下一条指令执行了吗

在 Debug 中，用 A 命令写一段程序：

```assembly
mov ax,2000
mov ss,ax
mov sp,10		;安排 2000:0000~2000:000F 为栈空间，初始化栈顶

mov ax,3123
push ax
mov ax,3366
push ax			;在栈中压入两个数据
```



仔细看一下图 3.18 中单步执行的结果，你发现了什么问题？

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE21.jpg"/> </div><br>
在用 T 命令单步执行 mov ax,2000 后，显示出当前 CPU 各个寄存器的状态和下一步要执行的指令：mov ss,ax；

在用 T 命令单步执行 mov ss,ax 后，显示出当前 CPU 各个寄存器的状态和下一步要执行的指令……，在这里我们发现了一个问题：mov ss,ax 的下一条指令应该是 mov sp,10，怎么变成了 mov ax,3123？

mov sp,10 到哪里去了？它被执行了吗？

我们再仔细观察，发现：

在程序执行前，ax=0000，ss=0b39，sp=ffee

在用 T 命令单步执行 mov ax,2000 后，ax=2000；ss=0b39；sp=ffee

在用 T 命令单步执行 mov ss,ax 后，ax=2000；ss=2000；sp=0010

注意，在用 T 命令单步执行 mov ss,ax 前，ss=0b39，sp=ffee，而执行后 ss=2000，sp=0010。
ss 变为 2000 是正常的，这正是 mov ss,ax 的执行结果。可是 sp 变为 0010 是怎么回事？在这期间，能够将 sp 设为 0010 的只有指令 mov sp,10，看来，mov sp,10 一定是得到了执行。

那么，mov sp,10 是在什么时候被执行的呢？当然是在 mov ss,ax 之后，因为它就是 mov ss,ax 的下一条指令。显然，在用 T 命令执行 mov ss,ax 的时候，它的下一条指令 mov sp,10 也紧接着执行了。

整理一下我们分析的结果：在用 T 命令执行 mov ss,ax 的时候，它的下一条指令 mov sp,10 也紧接着执行了。一般情况下，用 T ml执行一条指令后，会停止继续执行，显示出当前 CPU 各个寄存器的状态和下一步要执行的指令，但 T 命令执行 mov ss,ax 的时候，没有做到这一点。

不单是 mov ss,ax，对于如 mov ss,bx，mov ss,[0]，pop ss 等指令都会发生上面的情况，这些指令有哪些共性呢？它们都是修改栈段寄存器 SS 的指令。

为什么会这样呢？要想彻底说清楚这里面的来龙去脉，在这里还为时过早，因为这涉及我们在以后的课程中要深入研究的内容：中断机制，它是我们后半部分课程的一个主要主题。现在我们只要知道这一点就可以了：Debug 的 T 命令在执行修改寄存器 SS 的指令时，下一条指令也紧接着被执行。





### 第 4 章	第一个程序

终于可以编写第 1 个完整的程序了，我们以前都是在 Debug 中写一些指令，在 Debug 中执行。现在我们将开始编写完整的汇编语言程序，用编译和连接程序将它们编译连接成为可执行文件（如 *.exe 文件），在操作系统中运行。这一章中，我们将编写第一个这样的程序。为了能够透彻地理解一个完整的程序（尽管它看上去十分简单），我们将经历一个漫长的过程。



#### 4.1	一个源程序从写出到执行的过程

图 4.1 描述了一个汇编语言程序从写出到最终执行的简要过程。具体说明如下。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE22.jpg"/> </div><br>
第一步：编写汇编源程序。

使用文本编辑器，用汇编语言编写汇编程序。

这一步工作的结果是产生了一个存储源程序的文本文件。

第二步：对源程序进行编译连接。

使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件；再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件。

可执行文件包含两部分内容。

- 程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）
- 相关的描述信息（比如，程序有多大、要占用多少内存空间等）

这一步工作的结果：产生了一个可在操作系统中运行的可执行文件。

第三步：执行可执行文件中的程序。

在操作系统中，执行可执行文件中的程序。

操作系统按照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如蛇者 CS:IP 指向第一条要执行的指令），然后由 CPU 执行程序。

下面我们将通过学习一个简单的程序来经历图 4.1 中所描述的过程。



#### 4.2	源	程	序

下面就是一段简单的汇编语言源程序。

**程序	4.1**

```assembly
assume cs:codesg
codesg segment
		mov ax,0123H
		mov bx,0456H
		add ax,bx
		add ax,ax
		
		mov ax,4c00H
		int 21H
		
codesg ends
end
```



下面对程序进行说明。

**1.伪指令**

在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为 CPU 所执行。而伪指令没有对应的机器指令，最终不被 CPU 所执行。那么谁来执行伪指令呢？伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。

程序 4.1 中出现了 3 种伪指令。

（1）XXX segment

​		  ...

​		  XXX ends

segment 和 ends 是一对成对使用的伪指令，这是在写可变编译器编译的汇编程序时，必须要用到的一对伪指令。segment 和 ends 的功能是定义一个段，segment 说明一个段开始，ends 说明一个段结束。一个段必须有一个名称来标识，使用格式为：

段名 segment

...

段名 ends



比如，程序 4.1 中的：

codesg segment	；定义一个段，段的名称为 "codesg"，这个段从此开始

..

codesg ends			;名称为 "codesg" 的段到此结束

一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。我们在前面的课程中所讲解的段的概念，在汇编源程序中得到了应用与体现，一个源程序中所有将被计算机所处理的信息：指令、数据、栈，被划分到了不同的段中。

一个有意义的汇编程序中至少要有一个段，这个段用来存放代码。

我们可以看到，程序 4.1 中，在 codesg segment 和 codesg ends 之间写的汇编指令是这个段中存放的内容，这是一个代码段（其中还有我们不认识的指令，后面会进行讲解）。



（2）end

end 是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，如果碰到了伪指令 end，就结束对源程序的编译。所以，在我们写程序的时候，如果程序写完了，要在结尾处加上伪指令 end。否则，编译器在编译程序时，无法知道程序在何处结束。

注意，不要搞混了 end 和 ends，ends 是和 segment 成对使用的，标记一个段的结束，ends 的含义可理解为 “end segment”。我们这里讲的 end 的作用是标记整个程序的结束。



（3）assume

这条伪指令的含义为 “假设”。它假设某一段寄存器和程序中的某一个用 segment..ends 定义的段相关联。通过 assume 说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。assume 并不是一条非要深入理解不可的伪指令，以后我们编程时，记着用 assume 将有特定用途的段和相关的段寄存器关联起来即可。

比如，在程序 4.1 中，我们用 codesg segment ... codesg ends 定义了一个名为 codesg 的段，在这个段中存放代码，所以这个段是一个代码段。在程序的开头，用 assume cs:codesg 将用作代码段的段 codesg 和 CPU 中的段寄存器 cs 联系起来。



**2.源程序中的程序**

用汇编语言写的源程序，包括伪指令和汇编指令，我们编程的最终目的是让计算机完成一定的任务。源程序中的汇编指令组成了最终由计算机执行的程序，而源程序中的伪指令是由编译器来处理的，它们并不实现我们编程的最终目的。这里所说的程序就是值源程序中最终由计算机来执行、处理的指令或数据。

注意，以后可以将源程序文件中得所有内容称为源程序，将源程序中最终由计算机执行、处理的指令或数据，称为程序。程序最先以汇编指令得形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中。这个过程如图 4.2 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE23.jpg"/> </div><br>
**3.标号**

汇编源程序中，除了汇编指令和伪指令外，还有一些标号，比如 “codesg”。一个标号指代了一个地址。比如 codesg 在 segment 的前面，作为一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。



**4.程序的结构**

我们现在讨论一下汇编程序的结构。在前 3 章中，我们都是通过直接在 Debug 中写入汇编指令来写汇编程序，对于十分简短的程序这样做的确方便。可对于大一些的程序，就不能如此了。我们需要写出能让编译器进行编译的源程序，这样的源程序应该聚呗起码的结构。

源程序是一些段构成的。我们可以在这些段中存放代码、数据、或将某个段当作栈空间。我们现在来一步步地完成一个小程序，从这个过程中体会一下汇编程序中的基本要素和汇编程序的简单框架。

任务：编程运算 2^3。源程序应该怎样来写呢？

（1）我们要定义一个段，名称为 abc。

```assembly
abc segment

..

abc ends
```



（2）在这个段中写入汇编指令，来实现我们的任务。

```assembly
abc segment
 mov ax,2
 add ax,ax
 add ax,ax
abc ends
```



（3）然后，要指出程序在何处结束。

```assembly
abc segment
 mov ax,2
 add ax,ax
 add ax,ax
abc ends 

end
```



（4）abc 被当作代码段来用，所以，应该将 abc 和 cs 联系起来。（当然，对于这个程序，也不是非这样做不可。）

```assembly
assume cs:abc

abc segment
 mov ax,2
 add ax,ax
 add ax,ax
abc ends 

end
```



最终写成的程序如程序 4.2 所示。

**程序 4.2**

```assembly
assume cs:abc

abc segment
 mov ax,2
 add ax,ax
 add ax,ax
abc ends 

end
```



**5.程序返回**

我们的程序最先以汇编指令的形式存在源程序中，经编译、连接后转变为机器码，存储在可执行文件中，那么，它怎样得到运行呢？

下面我们在 DOS（一个单任务操作系统）的基础上，简单地讨论一下这个问题。

一个程序 P2 在可执行文件中，则必须有一个正在运行地程序 P1，将 P2 从可执行文件中加载入内存后，将 CPU 的控制权交给 P2，P2 才能得以运行。P2 开始运行后，P1 暂停运行。

而当 P2 运行完毕后，应该将 CPU 的控制权交还给使它得以运行的程序 P1，此后，P1 继续运行。

现在，我们知道，一个程序结束后，将 CPU 的控制权交还给使它得以运行的程序，我们称这个过程为：**程序返回**。那么，如何返回呢？应该在程序的末尾添加返回的程序段。

我们回过头来，看一下程序 4.1 中的两条指令：

```assembly
mov ax,4c00H
int 21H
```



这两条指令所实现的功能就是程序返回。

在目前阶段，我们不必去理解 int 21H 指令的含义，和为什么要在这条指令的前面加上指令 mov ax,4c00H。我们只要知道，在程序的末尾使用这两条指令就可以实现程序返回。

到目前为止，我们好像已经遇到了几个和结束相关的内容：段结束、程序结束、程序返回。表 4.1 展示了它们的区别。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE24.png"/> </div><br>
**6.语法错误和逻辑错误**

可见，程序 4.2 在运行时会引发一些问题，因为程序没有返回。当然，这个错误在编译的时候是不能表现出来的，也就是说，程序 4.2 对于编译器来说是正确的程序。

一般说来，程序在编译时被编译器发现的错误是语法错误。

在源程序编译后，在运行时发生的错误是逻辑错误。语法错误容易发现，也容易解决。而逻辑错误通常不容易被发现。





#### 4.3	编辑源程序

可以用任意的文本编辑器来编辑源程序，只要最终将其存储为纯文本文件即可。在我们的课程中，使用 DOS 下的 Edit。以程序 4.1 为例，说明工作过程。

（1）进入 dosbox，运行 Edit。

（2）在 Edit 中编辑程序，如下所示：

```assembly
assume cs:codesg
codesg segment
	mov ax,0124h
	mov bx,0456h
	add ax,bx
	add ax,ax
	
	mov ax,4c00h
	int 21h

codesg ends
ends
```



（3）将程序保存为文件 c:\1.asm 后，退出 Edit，结束对源程序的编辑。



#### 4.4	编	译

在前一节中，完成对源程序的编辑后，得到一个源程序文件。可以对其进行编译，生成包含机器代码的目标文件。

在编译一个源程序之前首先要找到一个相应的编译器。在我们的课程中，采用微软的 masm5.0 汇编编译器，文件名为 masm.exe。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE25.jpg"/> </div><br>
图 4.5 中，运行 masm 后，首先显示出一些版本信息，然后提示输入将要被扁你的源程序文件的名称。注意，“[.ASM]” 提示我们，默认的文件扩展名是 asm，比如，要编译的源程序文件名是 “p1.asm”，只要在这里输入 “p1” 即可。可如果源程序文件不是以 asm 为扩展名的话，就要输入它的全名。比如源程序文件名为 “p1.txt”，就要输入全名。

在输入源程序文件名的时候一定要指明它所在的路径。如果文件就在当前路径下，只输入文件名就可以，可如果文件在其他的目录中，则要输入路径，比如，要编译的文件 p1.txt 在 “c:\” 下，则要输入 “c:\p1.txt”。

这里，我们要编译的文件是 C 盘根目录下的 1.asm，所以此处输入 “c:\1.asm”。



（2）输入要编译的源程序文件名后，按 Enter 键，屏幕显示如图 4.6 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE26.jpg"/> </div><br>
图 4.6 中，在输入源程序文件名后，程序继续提示我们输入要编译出的目标文件的名称，目标文件是我们对一个源程序继续编译要得到的最终结果。因为我们已经输入了源程序文件名为 1.asm，编译程序已经默认要输出的目标文件名为 1.obj，所以可以不必再另行指定文件名。直接按 Enter 键，编译程序将在当前的目录下，生成 1.obj 文件。

这里，也可以指定生成的目标文件所在的目录，比如，想让编译程序在 “c:\windows\desktop” 下生成目标文件 1.obj，则可输入 “c:\windows\desktop\1”。

我们直接按 Enter 键，使用编译程序设定的目标文件名。



（3）确定了目标文件的名称后，屏幕显示如图 4.7 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE27.jpg"/> </div><br>
图 4.7 中，编译程序提示输入列表文件的名称，这个文件是编译器将源程序编译为目标文件的过程中产生的中间结果，可以让编译器不生成这个文件，直接按 Enter 键即可。



（4）忽略了列表文件的生成后，屏幕显示如图 4.8 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE28.jpg"/> </div><br>
图 4.8 中，编译程序提示输入交叉引用文件的名称，这个文件同列表文件一样，是编译器将源程序编译为目标文件过程中产生的中间结果。可以让编译器不生产这个文件，直接按 Enter 键即可。



（5）忽略了交叉引用文件的生成后，屏幕显示如图 4.9 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE29.jpg"/> </div><br>
图 4.9 中，对源程序的编译结束，编译器输出的最后两行告诉我们这个源程序没有警告错误和必须要改正的错误。

上面我们通过对 C 盘根目录下的 1.asm 进行编译的过程，展示了使用汇编编译器对源程序进行编译的方法。按照上面的过程就行了编译之后，在编译器 masm.exe 运行的目录 c:\masm 下，将出现一个新的文件：1.obj，这是对源程序 1.asm 进行编译所得到的结果。当然，如果编译得过程中出现错误，那么将得不到目标文件。一般来说，有两类错误使我们得不到所期望的目标文件：

（1）程序中有 “Severe Errors”；

（2）找不到所给出的源程序文件。

注意，在编译的过程中，我们提供了一个输入，即源程序文件。最多可以得到 3 个输出：目标文件（.obj）、列表文件（.lst）、交叉引用文件（.crf），这 3 个输出文件中，目标文件是我们最终要得到的结果，而另外两个只是中间结果，可以让编译器忽略对它们的生成。在汇编课程中，我们不讨论这两类文件。



#### 4.5	连	接

在对源程序进行编译得到目标文件后，我们需要对目标文件进行连接，从而得到可执行文件。持续上一节的过程，我们已经对 c:\1.asm 进行编译得到 c:\1.obj，现在再将 c:\1.obj 连接为 c:\1.exe。

我们使用微软的 Overlay linker3.60 连接器，文件名为 link.exe.

生成执行文件的过程与上面类似。

（3）确定了可执行文件的名称后，屏幕显示如图 4.12 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE30.jpg"/> </div><br>
图 4.12 中，连接持续提示输入映像文件的名称，这个文件是连接程序将目标文件连接为可执行文件过程中产生的中间结果，可以让连接程序不生产这个文件，直接按 Enter 键即可。



（4）忽略了映像文件的生成后，屏幕显示如图 4.13 所示。

图 4.13 中，连接程序提示输入库文件的名称。库文件里面包含了一些可以调用的子程序，如果程序中调用了某一个库文件中的子程序，就需要在连接的时候，将这个库文件和目标文件连接到一起，生成可执行文件。但是，这个程序中没有调用任何子程序，所以，这里忽略库文件名的输入，直接按 Enter 键即可。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE31.jpg"/> </div><br>
（5）忽略了库文件的连接后，屏幕显示如图 4.14 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE32.jpg"/> </div><br>
图 4.14 中，对目标文件的连接结束，连接程序输出的最后一行告诉我们，这个程序中有一个警告错误：“没有栈段”，这里我们不理会这个错误。

上面我们通过对当前路径下的 1.obj 进行连接的过程，展示了使用链接起对目标文件进行连接的方法。按照上面的过程进行了连接之后，在连接器 link.exe 进行的目录下，将出现一个新的文件：1.exe，这是对目标文件 1.obj 进行连接所得到的结果。当然，如果连接过程中出现错误，那么将得不到可执行文件。

连接的作用是什么呢？

对于连接，我们也不想过多地讨论。实际上，在汇编课程中，我们将会接触到许多知识、概念，对于这些，我们并不是都有深入讨论的必要。

这里再次强调一下，我们学习汇编的主要目的，就是通过用汇编语言进行编程而深入地理解计算机底层的基本工作机理，达到可以随心所欲地控制计算机地目的。基于这种考虑，我们的编程活动，大都是直接对硬件进行的。我们希望直接对硬件编程，却并不希望用机器码编程。我们用汇编语言编程，就要用到编辑器（Edit）、编译器（masm）、连接器（link）、调式工具（Debug）等所有工具，而这些工具都是在操作系统之上运行的程序，所以我们的学习过程必须在操作系统的环境中进行。我们在一个操作系统环境中，使用了许多工具，这势必要牵扯到操作系统、编译原理等方面的知识和原理。我们只是利用这些环境、工具来方便我们的学习，而不希望这些东西分散了我们的注意力。所以，对于涉及而又不在我们学习的主要内容之中的东西，我们只做简单的解释。

好了，我们简单地讲连接的作用，连接的作用有以下几个。

（1）源程序很大时，可以将它分为多个源程序文件来编译，每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件；

（2）程序中调用了某个库文件中的子程序，需要将这个库文件和该程序生成的目标文件连接到一起去，生成一个可执行文件；

（3）一个源程序编译后，得到了存有机器码的目标文件，目标文件中的有些内容还不能直接用来生成可执行文件，连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。

注意，对于连接的过程，可执行文件是我们要得到的最终结果。



#### 4.6	以简化的方式进行编译和连接

在前面的内容里，介绍了如何使用 masm 和 link 进行编译和连接。可以看出，我们编译、连接的最终目的是用源程序文件生成可执行文件。在这个过程中所产生的中间文件都可以忽略。我们可以用一种较为简捷的方式进行编译、连接。

直接使用命令 “masm c:\1;”，“link 1;”，在 masm 后面加上被编译的源程序文件的路径、文件名，在命令行的结尾再加上分号，按 Enter 键后，编译器就对 c:\1.asm 进行编译，在当前路径下生成目标文件 1.obj，并在编译的过程中自动忽略中间文件的生成。link 同理。



#### 4.7	1.exe 的执行

现在，终于将我们的第一个汇编程序加工成了一个可在操作系统下执行的程序文件，在命令行输入 “1”，点击 Enter 键执行 1.exe，图 4.17 展示了 1.exe 的执行情况。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE33.jpg"/> </div><br>
程序运行后，没有任何结果，因为我们没有向显示器输出任何信息。程序执行完成后，返回，屏幕上再次出现操作系统的提示符。



#### 4.8	谁将可执行文件中的程序装载进入内存并使它运行？

我们在前面讲过，在 DOS 中，可执行文件中的程序 P1 若要运行，必须有一个正在运行的程序 P2，将 P1 从可执行文件中加载入内存，将 CPU 的控制权交给它，P1 才能得以运行；当 P1 运行完毕后，应该将 CPU 的控制权交换给使它得以运行的程序 P2。

按照上面的原理，再来看一下 4.7 节中的 1.exe 的执行过程（思考相关的问题）。



#### 操作系统的外壳

操作系统是由多个功能模块组成的庞大、复杂的软件系统。任何通用的操作系统，都要提供要给称为 shell（外壳）的程序，用户（操作人员）使用这个程序来操作计算机系统进行工作。

DOS 中有一个程序 command.com，这个程序在 DOS 中称为命令解释器，也就是 DOS 系统的 shell。

DOS 启动时，先完成其他重要的初始化工作，然后运行 command.com，command.com 运行后，执行完其他的相关任务后，在屏幕上显示出由当前盘符和当前路径组成的提示符，比如：“c:\” 或 "c:\windows" 等，然后等待用户的输入。

用户可以输入所要执行的命令，比如，cd、dir、type 等，这些命令由 command 执行，command 执行完这些命令后，再次显示出由当前盘符和当前路径组成的提示符，等待用户的输入。

如果用户要执行一个程序，则输入该程序的可执行文件的名称，command 首先根据文件名找到可执行文件，然后将这个可执行文件中的程序加载入内存，设置 CS:IP 指向程序的入口。此后，command 暂停运行，CPU 运行程序。程序运行结束后，返回到 command 中，command 再次显示由当前盘符和当前路径组成的提示符，等待用户的输入。

在 DOS 中，command 处理各种输入：命令或要执行的程序的文件名。我们就是通过 command 来进行工作的。



#### 问题 4.1

此时，有一个正在运行的程序将 1.exe 中的程序加载入内存，这个正在运行的程序是什么？它将程序加载入内存后，如何使程序得以运行？



#### 问题 4.2

程序运行结束后，返回到哪里？



（1）在 DOS 中直接执行 1.exe 时，是正在运行的 command，将 1.exe 中的程序加载入内存；

（2）command 设置 CPU 的 CS:IP 指向程序的第一条指令（即程序的入口），从而使程序得以运行；

（3）程序运行结束后，返回到 command 中，CPU 继续运行 command。





#### 4.9	程序执行过程的跟踪

可以用 Debug 来跟踪一个程序的运行过程，这通常是必须要做的工作。我们写的程序在逻辑上不一定总是正确，对于简单的错误，仔细检查一下源程序就可以发现：而对于隐藏较深的错误，就必须对程序的执行过程进行跟踪分析才容易发现。

下面以在前面的内容中生成的可执行文件 1.exe 为例，讲解如何用 Debug 对程序的执行过程进行跟踪。

现在我们知道，在 DOS 中运行一个程序的时候，是由 command 将持续从可执行文件中加载入内存，并使其得以执行。但是，这样我们不能逐条指令地看到程序的执行过程，因为 command 的程序加载，设置 CS:IP 指向程序的入口的操作是连续完成的，而当 CS:IP 一指向程序的入口，command 就放弃了 CPU 的控制权，CPU 立即开始运行程序，直至程序结束。

为了观察程序的运行过程，可以使用 Debug。Debug 可以将程序加载入内存，设置 CS:IP 指向程序的入口，但 Debug 并不放弃对 CPU 的控制，这样，我们就可以使用 Debug 的相关命令来单步执行程序，查看每一条指令的执行结果。

具体方法如图 4.18 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE34.jpg"/> </div><br>
在提示符后输入 “debug 1.exe”，按 Enter 键，Debug 将程序从 1.exe 中加载入内存，进行相关的初始化后设置 CS:IP 指向程序的入口。

接下来可以用 R 命令看一下各个寄存器的设置情况，如图 4.19 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE35.jpg"/> </div><br>
可以看到，Debug 将程序从可执行文件加载入内存后，cx（count）：计数寄存器中存放的是程序的长度。1.exe 中程序的机器码共有 15 个字节。则 1.exe 加载后，cx 中的内容为 000FH。

现在程序已从 1.exe 中装入内存，接下来查看一下它的内容，可是我们查看哪里的内容呢？程序被装入内存的什么地方？我们如何得知？

这里，需要讲解一下在 DOS 系统中 .EXE 文件中的程序的加载过程。图 4.20 针对我们的问题，简要地展示了这个过程。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE36.jpg"/> </div><br>
program segment prefix，简称PSP（程序段前缀）。

注意，有一步称为重定位的工作在图 4.20 中没有讲解，因为这个问题和操作系统的关系较大，我们不作讨论。

那么，我们的程序被装入内存的什么地方？我们如何得知？从图 4.20 中我们知道以下的信息。

（1）程序加载后，ds 中存放着程序所在内存区的段地址，这个内存区的偏移地址为 0，则程序所在的内存区的地址为 ds:0;

（2）这个内存区的前 256 个字节中存放的是 PSP，DOS 用来和程序进行通信。从 256 字节处向后的空间存放的是程序。

所以，从 ds 中可以得到 PSP 的段地址 SA，PSP 的偏移地址为 0，则物理地址为 SA×16+0。

因为 PSP 占 256（100H）字节，所以程序的物理地址是：SA+10H:0。

现在，我们看一下图 4.19 中 DS 的值，DS=129E，则 PSP 的地址为 129E:0，程序的地址为 12AE:0（即 129E+10:0）。

图 4.19 中，CS=12AE，IP=0000，CS:IP 指向程序的第一条指令。注意，源程序中的指令是 mov ax,0123H，在 Debug 中记为 mov ax,0123，这是因为 Debug 默认所有数据都用十六进制表示。

可以用 U 指令看一下其他指令，如图 4.21 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE37.jpg"/> </div><br>
可以看到，从 12AE:0000~12AE:000E 都是程序的机器码。

现在，我们可以开始跟踪了，用 T 命令单步执行程序中的每一条指令，并观察每条指令的执行结果，到了 int 21，我们要用 P 命令执行，如图 4.22 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE38.jpg"/> </div><br>
图 4.22 中，int 21 执行后，显示出 “Peogram terminated normally”，返回到 Debug 中。表示程序正常结束。注意，要使用 P 命令执行 int 21。这里不必考虑是为什么，只要记住这一点就可以了。

需要注意的是，在 DOS 中运行程序时，是 command 将程序加载入内存，所以程序运行结束后返回到 command 中，而在这里是 Debug 将程序加载入内存，所以程序运行结束后要返回到 Debug 中。p

使用 Q 命令退出 Debug，将返回到 command 中，因为 Debug 是由 command 加载运行的。在 DOS 中用 “debug 1.exe” 运行 Debug 对 1.exe 进行跟踪时，程序加载的顺序是：command 加载 Debug，Debug 加载 1.exe。返回的顺序是：从 1.exe 中的程序返回到 Debug，从 Debug 返回到 command。



#### 实验 3	编程、编译、连接、跟踪

（1）将下面的程序保存为 t1.asm 文件，将其生成可执行文件 t1.exe。

```assembly
assume cs:codesg

codesg segment

	mov ax,2000H
	mov ss,ax
	mov sp,10
	pop ax
	pop bx
	push ax
	push bx
	pop ax
	pop bx
	
	mov ax,4c00H
	int 21H
	
codesg ends

end
```



（2）用 Debug 跟踪 t1.exe 的执行过程，写出每一步执行后，相关寄存器中的内容和栈顶的内容。

ax=ffff	bx=0000	ss=0769	sp=0000

ds=075A	cs=076A	ip=0000



ax=2000	bx=0000	ss=0769	sp=0000

ds=075A	cs=076A	ip=0003



ax=2000	bx=0000	ss=0769	sp=0000

ds=075A	cs=076A	ip=0003



ax=2000	bx=0000	ss=2000	sp=000A

ds=075A	cs=076A	ip=0008



2000:a  0000	2000:c 0000

ax=0000	bx=0000



ax=2000	bx=0000	ss=2000	sp=000A

ds=075A	cs=076A	ip=0009



ax=0000	bx=0000	ss=2000	sp=000C

ds=075A	cs=076A	ip=000A



ax=0000	bx=0000	ss=2000	sp=000E

ds=075A	cs=076A	ip=000B



ax=0000	bx=0000	ss=2000	sp=000C

ds=075A	cs=076A	ip=000C



ax=0000	bx=0000	ss=2000	sp=000A

ds=075A	cs=076A	ip=000D



ax=0000	bx=0000	ss=2000	sp=000C

ds=075A	cs=076A	ip=000E



ax=4c00	bx=0000	ss=2000	sp=000E

ds=075A	cs=076A	ip=0011



（3）PSP 的头两个字节是 CD 20，用 Debug 加载 t1.exe，查看 PSP 的内容。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE39.jpg"/> </div><br>
### 第 5 章	[BX] 和 loop 指令

**1.[bx] 和内存单元的描述**

[bx] 是什么呢？和 [0] 有些类似，[0] 表示内存单元，它的偏移地址是 0。比如在下面的指令中，（在 Debug 中使用）：

mov ax,[0]

将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址为 0，段地址在 ds 中。

mov al,[0]

将一个内存单元的内容送入 al，这个内存单元的长度为 1 字节（字节单元），存放一个字节，偏移地址为 0，段地址在 ds 中。

要完整地描述一个内存单元，需要两种信息：（1）内存单元的地址；（2）内存单元的长度（类型）。

用 [0] 表示一个内存单元时，0 表示内存单元的偏移地址，段地址默认在 ds 中，单元的长度（类型）可以由具体指令中的其他操作对象（比如说寄存器）指出。

[bx] 同样也表示一个内存单元，它的偏移地址在 bx 中，比如下面的指令：

mov ax,[bx]

将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址在 bx 中，段地址在 ds 中。

mov al,[bx]

将一个内存单元的内容送入 al，这个内存单元的长度为 1 字节，存放一个字节，偏移地址在 bx 中，段地址在 ds 中。



**2.loop**

英文单词 "loop" 有循环的含义，显然这个指令和循环有关。

我们在这一章，讲解 [bx] 和 loop 指令的应用、意义和相关的内容。



**3.我们定义的描述性的符号：“()”**

为了描述上的简洁，在以后的课程中，我们将使用一个描述性的符号 “()” 来表示一个寄存器或一个内存单元中的内容。比如：

(ax) 表示 ax 中的内容、(al) 表示 al 中的内容；

(20000H) 表示内存 20000H 单元的内容（括号中的内存单元的地址为物理地址）；

((ds)*16+(bx)) 表示：

ds 中的内容为 ADR1，bx 中的内容为 ADR2，内存 ADR1×16+ADR2 单元的内容。

也可以理解为：ds 中的 ADR1 作为段地址，bx 中的 ADR2 作为偏移地址，内存 ADR1:ADR2 单元的内容。

注意，“()” 中的元素可以有 3 种类型：（1）寄存器名；（2）段寄存器名；（3）内存单元的物理地址（一个 20 位数据）。比如：

(ax)、(ds)、(al)、(cx)、(20000H)、(ds)*16、(bx) 等是正确的用法：

(2000:0)、((ds):1000H)  等是不正确的用法。

我们看一下 (x) 的应用，比如，

（1）ax 中的内容为 0010H，可以这样来描述：(ax)=0010H;

（2）2000:1000 处的内容为 0010H，可以这样来描述：(21000H)=0010H;

（3）对于 mov ax,[2] 的功能，可以这样来描述：(ax)=((ds)*16+2);

（4）对于 mov [2],ax 的功能，可以这样来描述：((ds)*16+2)=(ax);

（5）对于 add ax,2 的功能，可以这样来描述：(ax)=(ax)+2;

（6）对于 add ax,bx 的功能，可以这样来描述：(ax)=(ax)+(bx);

（7）对于 push ax 的功能，可以这样来描述：

​			(sp)=(sp)-2

​			((ss)*16+(sp))=(ax)

（8）对于 pop ax 的功能，可以这样来描述：

​			(ax)=((ss)*16+(sp))

​			(sp)=(sp)+2



"(x)" 所表示的数据有两种类型：（1）字节;（2）字。是哪种类型由寄存器名或具体的运算决定，比如：

 (al)、(bl)、(cl) 等得到的数据为字节型；(ds)、(ax)、(bx) 等得到的数据为字型。

(al)=(20000H)，则 (20000H) 得到的数据为字节型；(ax)=(20000H)，则 (20000H) 得到的数据为字型。



**4.约定符号 idata 表示常量**

我们在 Debug 中写过类似的指令：mov ax,[0]，表示将 ds:0 处的数据送入 ax 中。指令中，在 “[...]” 里用一个常量 0 表示内存单元的偏移地址。以后，我们用 idata 表示常量。比如：

mov ax,[idata] 就代表 mov ax,[1] 、mov ax,[2]、mov ax,[3] 等。

mov bx,idata 就代表 mov bx,1、mov bx,2、mov bx,3 等。

mov ds,idata 就代表 mov ds,1、mov ds,2 等，它们都是非法指令。





#### 5.1	[BX]

看一看下面指令的功能。

mov ax,[bx]

功能：bx 中存放的数据作为一个偏移地址 EA，段地址 SA 默认在 ds 中，将 SA:EA 处的数据送入 ax 中。即：(ax)=((ds)*16+(bx))。

mov [bx],ax

功能：bx 中存放的数据作为一个偏移地址 EA，段地址 SA 默认在 ds 中，将 ax 中的数据送入内存 SA:EA 处。即：((ds)*16+(bx))=(ax)



#### 5.2	Loop 指令

loop 指令的格式是：loop 标号，CPU 执行 loop 指令的时候，要进行两步操作，（1）(cx)=(cx)-1;

（2）判断 cx 中的值，不为零则转至标号处执行程序，如果为零则向下执行。

cx（count）：计数寄存器中存放的是程序的长度。

从上面的描述中，可以看到，cx 中的值影响着 loop 指令的执行结果。通常（注意，我们说的是通常）我们用 loop 指令来实现循环功能，cx 中存放循环次数。

这里讲解 loop 指令的功能，关于 loop 指令如何实现转至标号处的细节，将在后面的课程中讲解。下面我们通过一个程序来看一下 loop 指令的具体应用。

任务 1：编程计算 2^2，结果存在 ax 中。

分析：设 (ax)=2，可计算 (ax)=(ax)*2，最后  (ax) 中为 2^2 的值。N *2 可用 N+N 实现，程序如下。

```assembly
assume cs:code
code segment
 mov ax,2
 add ax,ax
 
 mov ax,4c00h
 int 21h
code ends
end
```



按照我们的算法，计算 2^12 需要 11 条重复的指令 add ax,ax。我们显然不希望这样来写程序，这里，可用 loop 来简化我们的程序。



#### 程序 5.1

```assembly
assume cs:code
code segmetn
	mov ax,2
	mov cx,11
s:	add ax,ax
	loop s
	mov ax,4c00h
	int 21h
code ends
end
```



下面分析一下程序 5.1

（1）标号

在汇编语言中，标号代表一个地址，程序 5.1 中有一个标号 s。它实际上标识了一个地址，这个地址处有一条指令：add ax,ax。

（2）loop s

CPU 执行 loop s 的时候，要进行两步操作：

1. (cx)=(cx)-1;

2. 判断 cx 中的值，不为 0 则转至标号 s 所标识的地址处执行（这里的指令是 add ax,ax），如果为零则执行下一条指令（下一条指令是 mov ax,4c00h）。

3. 以下 3 条指令

   ```assembly
   	mov cx,11
   s:	add ax,ax
   	loop s
   ```

   

执行 loop s 时，首先要将 (cx) 减 1，然后若 (cx) 不为 0，则向前转至 s 处执行 add ax,ax。所以，可以利用 cx 来控制 add ax,ax 的执行次数。

从上面的过程中，我们可以总结出用 cs 和 loop 指令相配合实现循环功能的 3 个要点。

（1）在 cx 中存放循环次数；

（2）loop 指令中的标号所标识地址要在前面；

（3）要循环执行的程序段，要写在标号和 loop 指令的中间。

用 cx 和 loop 指令相配合实现循环功能的程序框架如下。

​	mov cx,循环次数

s:

​	循环执行的程序段

​	loop s





#### 5.3	在 Debug 中跟踪用 loop 指令实现的循环程序

考虑这样一个问题，计算 ffff:0006 单元中的数乘以 3，结果存储在 dx 中。

我们分析一下。

（1）运算后的结果是否会超出 dx 所能存储的范围？

ffff:0006 单元中的数是一个字节型的数据，范围在 0~255 之间，则用它和 3 相乘结果不会大于 65535，可以在 dx 中存放下。

（2）用循环累加来实现乘法，用哪个寄存器进行累加？

将 ffff:0006 单元中的数赋值给 ax，用 ds 进行累加。先设 (dx)=0，然后做 3 次 (dx)=(dx)+(ax)。

（3）ffff:6 单元是一个字节单元，ax 是一个 16 位寄存器，数据的长度不一样，如何赋值？

注意，我们说的是 “赋值”，就是说，让 ax 中的数据的值（数据的大小）和 ffff:0006 单元中的数据的值（数据的大小）相等。8 位数据 01H 和 16 位数据 0001H 的数据长度大小不一样，但它们的值是相等的。

那么我们如何赋值？设 ffff:0006 单元中的数据是 XXH，若要 ax 中的值和 ffff:0006 单元中的相等，ax 中的数据应为 00XXH。所以，若实现 ffff:0006 单元向 ax 赋值，应该令 (ah)=0，(al)=(ffff6H)。

想清楚以上的 3 个问题之后，编写程序如下。



#### 程序 5.3

```assembly
assume cs:code
code segment
	mov ax,0ffffh
	mov ds,ax
	mov bx,6		;以上，设置 ds:bx 指向 ffff:6
	
	mov al,[bx]
	mov ah,0		;以上，设置 (al)=((ds*16)+(bx)), (ah)=0
	
	mov dx,0		;累加寄存器清 0
	
	mov cs,3		;循环 3 次
  s:add dx,ax
    loop s			;以上累加计算 (ax)*3
    
    mov ax,4c00h
    int 21h			;程序返回
    
code ends
end
```



注意程序中的第一条指令 mov ax,0ffffh。我们知道，大于 9FFFH 的十六进制数据 A000H、A0001H...FFFEH、FFFFH 等，在书写的时候都是以字母开头的。而在**汇编源程序中，数据不能以字母开头**，所以要再前面加 0。比如，9138h 在汇编源程序中可以直接写为 “9138h”，而 A000h 在汇编源程序中要写为 "0A000h"。



使用 g 命令直接给 ip 赋值，程序会直接执行到指定位置处，格式形如 “g 0016”。

使用 p 命令来跳过循环，遇到 loop 指令时，使用 p 命令来执行，Debug 就会自动重复执行循环中的指令，直到 (cx)=0 为止。



#### 5.4	Debug 和汇编编译器 masm 对指令的不同处理

本节知识点为下面课程的顺利进行提供一点预备知识。

我们在 Debug 中写过类似的指令：

mov ax,[0]

表示将 ds:0 处的数据送入 ax 中。

但是在汇编源程序中，指令 "mov ax,[0]" 被编译器当作指令 “mov ax,0” 处理。

下面通过具体的例子来看一下 Debug 和汇编编译器 masm 对形如 “mov ax,[0]” 这类指令的不同处理。

任务：将内存 2000:0、2000:1、2000:2、2000:3 单元中的数据送入 al,bl,cl,dl 中。

（1）在 Debug 中编程实现：

```assembly
mov ax,2000
mov ds,ax
mov al,[0]
mov bl,[1]
mov cl,[2]
mov dl,[3]
```



（2）汇编源程序实现：

```assembly
assume cs:code
code segment

    mov ax,2000h
    mov ds,ax
    mov al,[0]
    mov bl,[1]
    mov cl,[2]
    mov dl,[3]

code ends
end
```



我们看一下两种实现的实际实施情况：

（1）Debug 中的情况如图 5.16 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE40.jpg"/> </div><br>
（2）将汇编源程序存储为 compare.asm，用 masm、link 生成 compare.exe，用 Debug 加载 compare.exe，如图 5.17 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE41.jpg"/> </div><br>
从图 5.16，图 5.17 中我们可以明显地看出，Debug 和编译器 masm 对形如 “mov ax,[0]” 这类指令在解释上的不同。我们在 Debug 中和源程序中写入同样形式的指令：“mov al,[0]”、“mov bl,[1]”，但 Debug 和编译器对这些指令中的 “[idata]” 却有不同的解释。Debug 将它解释为 “[idata]” 是一个内存单元，“idata” 是内存单元的偏移地址；而编译器将 “[idata]” 解释为 “idata”。

那么我们如何在源程序中实现将内存  2000:0、2000:1、2000:2、2000:3 单元中的数据送入 al,bl,cl,dl 中呢？

目前的方法是，可将偏移地址送入 bx 寄存器中，用 [bx] 的方式来访问内存单元。比如我们可以这样访问 2000:0 单元：

```assembly
mov ax,2000h
mov ds,ax		;段地址 2000h 送入 ds
mov bx,0		;偏移地址 0 送入 bx
mov al,[bx]		;ds:bx 单元中的数据送入 al
```



这样做是可以，可是比较麻烦，我们要用 bx 来间接地给出内存单元的偏移地址。我们还是希望能够像在 Debug 中那样，在 "[ ]" 中直接给出内存单元的偏移地址。这样做，在汇编源程序中也是可以的，只不过，要在 "[ ]" 的前面显式地给出段地址所在地段寄存器。比如我们可以这样访问 2000:0 单元：

```assembly
mov ax,2000h
mov ds,ax
mov al,ds:[0]
```

 

比较一下汇编源程序中以下指令的含义。

"mov al,[0]"，含义：(al)=0，将常量 0 送入 al 中（与 mov al,0 含义相同）；

"mov al,ds:[0]"，含义：(al)=((ds)*16+0)，将内存单元中的数据送入 al 中；

"mov al,[bx]"，含义：(al)=((ds)*16+(bx))，将内存单元中的数据送入 al 中；

"mov al,ds:[bx]"，含义：与 “mov al,[bx]” 相同；

从上面的比较中可以看出：

（1）在汇编源程序中，如果用指令访问一个内存单元，则在指令中必须用 “[...]” 来表示内存单元，如果在 “[]” 里用一个常量 idata 直接给出内存单元的偏移地址，就要在 “[]” 的前面显式地给出段地址所在的段寄存器，比如

mov al,ds:[0]

如果没有在 ”[]“ 的前面显式地给出段地址所在的段寄存器，比如

mov al,[0]

那么，编译器 masm 将把指令中的 "[idata]" 解释为 ”idata“。



（2）如果在 ”[]“ 里用寄存器，比如 bx，间接给出内存单元的偏移地址，则段地址默认在 ds 中，当然，也可以显式地给出段地址所在的段寄存器。





#### 5.5	loop 和 [bx] 的联合应用

考虑这样一个问题，计算 ffff:0~ffff:b 单元中的数据的和，结果存储在 dx 中。

我们还是先分析一下。

（1）运算后的结果是否会超出 dx 所能存储的范围？

ffff:0~ffff:b 内存单元中的数据是字节型数据，范围在 0~255 之间，12 个这样的数据相加，结果不会大于 65535，可以在 dx 中存放下。

（2）我们能否将 ffff:0~ffff:b 中的数据直接累加到 dx 中？

当然不行，因为 ffff:0~ffff:b 中的数据是 8 位的，不能直接加到 16 位寄存器 dx 中。

（3）我们能否将 ffff:0~ffff:b 中的数据累加到 dl 中，并设置 (dh)=0，从而实现累加到 dx 中？

这也不行，因为 dl 是 8 位寄存器，能容纳的数据的范围在 0~255 之间，ffff:0~ffff:b 中的数据也都是 8 位，如果仅向 dl 中累加 12 个 8 位数据，很有可能造成进位丢失。

（4）我们到底怎样将 ffff:0~ffff:b 中的 8 位数据，累加到 16 位寄存器 dx 中？

从上面的分析中，可以看到，这里面有两个问题：类型的匹配和结果的不超界。具体的说，就是在做加法的时候，我们有两种方法：

1. (dx)=(dx)+内存中的 8 位数据；

2. (dl)=(dl)+内存中 8 位数据。



第一种方法中问题是两个运算对象的类型不匹配，第二种分分钟的问题是结果有可能超界。

怎样解决这两个看似矛盾的问题？目前的方法（在后面的课程中我们还有别的方法）就是得用一个 16 位寄存器来做中介。将内存单元中的 8 位数据赋值到一个 16 位寄存器 ax 中，再将 ax 中的数据加到 dx 上，从而使两个运算对象的类型匹配并且结果不会超界。





#### 5.6	段	前	缀

指令 "mov ax,[bx]" 中，内存单元的偏移地址由 bx 给出，而段地址默认在 ds 中。我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器。比如：

（1）mov ax,ds:[bx]

将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址在 bx 中，段地址在 ds 中。

（2）mov ax,cs:[bx]

将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址在 bx 中，段地址在 cs 中。

（3）mov ax,ss:[bx]

将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址在 bx 中，段地址在 ss 中。

（4）mov ax,es:[bx]

将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址在 bx 中，段地址在 es 中。

（5）mov ax,ss:[0]

将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址为 0，段地址在 ss 中。

（6）mov ax,cs:[0]

将一个内存单元的内容送入 ax，这个内存单元的长度为 2 字节（字单元），存放一个字，偏移地址为 0，段地址在 cs 中。

这些出现在访问内存单元的指令中，用于显式地指明内存单元地段地址的 ”ds:“ "cs:" "ss:" "es:"，在汇编语言中称为**段前缀**。



#### 5.7	一段安全的空间

在 8060 模式中，随意向一段内存空间写入内容是很危险的，因为这段空间中可能存放着重要的系统数据库或代码。比如下面的指令：

```assembly
mov ax,1000h
mov ds,ax
mov al,0
mov ds:[0],al
```



我们以前在 Debug 中，为了讲解上的方便，写过类似的指令。但这种做法是不合理的，因为之前我们并没有论证过 1000:0 中是否存放着重要的系统数据或代码。如果 1000:0 存放着重要的系统数据或代码，”mov ds:[0],al‘ 将其改写，将引发错误。



#### 程序 5.7

```assembly
assume cs:code
code segment

	mov ax,0
	mov ds,ax
	mov ds:[26h],ax
	
	mov ax,4c00h
	int 21h
	
code ends
end
```



在虚拟 DOS 方式中，代码会报错。如果在实模式（即纯 DOS 方式）下执行程序，将会引起死机。产生这种结果的原因是 0:0026 处存放着重要的系统数据，而 ”mov [0026],ax“ 将其改写。

可见，在不能确定一段内存空间中是否存放着重要的数据或代码的时候，不能随意向其中写入内容。

不要忘记，我们是在操作系统的环境中工作，操作系统管理所有的资源，也包括内存。如果我们需要向内存空间写入数据的话，要使用操作系统给我们分配的空间，而不应直接用地址任意指定内存单元，向里面写入。下一章我们会对 ”使用操作系统给我们分配的空间“ 有所认识。

但是，同样不能忘记，我们正在学习的是汇编语言，要通过它来获得底层的编程体验，理解计算机底层的基本工作机理。所以我们尽量直接对硬件编程，而不去理会操作系统。

我们似乎面临一种选择，是在操作系统中安全、规矩地编程，还是自由、直接地用汇编语言去操作真实的硬件，了解哪些早已被层层系统软件遮盖的真相？在大部分的情况下，我们选择后者，除非我们就是在学习操作系统本身的内容。

注意，我们在纯 DOS 方式（实模式）下，可以不理会 DOS，直接用汇编语言去操作真实的硬件，因为运行在 CPU 实模式下的 DOS，没有能力对硬件系统进行全面、严格地管理。但在 Windows 2000、Unix 这些运行于 CPU 保护模式下的操作系统中，不理会操作系统，用汇编语言去操作真实的硬件，是根本不可能的。硬件已被这些操作系统利用 CPU 保护模式所提供的功能全面而严格地管理了。

在后面的课程中，我们需要直接向内存中写入内容，可我们又不希望发生上面的情况，所以要找到一段安全的空间供我们使用。在一般的 PC 机中，DOS 方式下，DOS 和其他合法的程序一般都不会使用 0:200~0:2ff(00200h ~ 002ffh) 的 256 个字节的空间，所以，我们使用这段空间是安全地。不过为了谨慎起见，在进入 DOS 后，我们可以先用 Debug 查看以下，如果 0:200~0:2ff 单元的内容都是 0 的话，则证明 DOS 和其他合法的程序没有使用这里。

为什么 DOS 和其他合法的程序一般都不会使用 0:200~0:2ff 这段空间？我们将在以后的课程中讨论这个问题。

好了，我们总结一下：

（1）我们需要直接向一段内存中写入内容；

（2）这段内存空间不应存放系统或其他程序的数据或代码，否则写入操作很可能引发错误；

（3）DOS 方式下，一般情况，0:200~0:2ff 空间中没有系统或其他程序的数据或代码；

（4）以后，我们需要直接向一段内存中写入内容时，就使用 0:200~0:2ff 这段空间。



#### 5.8	段前缀的使用

我们考虑一个问题，将内存 ffff:0~ffff:b 单元中的数据复制到 0:200~0:20b 单元中。

分析一下：

（1）0:200~0:20b 单元等同于 0020:0~0020:b 单元，它们描述的是同一段内存空间。

（2）复制的过程应用循环实现，简要描述如下：

​       初始化：

​       x=0

​       循环12次：

​       将 ffff:x 单元中的数据送入 0020:x（需要用一个寄存器中转，因为没有 mov 内存单元,内存单元）

（3）在循环中，源始单元 ffff:x 和目标单元 0020:x 的偏移地址 x 是变量。我们用 bx 来存放。

（4）将 0:200~0:20b 用 0020:0~0020:b 描述，就是为了使目标单元的偏移地址和源始单元的偏移地址从同一数值 0 开始。

 

#### 程序 5.8

```assembly
assume cs:code
code segment

    mov bx,0
    mov cx,12
    
s:  mov ax,0ffffh
    mov ds,ax
    mov dl,[bx]

    mov ax,002h
    mov ds,ax
    mov [bx],dl

    inc bx
    loop s
    
    mov ax,4c00h
    int 21h
    
code ends
end

```



因源始单元 ffff:x 和目标单元 0020:x 相距大于 64KB，在不同的 64KB 段里，程序 5.8 中，每次循环要设置两次 ds。这样做是正确的，但是效率不高。我们可以使用两个段寄存器分别存放源始单元 ffff:x 和目标单元 0020:x 的段地址，这样就可以省略循环中需要重复做 12 次的设置 ds 的程序段。



#### 程序 5.9

```assembly
assume cs:code
code segment

    mov ax,0ffffh
    mov ds,ax
    
    mov ax,0020h
    mov es,ax
    
    mov bx,0
    mov cx,12
    
s:	mov dl,[bx]    
    mov es:[bx],dl
    inc bx
    loop s
    
    mov ax,4c00h
    int 21h
    
code ends
end

```



使用 es 存放目标空间 0020:0~0020:b 的段地址，用 ds 存放源始空间 ffff:0~ffff:b 的段地址。在访问内存单元的指令 “mov es:[bx],al” 中，显式地用段前缀 “es:” 给出单元的段地址，这样就不必在循环中重复设置 ds。



#### 实验 4	[bx] 和 loop 的使用

（1）编程，向内存 0:200~0:23F 依次送入数据 0~63(3FH)。

（2）编程，向内存 0:200~0:23F 依次送入数据 0~63(3FH)，程序中只能使用 9 条指令，9 条指令中包括 ”mov ax,4c00h“ 和 ”int 21h‘。

```assembly
assume cs:code
code segment

    mov ax,0020h
    mov ds,ax
    
    mov bx,0
    
    mov cx,40H		//mov cx,64 也可以
    
s:	mov [bx],bl     
    inc bx
    loop s
    
    mov ax,4c00h
    int 21h
    
code ends
end
```



（3）下面的程序的功能是将 “mov ax,4c00h’ 之前的指令复制到内存 0:200 处，补全程序。上机调试，跟踪运行结果。

```assembly
assume cs:code
code segment

	mov ax,
	mov ds,ax
	mov ax,0020h
	mov es,ax
	mov bx,0
	mov cx,
  s:mov al,[bx]
    mov es:[bx],al
    inc bx
    loop s
    mov ax,4c00h
    int 21h
    
code ends
end
```



程序分析：

（1）使用 debug 调试一个 exe 文件时候，使用 r 命令查看寄存器状态，其中 cx 寄存器的值（初始值）就是该程序代码的大小（按照字节数）。我们可以通过运行 debug 程序来调式生成的 exe 文件，前提是先将程序补全，填写临时的值。

（2）cs 段寄存器中存储的是指向程序代码段的段地址。此实验是将程序的代码（按字节）赋值，故将 cs 寄存器中的指向代码的段地址赋值给 ax，再通过 ax 寄存器赋值给 ds 段寄存器。（为什么不能支持从段寄存器 cs 直接赋值给段寄存器 ds 呢？回忆下，在 8086CPU 中，ds、ss、cs、es 四个段寄存器存放的都是段地址，在 CPU 和我们看来。其他的寄存器一般存放的都是数据。 这 4 个段寄存器支持从其他寄存器中赋值，但不允许立即数直接赋值给段寄存器。）

（3）[bx] 作为偏移地址为 bx 的内存单元，它支持的段地址默认是存储在 ds 段寄存器中的。 本例中 ds：[bx] 指向的是存储代码段的内存单元（源内存段）。由于 ds 被占用了，故被写入的内存单元的段地址就没有存储的段寄存器了，es 寄存器上场了，es 存储了地址为 0020H 的段地址（目标内存段），那么同样使用 [bx] 偏移地址的话，必须明确的指出它的前缀，故 es：[bx] 就指向了内存是 0200H 的内存单元地址段。



**实验步骤如下：**

（1）首先使用debug调试该程序：假如这个可执行程序（经编译、连接无误后的）为test.exe

**debug  test.exe**  



（2）使用r命令显示寄存器状态，显示整个程序代码所占字节数。

-r

AX=0000  BX=0000  CX=001C  DX=0000  SP=0000  BP=0000  SI=0000  DI=0000

DS=0B55  ES=0B55  SS=0B65  CS=0B65  IP=0000   NV UP EI PL NZ NA PO NC

0B65:0000 8CC8          MOV     AX,CS

这里我们发现 CX=001CH。



（3）使用u命令显示汇编指令，求出需要复制的机器码字节数。

-u cs:0000

0B65:0000 8CC8          MOV     AX,CS

0B65:0002 8ED8          MOV     DS,AX

0B65:0004 B82000        MOV     AX,0020

0B65:0007 8EC0          MOV     ES,AX

0B65:0009 BB0000        MOV     BX,0000

0B65:000C B90300        MOV     CX,0003

0B65:000F 8A07          MOV     AL,[BX]

0B65:0011 26            ES:

0B65:0012 8807          MOV     [BX],AL

0B65:0014 43            INC     BX

0B65:0015 E2F8          LOOP    000F

0B65:0017 B8004C        MOV     AX,4C00

0B65:001A CD21          INT     21



我们发现 mov ax,4cooH/int 21H 它们共占用了 5 个字节。所以在本实验中我们需要复制的代码字节数是 001CH-0005H=0017H=23 个字节，故 cx 计数寄存器赋值为 23 或 17H。



（4）完整的汇编代码如下：

```assembly
assume cs:code

code segment

    mov ax,cs       ;将 cs 段地址赋值给 ax
    mov ds,ax       ;用 cs 寄存器中的值初始化 ds 段寄存器，

    mov ax,0020H
    mov es,ax       ;es 指向 0020H 内存段
    
    mov bx,0        ;偏移地址寄存器清零
    mov cx,17H      ;此处是循环次数:程序机器码的字节数，存储在 CX 中

  s:mov al,[bx]     ;将 [bx] 按照字节单元传送给 al
    mov es:[bx],al  ;复制到 es 段内存中
    inc bx
    
    loop s

    mov ax,4c00H
    int 21H

code ends

end
```





**实验结果测试：**

-d 20:0

0020:0000  8C C8 8E D8 B8 20 00 8E-C0 BB 00 00 B9 17 00 8A   ..... ..........

0020:0010  07 26 88 07 43 E2 F8 00-00 00 00 00 00 00 00 00   .&..C...........

……

我们发现偏移地址从 0000H~0017H 存储了程序的执行代码。与程序执行代码存储的内存单元比较，我们发现是一样的。

-d cs:0

0B65:0000  8C C8 8E D8 B8 20 00 8E-C0 BB 00 00 B9 17 00 8A   ..... ..........

0B65:0010  07 26 88 07 43 E2 F8 B8-00 4C CD 21 FF 06 48 91   .&..C....L.!..H.





### 第 6 章	包含多个段的程序

前面的程序中，只有一个代码段。现在有一个问题是，如果程序需要用其他空间来存放数据，使用哪里呢？第 5 章中，我们讲到要使用一段安全的空间。可哪里安全呢？第 5 章中，我们说 0:200~0:2FF 是相对安全的，可这段空间的容量只有 256 个字节，如果我们需要的空间超过 256 个字节该怎么办呢？

在操作系统的环境中，合法地通过操作系统取得的空间都是安全的，因为操作系统不会让一个程序所用的空间和其他程序以及系统自己的空间相冲突。在操作系统运行的情况下，程序可以取得任意容量的空间。

程序取得所需空间的方法有两种，一是在加载程序的时候为程序分配，再就是程序在执行的过程中向系统申请。在我们的课程中，不讨论第二种方法。

加载程序的时候为程序分配空间，我们在前面已经有所体验，比如我们的程序在加载的时候，取得了代码段中的代码的存储空间。

我们若要一个程序在被加载的时候取得所需的空间，则必须要在源程序中做出说明。我们通过在源程序中定义段来进行内存空间的获取。

上面是从内存空间获取的角度上，谈定义段的问题。我们再从程序规划的角度来谈一下定义段的问题。大多数有用的程序，都要处理数据，使用栈空间，当然也都必须有指令，为了程序设计上的清晰和方便，我们一般也都定义不同的段来存放它们。

对于使用多个段的问题，我们先简单说到这里，下面我们将以这样的顺序来深入地讨论多个段的问题：

（1）在一个段中存放数据、代码、栈，我们先来体会一下不使用多个段时的情况；

（2）将数据、代码、栈放入不同的段中。



#### 6.1	在代码段中使用数据

考虑这样一个问题，编程计算以下 8 个数据的和，结果存在 ax 寄存器中：

0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h

在前面的课程中，我们都是累加某些内存单元中的数据，并不关心数据本身。可现在要累加的就是已经给定了数值的数据。我们可以将它们一个一个地加到 ax 寄存器中，但是，我们希望可以用循环的方法来进行累加，所以在累加前，要将这些数据存储在一组地址连续的内存单元中。如何将这些数据存储在一组地址连续的内存单元中呢？我们可以用指令一个一个地将它们送入地址连续的内存单元中，可是这样又有一个问题，到哪里去找这段内存空间呢？

从规范的角度来讲，我们是不能自己随便决定哪段空间可以使用的，应该让系统来为我们分配。我们可以在程序中，定义我们希望处理的数据，这些数据就会被编译、连接程序作为程序的一部分写到可执行文件中。当可执行文件中的程序被加载入内存时，这些数据也同时被加载入内存中。与此同时，我们要处理的数据也就自然而然地获得了内存空间。

具体的做法看下面的程序。



##### 程序 6.1

```assembly
assume cs:code
code segment

    dw 0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h
    mov bx,0
    mov ax,0

    mov cx,8
  s:add ax,cs:[bx]
    add bx,2
    loop s
    
    mov ax,4c00h
    int 21h
    
code ends
end
```



解释一下，程序第一行中的 “dw” 的含义是定义字型数据。dw 即 “define word‘。在这里，使用 dw 定义了 8 个字型数据（数据之间以逗号分隔），它们所占的内存空间的大小为 16 个字节。

程序中的指令就要对这 8 个数据进行累加，可这 8 个数据在哪里呢？由于它们在代码段中程序在运行的时候 CS 中存放代码段的段地址，所以可以从 CS 中得到它们的段地址。它们的偏移地址是多少呢？因为用 dw 定义的数据处于代码段的最开始，所以偏移地址为 0，这 8 个数据就在代码段的偏移 0、2、4、6、8、A、C、E 处。程序运行时，它们的地址就是 cs:0、cs:2、cs:4、cs:6、cs:8、cs:A、cs:C、cs:E。

程序中，用 bx 存放 2 递增的偏移地址，用循环来进行累加。在循环开始前，设置 (bx)=0，cs:bx 指向第一个数据所在的字单元。每次循环中 (bx)=(bx)+2，cs:bx 指向下一个数据所在的字单元。

将程序 6.1 编译、链接为可执行文件 p61.exe，先不要运行，用 Debug 加载查看一下，情况如图 6.1 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE42.jpg"/> </div><br>
图 6.1 中，通过 ”DS=0B2D“，可知道程序从 0B3D:0000 开始存放。用 u 命令从 0B3D:000 查看程序，却看到了一些让人读不懂的指令。

为什么没有看到程序中的指令呢？实际上用 u 命令从 0B3d:0000 查看到的也是程序中的内容，只不过不是源程序中的汇编指令所对应的机器码，而是源程序中，在汇编指令前面，用 dw 定义的数据。实际上，在程序中，有一个代码段，在代码段中，前面的 16 个字节是用 ”dw’ 定义的数据，从第 16 个字节开始菜是汇编指令所对应的机器码。

可以用 d 命令更清楚地查看一下程序中前 16 个字节的内容，如图 6.2 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE44.jpg"/> </div><br>
可以从 0B3D:0010 查看程序中要执行的机器指令，如图 6.3 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE43.jpg"/> </div><br>
从图 6.2 和 6.3 中，我们可以看到程序加载到内存中后，所占内存空间的前 16 个单元存放着源程序中用 “dw” 定义的数据，后面的单元存放源程序中汇编指令所对应的机器指令。

怎样执行程序中的指令呢？用 Debug 加载后，可以将 IP 设置为 10h，从而使 CS:IP 指向程序中的第一条指令。然后再用 t 命令、p 命令，或者是 g 命令执行。

可是这样依赖，我们就必须用 Debug 来执行程序。程序 6.1 编译、连接成可执行文件后，在系统中直接运行可能会出现问题，因为程序的入口处不是我们所希望执行的指令。如何让这个程序在编译、连接后可以在系统中直接运行呢？我们可以在源程序中指明程序的入口所在，具体做法如下。



##### 程序 6.2

```assembly
assume cs:code
code segment

    dw 0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h
    start:  mov bx,0
            mov ax,0

            mov cx,8
        s:  add ax,cs:[bx]
            add bx,2
            loop s

            mov ax,4c00h
            int 21h
    
code ends
end start
```



注意在程序 6.2 中加入的新内容，在程序的第一条指令的前面加上了一个标号 start，而这个标号在伪指令 end 的后面出现。这里，我们要再次探讨 end 的作用。end 除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。在程序 6.2 中我们用 end 指令指明了程序的入口在标号 start 处，也就是说，“mov bx,0” 是程序的第一条指令。

在前面的课程中（参见 4.8 节），我们已经知道在单任务系统中，可执行文件中的程序执行过程如下。

（1）由其他的程序（Debug、command 或其他程序）将可执行文件中的程序加载入内存；

（2）设置 CS:IP 指向程序的第一条要执行的指令（即程序的入口），从而使程序得以运行；

（3）程序运行结束后，返回到加载者。

现在的问题是，根据什么设置 CPU 的 CS:IP 指向程序的第一条要执行的指令？也就是说，如何知道哪一条指令是程序的第一条要执行的指令。这一点，是由可执行文件中的描述信息指明的。我们知道可执行文件由描述信息和程序组成，程序来自于远程中的汇编指令和定义的数据；描述信息则主要是编译、连接程序对源程序中相关伪指令进行处理所得到的信息。我们在程序 6.2 中，用伪指令 end 描述了程序的结束和程序的入口。在编译、连接后，由 “end start” 指明的程序入口，被转化为一个入口地址，存储在可执行文件的描述信息中。在程序 6.2 生成的可执行文件中，这个入口地址的偏移地址部分为：10H。当程序被加载入内存之后，加载者从程序的可执行文件的描述信息中读到程序的入口地址，设置 CS:IP。这样 CPU 就从我们希望的地址处开始执行。

归根结底，我们若要 CPU 从何处开始执行程序，只要在源程序中用 “end 标号” 指明就可以了。

有了这种方法，就可以这样来安排程序的框架：

```assembly
assume cs:code
code segmetn

	数据

start:

	代码
	
code ends
end start
```





#### 6.2	在代码段中使用栈

完成下面的程序，利用栈，将程序中定义的数据逆序存放。

```assembly
assume cs:codesg
codesg segment

    dw 0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h
	  ?
    
codesg ends
end start
```



程序的思路大致如下。

程序运行时，定义的数据存放在 cs:0~cs:F 单元中，共 8 个字单元。依次将这 8 个字单元中的数据入栈，然后再依次出栈到这 8 个字单元中，从而实现数据的逆序存放。

问题是，我们首先要有一段可当作栈的内存空间。如前所述，这段空间应该由系统来分配。可以在程序中通过定义数据来取得一段空间，然后将这段空间当作栈空间来用。程序如下。



##### 程序 6.3

```assembly
assume cs:codesg
codesge segment
	dw 0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h
	dw 0、0、0、0、0、0、0、0、0、0、0、0、0、0、0、0
	;用 dw 定义 16 个字型数据，在程序加载后，将取得 16 个字的内存空间，存放这 16 个数据。
	;在后面的程序中将这段空间当作栈来使用
	
start:	mov ax,cs
		mov ss,ax
		mov sp,30h		;将设置栈顶 ss:sp 指向 cs:30
		
		mov bx,0
		mov cx,8
	s:  push cs:[bx]
		add bx,2
		loop s			;以上将代码段 0~15 的单元中的 8 个字型数据依次入栈
		
		mov bx,0
		mov cx,8
	s0: pop cs:[bx]
    	add bx,2
    	loop s0			;以上依次出栈 8 个字型数据到代码段 0~15 单元中
    	
    	mov ax,4c00h
    	int 21h
    	
codesg ends
end start				;指明程序的入口在 start 处
```



注意程序 6.3 中的指令：

mov ax,cs

mov ss,ax

mov sp,30h



我们要将 cs:10~cs:2F 的内存空间当作栈来用，初始状态下栈为空，所以 ss:sp 要指向栈底，则设置 ss:sp 指向 cs:30。

在代码段中定义了 16 个字型数据，它们的数值都是 0。这 16 个字型数据的值是多少，对程序来说没有意义。我们用 dw 定义 16 个数据，即在程序中写入了 16 个字型数据，而程序在加载后，将用 32 个字节的内存空间来存放它们。这段内存空间是我们所需要的，程序将它用作栈空间。可见，我们定义这些数据的最终目的是，通过它们取得一定容量的内存空间。所以我们在描述 ds 的作用时，可以说用它定义数据，也可以说用它开辟内存空间。比如对于：

dw 0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h

可以说，定义了 8 个字型数据，也可以说，开辟了 8 个字的内存空间，这段空间中每个字单元的数据依次是：0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h。因为它们最终的效果是一样的。





#### 6.3	将数据、代码、栈放入不同的段

在前面的内容中，我们在程序中用到了数据和栈，将数据、栈和代码都放到了一个段里面。我们在编程的时候要注意何处是数据，何处是栈，何处是代码。这样做显然有两个问题：

（1）把它们放到一个段中使程序显得混乱；

（2）前面程序中处理的数据很少，用到的栈空间也小，加上没有多长的代码，放到一个段里面没有问题。但如果数据、栈和代码需要的空间超过 64KB，就不能放在一个段中（一个段地容量不能大于 64KB，是我们在学习中所用的 8086 模式的限制，并不是所有的处理器都这样）。

所以，应该考虑用多个段来存放数据、代码和栈。

怎样做呢？我们用和定义代码段一样的方法来定义多个段，然后在这些段里面定义需要的数据，或通过定义数据来取得栈空间。具体做法如下面的程序所示，这个程序实现了和程序 6.3 一样的功能，不同之处在于它将数据、栈和代码放到了不同的段中。



##### 程序 6.4

```assembly
assume cs:code,ds:data,ss:stack
data segment
	dw 0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h
data ends

stack segment
	dw 0、0、0、0、0、0、0、0、0、0、0、0、0、0、0、0
stack ends

code segment
start:	mov ax,stack
		mov ss,ax
		mov sp,20h		;设置栈顶 ss:sp 指向 stack:20
		
		mov ax,data		
		mov ds,ax		;ds 指向 data 段
		
		mov bx,0		;ds:bx 指向 data 段中的第一个单元
		mov cx,8
		
	s:  push [bx]
		add bx,2
		loop s			;以上将 data 段 0~15 单元中的 8 个字型数据依次入栈
		
		mov bx,0
		mov cx,8
		
	s0: pop [bx]
    	add bx,2
    	loop s0			;以上依次出栈 8 个字型数据到 data 段 0~15 单元中
    	
    	mov ax,4c00h
    	int 21h
    	
code ends
end start				
```



下面对程序 6.4 做出说明。

（1）定义多个段的方法

这点，我们从程序中可明显地看出，定义一个段的方法和前面所讲的定义代码段的方法没有区别，只是对于不同的段，要有不同的段名。

（2）对段地址的引用

现在，程序中有多个段了，如何访问段中的数据呢？当然要通过地址，而地址是分为两部分的，即段地址和偏移地址。如何指明要访问的数据的段地址呢？在程序中，段名就相当于一个标号，它代表了段地址。所以指令 “mov ax,data” 的含义就是将名称为 “data” 的段的段地址送入 ax。一个段中的数据的段地址可由段名代表，偏移地址就要看它在段中的位置了。程序中 “data” 段中的数据 “0abch” 的地址就是：data:6。要将它送入 bx 中，就要用如下的代码：

mov ax,data

mov ds,ax

mov bs,ds:[6]

我们不能用下面的指令：

mov ds,data

mov bx,ds:[6]

其中指令 “mov ds,data” 是错误地，因为 8086CPU 不允许将一个数值直接送入段寄存器中。程序中对段名的引用，如指令 “mov ds,data” 中的 “data”，将被编译器处理为一个表示段地址的数值。

（3）“代码段‘、”数据段“、”栈段“ 完全是我们的安排

现在，我们以一个具体的程序来再次讨论一下所谓的 “代码段‘、”数据段“、”栈段“。在汇编源程序中，可以定义许多的段，比如在程序 6.4 中，定义了 3 个段，”code“、”data“ 和 "stack"。我们可以分别安排它们存放代码、数据和栈。那么我们如何让 CPU 按照我们这种安排来执行这个程序呢？下面来看看源程序中对这 3 个段所做的处理。

1. 我们在源程序中为这 3 个段起了具有含义的名称，用来放数据的段我们将其命名为 ”data“，用来放代码的段我们将其命名为 ”code“，用作栈空间的段命名为 ”stack“。

   这样命名了之后，CPU 是否就去执行 ”code“ 段中的内容，处理 ”data“ 段中的数据，将 ”stack“ 当作栈了呢？

   当然不是，我们这样命名，仅仅是为了使程序便于阅读。这些名称同 ”start“、”s“、”s0“ 等标号一样，仅在源程序中存在，CPU 并不知道它们。

2. 我们在源程序中用伪指令 ”assume cs:code,ds:data,ss:stack“ 将 cs、ds 和 ss 分别和 ”code“、”data“ 和 "stack" 段相连。这样做了之后。CPU 是否就会将 cs 指向 code，ds 指向 data，ss 指向 stack，从而按照我们的意图来处理这些段呢？

   当然也不是，要知道 assume 是伪指令，是由编译器执行的，也是仅在源程序中存在的信息，CPU 并不知道它们。我们不必深究 assume 的作用，只要知道需要用它将你定义的具有一定用途的段和相关的寄存器联系起来就可以了。

3. 若要 CPU 按照我们的安排行事，就要用机器指令控制它，源程序中的汇编指令是 CPU 要执行的内容。CPU 如何知道去执行它们？我们在源程序的最后用 ”end start“ 说明了程序的入口，这个入口将被写入可执行文件的描述信息，可执行文件中的程序被加载入内存后，CPU 的 CS:IP 被设置指向这个入口，从而开始执行程序中的第一条指令。标号 ”start“ 在 ”code“ 段中，这样 CPU 就将 code 段中的内容当作指令来执行了。我们在 code 段中，使用指令：

   mov ax,stack

   mov ss,ax

   mov sp,20h

   设置 ss 指向 stack，设置 ss:sp 指向 stack:20，CPU 执行这些指令后，将把 stack 段当作栈空间来用。CPU 若要访问 data 段中的数据，则可用 ds 指向 data 段，用其他的寄存器（如 bx）来存放 data 段中数据的偏移地址。

   

总之，CPU 到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，还是当作栈空间，完全是靠程序中具体的汇编指令，和汇编指令对 CS:IP、SS:SP、DS 等寄存器的设置来决定的。完全可以将程序 6.4 写成下面的样子，实现同样的功能。

```assembly
assume cs:b,ds:a,ss:c
a segment
	dw 0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h
a ends

c segment
	dw 0、0、0、0、0、0、0、0、0、0、0、0、0、0、0、0
c ends

b segment
d:		mov ax,c
		mov ss,ax
		mov sp,20h		;希望用 c 段当作栈空间，设置栈顶 ss:sp 指向 c:20
		
		mov ax,a	
		mov ds,ax		;希望用 ds:bx 访问 a 段中的数据，ds 指向 a 段
		
		mov bx,0		;ds:bx 指向 a 段中的第一个单元
		mov cx,8
		
	s:  push [bx]
		add bx,2
		loop s			;以上将 a 段 0~15 单元中的 8 个字型数据依次入栈
		
		mov bx,0
		mov cx,8
		
	s0: pop [bx]
    	add bx,2
    	loop s0			;以上依次出栈 8 个字型数据到 a 段 0~15 单元中
    	
    	mov ax,4c00h
    	int 21h
    	
b ends
end d					;d 处是要执行的的第一条指令，即程序的入口
```





### 第 7 章	更灵活的定位内存地址的方法

前面，我们用 [0]、[bx] 的方法，在访问内存的指令中，定位内存单元的地址。本章我们主要通过具体的问题来讲解一些更灵活的定位内存地址的方法和相关的编程方法。我们的讲解将通过具体的问题来进行。



#### 7.1	and 和 or 指令

首先，介绍两条指令 and 和 or，因为我们下面的例程中要用到它们。、

（1）and 指令：逻辑与指令，按位进行与运算。

例如指令：

mov al,01100011B

and  al,00111011B

执行后：al=00100011B

通过改指令可将操作对象的相应位设为 0，其他位不变。



（2）or 指令：逻辑或指令，按位进行或运算。

例如指令：

mov al,01100011B

or     al,00111011B

执行后：al=01111011B

通过该指令可将操作对象的相应位设为 1，其他位不变。



#### 7.2	关于 ASCII 码

略





#### 7.3	以字符形式给出的数据

我们可以在汇编程序中，用 '........' 的方式指明数据是以字符的形式给出的，编译器将把它们转化为相对应的 ASCII 码。



#### 7.4	大小写转换的问题

如果一个问题的解决方案，使我们陷入一种矛盾之中。那么，很可能是我们考虑问题的出发点有了问题，或是说，我们起初运用的规律并不合适。



#### 7.5	[bx+idata]

在前面，我们用 [bx] 的方式来指明一个内存单元，还可以用一种更为灵活的方式来指明内存单元：[bx+idata] 表示一个内存单元，它的偏移地址为 (bx)+idata（bx 中的数值加上 idata）。

我们看一下指令 mov ax,[bx+200] 的含义：

将一个内存单元的内容送入 ax，这个内存单元的长度为 2 个字节（字单元），存放一个字，偏移地址为 bx 中的数值加上 200，段地址在 ds 中。

数字化的描述为：(ax)=((ds)*16+(bx)+200)

该指令也可以写成如下格式（常用）：

mov ax,[200+bx]

mov ax,200[bx]

mov ax,[bx] .200





#### 7.6	用 [bx+idata] 的方式进行数组的处理

有了 [bx+idata] 这种表示内存单元的方式，我们就可以用更高级的结构来看待所要处理的数据。



c 语言：a[i]，b[i]

汇编语言：0[bx]，5[bx]

通过比较，我们可以发现，[bx+idata] 的方式为高级语言实现数组提供了便利机制。





#### 7.7	SI 和 DI

SI（Source Index）：源变址寄存器

DI（Destination Index）：目的变址寄存器

si 和 di 是 8086CPU 中和 bx 功能相近的寄存器，si 和 di 不能够分成两个 8 位寄存器来使用。下面的 3 组指令实现了相同的功能。

(1) mov bx,0

​	 mov ax,[bx]

(2) mov si,0

​     mov ax,[si]

(3) mov di,0

​	  mov ax,[di]

下面的 3 组指令实现了相同的功能。

(1) mov bx,0

​	  mov ax,[bx+123]

(2) mov si,0

​	  mov ax,[si+123]

(3) mov di,0

​	  mov ax,[di+123]





#### 7.8	[bx+si] 和 [bx+di]

略





#### 7.9	[bx+si+idata] 和 [bx+di+idata]

该指令也可以写成如下格式（常用）：

mov ax,[bx+200+si]

mov ax,[200+bx+si]

mov ax,200[bx] [si]

mov ax,[bx] .200[si]

mov ax,[bx] [si] .200





#### 7.10	不同的寻址方式的灵活应用

如果我们比较一下前面用到的几种定位内存地址的方法（可称为寻址方式），就可以发现：

(1) [idata] 用一个常量来表示地址，可用于直接定位一个内存单元；
(2) [bx] 用一个变量来表示内存地址，可用于间接定位一个内存单元；
(3) [bx+idata] 用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；
(4) [bx+si] 用两个变量表示地址；
(5) [bx+si+idata] 用两个变量和一个常量表示地址。

可以看到，从 [idata] 到 [bx+si+idata]，我们可以用更加灵活的方式来定位一个内存单元的地址。这使我们可以从更加结构化的角度来看待所要处理的数据。


我们在这里讨论的问题是，程序中经常需要进行数据的暂存，怎样做将更为合理。这些数据可能是寄存器中的，也可能是内存中的。我们可以用寄存器暂存它们，但是这不是一个一般化的解决方案，因为寄存器的数量有限，每个程序中可使用的寄存器都不一样。我们希望寻找一个通用的方案，来解决这种在编程中经常会出现的问题。

显然，我们不能选择寄存器，那么可以使用的就是内存了。可以考虑将需要暂存的数据放到内存单元中，需要使用的时候，再从内存单元中恢复。这样我们就需要开辟一段内存空间。

我们使用内存来暂存数据，这一点是确定了的，但是值得推敲的是，我们用怎样的结构来保存这些数据，而使得我们的程序更加清晰。**一般来说，在需要暂存数据的时候，我们都应该使用栈**。





### 第 8 章	数据处理的两个基本问题

本章对前面的所有内容是具有总结性的。我们知道，计算机是继续数据处理、运算的机器，那么有两个基本的问题就包含在其中：

（1）处理的数据在什么地方？

（2）要处理的数据有多长？

这两个问题，在机器指令中必须给以明确或隐含的说明，否则计算机就无法工作。本章中，我们就要针对 8086CPU 对这两个基本问题进行讨论。虽然讨论是在 8086CPU 的基础上进行的，但是这两个基本问题确实普遍的，对任何一个处理机都存在。

我们定义的描述性符号：reg 和 sreg。

为了描述上的简洁，在以后的课程中，我们将使用两个描述性的符号 reg 来表示一个寄存器，用 sreg 表示一个段寄存器。

reg 的集合包括：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di；

sreg 的集合包括：ds、ss、cs、es。



#### 8.1	bx、si、di 和 bp

前 3 个寄存器我们已经用过了，现在我们进行一下总结。

（1）在 8086CPU 中，只有这 4 个寄存器可以用在 “[...]” 中来进行内存单元的寻址。比如下面的指令都是正确的：

mov ax,[bx]

mov ax,[bx+si]

mov ax,[bx+di]

mov ax,[bp]

mov ax,[bp+si]

mov ax,[bp+di]

而下面的指令是错误的：

mov ax,[cx]

mov ax,[ax]

mov ax,[dx]

mov ax,[ds]



（2）在 [...] 中，这 4 个寄存器可以单个出现，或只能以 4 种组合出现：bx 和 si、bx 和 di、bp 和 si、bp 和 di。比如下面的指令是正确的：

mov ax,[bx]

mov ax,[si]

mov ax,[di]

mov ax,[bp]

mov ax,[bx+si]

mov ax,[bx+di]

mov ax,[bp+si]

mov ax,[bp+di]

mov ax,[bx+si+idata]

mov ax,[bx+di+idata]

mov ax,[bp+si+idata]

mov ax,[bp+di+idata]

下面的指令是错误的：

mov ax,[bx+bp]

mov ax,[si+di]



（3）只要在 [...] 中使用寄存器 bp，而指令中没有显性地给出段地址，段地址就默认在 ss 中。比如下面的指令。

mov ax,[bp]						含义：(ax)=((ss)*16+(bp))

mov ax,[bp+idata]			 含义：(ax)=((ss)*16+(bp)+idata)

mov ax,[bp+si]			   	含义：(ax)=((ss)*16+(bp)+(si))

mov ax,[bp+si+idata]		含义：(ax)=((ss)*16+(bp)+(si)+idata)





#### 8.2	机器指令处理的数据在什么地方

绝大部分机器指令都是进行数据处理的指令，处理大致可分为 3 类：读取、写入、运算。在机器指令这一层来讲，并不关心数据的值是多少，而关心**指令执行前一刻**，它将要处理的数据所在的位置。指令在执行前，所要处理的数据可以在 3 个地方：CPU 内部、内存、端口（端口将在后面的课程中进行讨论），比如表 8.1 中所列的指令。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE45.jpg"/> </div><br>
#### 8.3	汇编语言中数据位置的表达

在汇编语言中如何表达数据的位置？汇编语言中用 3 个概念来表达数据的位置。

（1）立即数（idata）

对于直接包含在机器指令中的数据（执行前在 CPU 的指令缓冲器中），在汇编语言中称为：立即数（idata），在汇编指令中直接给出。

例：mov ax,1

​		add bx,2000h

​		or	bx,00010000b

​		mov al,'a'



（2）寄存器

指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。

例：mov ax,bx

​		mov ds,ax

​		push bx

​		mov ds:[0],bx

​		push ds

​		mov ss,ax

​		mov sp,ax



（3）段地址（SA）和偏移地址（EA）

偏移地址(Offset Address = OA)，又叫有效地址(Effective Address = EA)。

指令要处理的数据在内存中，在汇编指令中可用 [X] 的格式给出 EA，SA 在某个段寄存器中。

存放段地址的寄存器可以是默认的，比如：

mov ax,[0]

mov ax,[di]

mov ax,[bx+8]

mov ax,[bx+si]

mov ax,[bx+si+8]

等指令，段地址默认在 ds 中：

mov ax,[bp]

mov ax,[bp+8]

mov ax,[bp+si]

mov ax,[bp+si+8]

等指令，段地址默认在 ss 中。

存放段地址的寄存器也可以是显性给出的，比如以下的指令。

mov ax,ds:[bp]				 含义：(ax)=((ds)*16+(bp))

mov ax,es:[bx]				 含义：(ax)=((es)*16+(bx))

mov ax,ss:[bx+si]			含义：(ax)=((ss)*16+(bx)+(si))

mov ax,cs:[bx+si+8]	    含义：(ax)=((cs)*16+(bx)+(si)+8)





#### 8.4	寻址方式

当数据存放在内存中的时候，我们可以用多种方式来给定这个内存单元的偏移地址，这种定位内存单元的方法一般被称为寻址方式。

8086CPU 有多种寻址方式，我们在前面的课程中都已经用到了，这里进行一下总结，如表 8.2 所列。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE46.jpg"/> </div><br>
#### 8.5	指令要处理的数据有多长

8086CPU 的指令，可以处理两种尺寸的数据，byte 和 word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。对于这个问题，汇编语言中用以下方法处理。

（1）通过寄存器指明要处理的数据的尺寸。

例如，下面的指令中，寄存器指明了指令进行的是字操作。

mov ax,1

mov bx,ds:[0]

mov ds,ax

mov ds:[0],ax

inc ax

add ax,1000



下面的指令中，寄存器指明了指令进行的是字节操作。

mov al,1

mov al,bl

mov al,ds:[0]

mov ds:[0],al

inc al

add al,100



（2）在没有寄存器名存在的情况下，用操作符 X ptr 指明内存单元的长度，X 在汇编指令中可以为 word 或 byte。

例如，下面的指令中，用 word ptr 指明了指令访问的内存单元是一个字单元。

mov word ptr ds:[0],1

inc word ptr [bx]

inc word ptr ds:[0]

add word ptr [bx],2

下面的指令中，用 byte ptr 指明了指令访问的内存单元是一个字节单元。

mov byte ptr ds:[0],1

inc byte ptr [bx]

inc byte ptr ds:[0]

add byte ptr [bx],2

在没有寄存器参与的内存单元访问指令中，用 word ptr 或 byte ptr 显性地指明所要访问地内存单元地长度是很必要的。否则，CPU 无法得知所要访问的单元是字单元，还是字节单元。假设我们用 Debug 查看内存的结果如下：

2000:	1000	FF	FF	FF	FF	FF	FF	....

那么指令：

mov ax,2000H

mov ds,ax

mov byte ptr [1000H],1

将使内存中的内容变为：

2000:	1000	01	FF	FF	FF	FF	FF	....

而指令：

mov ax,2000H

mov ds,ax

mov word ptr [1000H],1

将使内存中的内容变为：

2000:	1000	01	00	FF	FF	FF	FF	....



（3）其他方法

有些指令默认了访问的是字单元还是字节单元，比如，push [1000H] 就不用指明访问的是字单元还是字节单元，因为 push 指令只进行字操作。





#### 8.6	寻址方式的综合应用

下面我们通过一个问题来进一步讨论一下各种寻址方式的作用。

关于 DEC 公司的一条记录（1982 年）如下。

公司名称：DEC

总裁姓名：Ken Olsen

排名：137

收入：40（40 亿美元）

著名产品：PDP（小型机）

这些数据在内存中以图 8.1 所示的方式存放。

可以看到，这些数据被存放在 seg 段中从偏移地址 60H 起使的位置，从 seg:60 起始以 ASCII 字符的形式存储了 3 个字节的公司名称：从 seg:60+3 起始以 ASCII 字符的形式存储了 9 个字节的总裁姓名：从 seg:60+0C 起始存放了一个字型数据，总裁在富翁榜上的排名：从 seg:60+0E 起始存放了一个字型数据，公司的收入；从 seg:60+10 起使以 ASCII 字符的形式存储了 3 个字节的产品名称。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE47.jpg"/> </div><br>
我们可以看到，8086CPU 提供的如 [bx+si+idata] 的寻址方式为结构化数据的处理提供了方便。使得我们可以在编程的时候，从结构化的角度去看待所要处理的数据。从上面可以看到，一个结构化的数据包含了多个数据项，而数据项的类型又不相同，有的是字符型数据，有的是字节型数据，有的是数组（字符串）。一般来说，我们可以用 [bx+idata+si] 的方式来访问结构体中的数据。用 bx 定位整个结构体，用 idata 定位结构体中的某一个数据项，用 si 定位数组项中的每个元素。为此，汇编语言提供了更为贴切的书写方式，如：[bx].idata、[bx].idata[si]。

在 C 语言中我们看到，如：dex.cp[i]，dec 是一个变量名，指明了结构体的地址，cp 是一个名称，指明了数据项 cp 的地址，而 i 用来定位 cp 中的每一个字符。汇编语言中的做法是：bx.10h[si]。看一下，是不是很相似？





#### 8.7	div 指令

div 是除法指令，使用 div 做除法的时候应注意以下问题。

（1）除数：有 8 位和 16 位两种，在一个 reg 或内存单元中。

（2）被除数：默认放在 AX 或 DX 和 AX 中，如果除数为 8 位，被除数则为 16 位，默认在 AX 中存放；如果除数为 16 位，被除数为 32 位，在 DX 和 AX 中存放，DX 存放高 16 位，AX 存放低 16 位。

（3）结果：如果除数为 8 位，则 AL 存储除法操作的商，AH 存储除法操作的余数；如果除数为 16 位，则 AX 存储除法操作的商，DX 存储除法操作的余数。

格式如下：

div reg

div 内存单元

现在，我们可以用多种方法来表示一个内存单元了，比如下面的例子：

div byte ptr ds:[0]
    (al)=(ax)/((ds)*16+0)的商
    (ah)=(ax)/((ds)*16+0)的余数

div word ptr es:[0]
          （高十六位）+(低十六位)
    (ax)=[(dx)*10000H+(ax)]/((es)*16+0)的商
    (dx)=[(dx)*10000H+(ax)]/((es)*16+0)的余数

div byte ptr [bx+si+8]
(al)=(ax)/((ds)*16+(bx)+(si)+8)的商
        (ah)=(ax)/((ds)*16+(bx)+(si)+8)的余数

div word ptr [bx+si+8]

​		高十六位)+(低十六位)

​		(ax)=[(dx)*10000H+(ax)]/((ds)*16+(bx)+(si)+8)的商
​        (dx)=[(dx)*10000H+(ax)]/((ds)*16+(bx)+(si)+8)的余数





#### 8.8	伪指令 dd

前面我们用 ds 和 dw 定义字节型数据和字型数据。dd 是用来定义 dword（double word，双字）型数据的。比如：

data segment

​	db 1

​	dw 1

​	dd 1

data ends



在 data 段中定义了 3 个数据：

第一个数据为 01H，在 data:0 处，占 1 个字节；

第二个数据为 0001H，在 data:1 处，占 1 个字；

第三个数据为 00000001H，在 data:3 处，占 2 个字。





#### 8.9	dup

dup 是一个操作符，在汇编语言中同 db、dw、dd 等一样，也是由编译器识别处理的符号。它是和 db、dw、dd 等数据定义伪指令配合使用的，用来进行数据的重复。比如：

db 3 dup (0)

定义了 3 个字节，它们的值都是 0，相当于 db 0,0,0。

db 3 dup (0,1,2)

定义了 9 个字节，它们是 0、1、2、0、1、2、0、1、2，相当于 db 0,1,2,0,1,2,0,1,2。

db 3 dup ('abc','ABC')

定义了 18 个字节，它们是 'abcABCabcABCabcABC'，相当于 db 'abcABCabcABCabcABC'。

可见，dup 的使用格式如下。

db 重复的次数 dup (重复的字节型数据)

dw 重复的次数 dup (重复的字型数据)

dd 重复的次数 dup (重复的双字型数据)





### 第 9 章	转移指令的原理

可以修改 IP，或同时修改 CS 和 IP 的指令统称为转移指令。概括地讲，转移指令就是可以控制 CPU 执行内存中某处代码的指令。

8086CPU 的转移行为有以下几类。

- 只修改 IP 时，称为段内转移，比如：jmp ax。

- 同时修改 CS 和 IP 时，称为段间转移，比如：jmp 1000:0。


由于转移指令对 IP 的修改范围不同，段内转移又分为：短转移和近转移。

- 短转移 IP 的修改范围为 -128~127。
- 近转移 IP 的修改范围为 -32768~32767。

8086CPU 的转移指令分为以下几类。

- 无条件转移指令（如：jmp）
- 条件转移指令
- 循环指令（如：loop）
- 过程
- 中断

这些转移指令转移的前提条件可能不同，但转移的基本原理是相同的。我们在这一章主要通过深入学习无条件转移指令 jmp 来理解 CPU 执行转移指令的基本原理。



#### 9.1	操作符 offset

操作符 offset 在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。比如下面的程序：

```assembly
assume cs:codesg
codesg segment
	
	start:mov ax,offset start		;相当于 mov ax,0
		s:mov ax,offset s			;相当于 mov ax,3

codesg ends
end start
```



在上面的程序中，offset 操作符取得了标号 start 和 s 的偏移地址 0 和 3，所以指令：

mov ax,offset start 相当于指令 mov ax,0，因为 start 是代码段中的标号，它所标记的指令是代码段中的第一条指令，偏移地址为 0；

mov ax,offset s 相当于指令 mov ax,3，因为 s 是代码段中的标号，它所标记的指令是代码段中的第二条指令，第一条指令长度为 3 个字节，则 s 的偏移地址为 3。



##### 问题 9.1

有如下程序段，添写两条指令，使该程序在运行中将 s 处的一条指令复制到 s0 处。

```assembly
assume cs:codesg
codesg segment
    s:mov ax,bx
      mov si,offset s		;mov ax,bx 的机器码占两个字节
      mov di,offset s0
      
    
   s0:nop					;nop 的机器码占一个字节
   	  nop
   	  
codesg ends
end s
```



思考后看分析。

分析：

（1）s 和 s0 处的指令所在的内存单元的地址是多少？cs:offset s 和 cs:offset s0。

（2）将 s 处的指令复制到 s0 处，就是将 cs:0ffset s 处的数据复制到 cs:0ffset s0 处。

（3）段地址已知在 cs 中，偏移地址 offset s 和 offset s0 已经送入 si 和 di 中。

（4）要复制的数据有多长？mov ax,bx 指令的长度为两个字节，即 1 个字。

程序如下。

```assembly
assume cs:codesg
codesg segment
    s:mov ax,bx
      mov si,offset s		;mov ax,bx 的机器码占两个字节
      mov di,offset s0
      mov ax,cs:[si]
      mov cs:[di],ax	
   s0:nop					;nop 的机器码占一个字节
   	  nop
   	  
codesg ends
end s
```





#### 9.2	jmp 指令

jmp 为无条件转移指令，可以只修改 IP，也可以同时修改 CS 和 IP。

jmp 指令要给出两种信息：

（1）转移的目的地址

（2）转移的距离（段间转移、段内短转移，段内近转移）

不同的给出目的地址的方法，和不同的转移位置，对应有不同格式的 jmp 指令。下面的几节内容中，我们以给出目的地址的不同方法为主线，讲解 jmp 指令的主要应用格式和 CPU 执行转移指令的基本原理。





#### 9.3	根据位移进行转移的 jmp 指令

jmp short 标号（转到标号处执行指令）

这种格式的 jmp 指令实现的是段内短转移，它对 IP 的修改范围为 -128~127，也就是说，它向前转移时可以最多越过 128 个字节，向后转移可以最多越过 127 个字节。jmp 指令中的 “short” 符号，说明指令进行的是短转移。jmp 指令中的 “标号” 是代码段中的标号，指明了指令要转移的目的地，转移指令结束后，CS:IP 应该指向标号处的指令。

比如：



##### 程序 9.1

```assembly
assume cs:codesg
codesg segment

start:mov ax,0
	  jmp short s
	  add ax,1
    s:inc ax

codesg ends

end start
```



上面的程序执行后，ax 中的值为 1，因为执行 jmp short s 后，越过了 add ax,1，IP 指向了标号 s 处的 inc ax。也就是说，程序只进行了一次 ax 加 1 操作。

汇编指令 jmp short s 对应的机器指令应该是什么样的呢？我们先看一下别的汇编指令和其对应的机器指令。

汇编指令						 机器指令

mov ax,0123h			   B8 23 01

mov ax,ds:[0123h]		A1 23 01

push ds:[0123h]			FF 36 23 01

可以看到，在一般的汇编指令中，汇编指令中的 idata(立即数)，不论它是表示一个数据还是内存单元的的偏移地址，都会在对应的机器指令中出现，因为 CPU 执行的是机器指令，它必须要处理这些数据或地址。

现在我们在 Debug 中将程序 9.1 翻译成为机器码，看到的结果如图 9.1 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE48.jpg"/> </div><br>
对照汇编源程序，我们可以看到，Debug 将 jmp short s 中的 s 表示为 inc ax 指令的偏移地址 8，并将 jmp short s 表示为 jmp 0008，表示转移到 cs:0008 处。这一切似乎合理，可是当我们查看 jmp short s 或是 jmp 0008 所对应的机器码，却发现了一些问题。

jmp 0008(Debug 中的表示)或 jmp short s(汇编语言中的表示)所对应的机器码为 EB03，注意，这个机器码中竟不包括转移目的地址，这意味着，CPU 在执行 EB 03 的时候，并不知道转移的目的地址。那么，CPU 根据什么进行转移呢？它知道转移到哪里呢？

令人奇怪的是，汇编指令 jmp short s 中，明明是带有转移的目的地址(由标号 s 表示)的，可翻译成机器指令后，怎么目的地址就没了呢？没有了目的地址，CPU 如何知道转移到哪里呢？

我们把程序 9.1 改写一下，变成下面这样：



##### 程序 9.2

```assembly
assume cs:codesg
codesg segment

start:mov ax,0
	  mov bx,0
	  jmp short s
	  add ax,1
    s:inc ax

codesg ends

end start
```



我们在 Debug 中将程序 9.2 翻译成为机器码，看到的结果如图 9.2 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE49.jpg"/> </div><br>
比较一下程序 9.1 和 9.2 用 Debug 查看的结果，注意，两个程序中的 jmp 指令都要使 IP 指向 inc ax 指令，但是程序 1 的 inc ax 指令的偏移地址为 8，而程序 2 的 inc ax 指令的偏移地址为 000BH。我们再来看两个程序中的 jmp 指令所对应的机器码，都是 **EB 03**。这说明 **CPU 在执行 jmp 指令的时候并不需要转移的目的地址**。两个程序中的 jmp 指令的转移目的地址并不一样，一个是 cs:0008，另一个是 cs:000B，如果机器指令中包含了转移的目的地址的话，那么它们对应的机器码应该是不同的。可是它们对应的机器码都是 EB 03，这说明在机器指令中并不包含转移的目的地址。如果机器指令中不包含目的地址的话，那么也就是说，CPU 不需要这个目的地址就可以实现对 IP 的修改。

CPU 不是神仙，它只能处理你提供给它的东西，jmp 指令的机器码中不包含转移的目的地址，那么，CPU 如何知道将 IP 改为多少呢？所以，在 jump 指令的机器码中，一定包含了某种信息，使得 CPU 可以将它当作修改 IP 的依据。这种信息是什么呢？我们一步步地分析。

我们先简单回忆一下 CPU 执行指令地过程(如果你需要过多的回忆，可以复习一下 2.10 节的内容)。

（1）从 CS:IP 指向内存单元读取指令，读取的指令进入指令缓冲器；

（2）(IP)=(IP)+所读取指令的长度，从而指向下一条指令；

（3）执行指令。转到 1，重复这个过程。

按照这个步骤，我们参照图 9.2 看一下，程序 9.2 中 jmp short s 指令的读取和执行过程：

（1）(cs)=0BBDH，(IP)=0006H，CS:IP 指向 EB 03(jmp short s 的机器码)；

（2）读取指令码 EB 03 进入指令缓冲器；

（3）(IP)=(IP)+所读取指令的长度=(IP)+2=0008H，CS:IP 指向 add ax,1；

（4）CPU 执行指令缓冲器中的指令 EB 03；

（5）指令 EB 03 执行后，(IP)=000BH，CS:IP 指向 inc ax。

从上面的过程中我们看到，CPU 将指令 EB 03 读入后，IP 指向了下一条指令，即 CS:0008 处的 add ax,1，接着指向 EB 03。如果 EB 03 没有对 IP 进行修改的话，那么，接下来 CPU 将指向 add ax,1，可是，CPU 执行的 EB 03 却是一条修改 IP 的转移指令，执行后 (IP)=000BH，CS:IP 指向 inc ax，CS:0008 处的 add ax,1 没有被执行。

CPU 在执行 EB 03 的时候是根据什么修改的 IP，使其指向目标指令呢？就是根据指令码中的 03。注意，要专一的目的地址是 CS:000B，而 CPU 执行 EB 03 时，当前的 (IP)=0008H，如果将当前的 IP 值加 3，使 (IP)=000BH，CS:IP 就可指向目标指令。在转移指令 EB 03 中并没有告诉 CPU 要转移的目的地址，却告诉了 CPU 要转移的位移，即将当前的 IP 向后移动 3 个字节。因为程序 1、2 中的 jmp 指令转移的位移相同，都是向后 3 个字节，所以它们的机器码都是 EB 03。

原来如此，在 "jmp short 标号" 指令所对应的机器码中，并不包含转移的目的地址，而包含的是转移的位移。这个位移，是编译器根据汇编指令中的 “标号” 计算出来的，具体的计算方法如图 9.3 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE50.jpg"/> </div><br>
实际上，“jmp short 标号” 的功能为：(IP)=(IP)+8 位位移。

（1）8 位位移=标号处的地址-jmp 指令后的第一个字节的地址；

（2）short 指明此处的位移为 8 位位移；

（3）8 位位移的范围为 -128~127，用补码表示(如果你对补码还不了解，请阅读附注 2);

（4）8 位位移由编译程序在编译时算出。

还有一种和 “jmp short 标号” 功能相近的指令格式，jmp near ptr 标号，它实现的是段内近转移。

“jmp near ptr 标号” 的功能为：(IP)=(IP)+16 位位移。

（1）16 位位移=标号处的地址-jmp 指令后的第一个字节的地址；

（2）near ptr 指明此处的位移为 16 位位移，进行的是段内近转移；

（3）16 位位移的范围为 -32768~32767，用补码表示；

（4）16 位位移由编译程序在编译时算出。



#### 9.4	转移的目的地址在指令中的 jmp 指令

前面讲的 jmp 指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前 IP 的转移位移。

“jmp far ptr 标号” 实现的是段间转移，又称为远转移。功能如下：

(CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址。

far ptr 指明了指令用标号的段地址和偏移地址修改 CS 和 IP。

看下面的程序：



##### 程序 9.3

```assembly
assume cs:codesg
codesg segment
 start:mov ax,0
 	   mov bx,0
       jmp far ptr s
       db 256 dup (0)
     s:add ax,1
       inc ax
       
codesg ends

end start
```



在 Debug 钟将程序 9.3 翻译为机器码，看到的结果如图 9.4 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE51.jpg"/> </div><br>
如图 9.4 所示，源程序中的 db 256 dup (0)，被 Debug 解释为相应的若干条汇编指令。这不是关键，关键是，我们要注意一下 jmp far ptr s 所对应的机器码：EA 0B 01 BD 0B，其中包含转移的目的地址。”0B 01 BD 0B“ 是目的地址在指令中的存储顺序，高地址的 ”BD 0B“ 是转移的段地址：0BBDH，低地址的 ”0B 01“ 是偏移地址：010BH。

对于 ”jmp X 标号“ 格式的指令的深入分析请参看附注 3。



#### 9.5	转移地址在寄存器中的 jmp 指令

指令格式：jmp 16 位 reg

功能：(IP)=(16 位 reg)

这种指令在 2.11 节中已经讲过。



#### 9.6	转移地址在内存中的 jmp 指令

转移地址在内存中的 jmp 指令有两种格式：

（1）jmp word ptr 内存单元地址(段内转移)

功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。

内存单元地址可用寻址方式的任一格式给出。

比如，下面的指令：

mov ax,0123H

mov ds:[0],ax

jmp word ptr ds:[0]

执行后，(IP)=0123H。

又比如，下面的指令：

mov ax,0123H

mov [bx],ax

jmp word ptr [bx]

执行后，(IP)=0123H



（2）jmp dword ptr 内存单元地址(段间转移)

功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。

(CS)=(内存单元地址+2)

(IP)=(内存单元地址)

内存单元地址可用寻址方式的任一格式给出。

比如，下面的指令：

mov ax,0123H

mov ds:[0],ax

mov word ptr ds:[2],0

jmp dword ptr ds:[0]

执行后，(cs)=0，(IP)=123H，CS:IP 指向 0000:0123

又比如，下面的指令：

mov ax,0123H

mov [bx],ax

mov word ptr [bx+2],0

jmp dword ptr [bx]

执行后，(CS)=0，(IP)=0123H，CS:IP 指向 0000:0123



##### 检测点 9.1

（1）程序如下。

```assembly
assume cs:code
data segment
	?
data ends

code segment
  start:mov ax,data
  	    moc ds,ax
  	    mov bx,0
  	    jmp word ptr [bx+1]

code ends
end start
```



若要使程序中的 jmp 指令执行后，CS:IP 指向程序的第一条指令，在 data 段中应该定义哪些数据？

程序分析：

 1）这个指令 jmp word ptr [bx+1] 是一个段内近转移，它只是修改了 ip 的值。它的转移地址在内存中。明确：[bx+1] 在此例子中是指的 data 段的第二个字节。

 2）我们发现 ds：bx 指向了 data 段，word ptr [bx+1] 指向的是 data 段中的第二个字节开始的字单元，也就是说它所指向的该字单元的内容。这个内容就是jmp跳转的偏移地址。

 3）word ptr [bx+1] 指的是一个字单元，也就是说是 2 个字节，也就是说在 data 段中是第 2 和第 3 个字节，如果 jmp 转移到程序第一条指令，也就是说 ip 的值应为：00 00 即可；我们要保证这二个字节的值是 00 00 就行。

 4）要想 jmp 跳转到 start 标号处，它的 ip 值是 offset start 即可（在汇编语言层面我们也不必关心它们代表的具体 ip 值是多少）；也就是说：（ds：[bx+1]）==offset start，那么在 data 段中定义的第二个字节必须是 offset start。至于 offset start 具体代表的二进制码是什么，那是编译器的事情。

 5）第一个字节，你随意定义成什么都行。

 这个结果是多个:

 dw 00xxH, offset start         ;xx 代表任意数值（一个字节的）

 **讲解：此时借用的是 00xxH 的高位字节值，00**

 db x,0,0                       ;x代表任意数值（一个字节的）

 dd 0                             ;2个字的内存单元，00 00 00 00

 db 3 dup (0)

 dw 2 dup (0)

 dd 0



简单来说就是，只要 ds:[bx+1] 起始地址的两个字节为 0 就可以了。



（2）程序如下。

```assembly
assume cs:code

data segment
  dd 12345678H
data ends

code segment

  start:mov ax,data
  		mov ds,ax
  		mov bx,0
  		mov [bx],
  		mov [bx+2],
  		jmp dword ptr ds:[0]
  		
code ends

end start
```



补全程序，使 jmp 指令执行后，CS:IP 指向程序的第一条指令。

[bx]=offset start

​		 word ptr 0

  	   0000H

​		 bx

​		 0



[bx+2]=cs

​			  code



（3）用 Debug 查看内存，结果如下：

​	2000:1000 BE 00 06 00 00 00 ...

  则此时，CPU 执行指令：

 	mov ax,2000H

​	 mov es,ax

​	 jmp  dword ptr es:[1000H]

后，(cs)=？，(IP)=？

(cs)= 0006H ，(ip)= 00BEH





#### 9.7	jcxz 指令

jcxz 指令为有条件转移指令，所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对 IP 的修改范围都为：-128~127。

指令格式：jcxz 标号(如果(cx)=0，转移到标号处执行。)

操作：当 (cx)=0 时，(IP)=(IP)+8 位位移；

8 位位移=标号处的地址-jcxz 指令后的第一个字节的地址；

8 位位移的范围为 -128~127，用补码表示；

8 位位移由编译程序在编译时算出。

当 (cx)≠0 时，什么也不做(程序向下执行)。

我们从 jcxz 的功能中可以看出，“jcxz 标号” 的功能相对于：

if((cx)==0) jmp short 标号；

（这种用 C 语言和汇编语言进行的综合描述，或许能使你对有条件转移指令理解得更加清楚。）



##### 监测点 9.2

补全编程，利用 jcxz 指令，实现在内存 2000H 段中查找第一个值为 0 的字节，找到后，将它的偏移地址存储在 dx 中。

```assembly
assume cs:code
code segment
  start:mov ax,2000H
  		mov ds,ax
  		mov bx,0
  	  s:
      
      
      
        jmp short s
     ok:mov dx,bx
     	mov ax,4c00h
        int 21h
code ends
end start
```



mov cl,[bx]

mov ch,0

jcxz ok 

inc bx





#### 9.8	loop 指令

loop 指令为循环指令，所有的循环指令都是**短转移**，在对应的机器码中包含转移的位移，而不是目的地址。对 IP 的修改范围都为： -128~127。

指令格式：loop 标号 ((cx)=(cx)-1)，如果((cx)≠0，转移到标号处执行。)

操作：

（1）(cx)=(cx)-1

（2）如果 (cx)≠0，(IP)=(IP)+8 位位移。

8 位位移=标号处的地址-loop 指令后的第一个字节的地址；

8 位位移的范围为 -128~127，用补码表示；

8 位位移由编译程序在编译时算出。

如果(cx)=0，什么也不做(程序向下执行)。

我们从 loop 的功能中可以看出，“loop 标号” 的功能相当于。

(cx)--;

if((cx)≠0) jmp short 标号;



##### 监测点 9.3

补全编程，利用 loop 指令，实现在内存 2000H 段中查找第一个值为 0 的字节，找到后，就将它的偏移地址存储在 dx 中。

```assembly
assum cs:code
code segment
  start:mov ax,2000H
		mov ds,ax
		mov bx,0
	  s:mov cl,[bx]
        mov ch,0
        
        inc bx
        loop s
     ok:dex bx		;dec 指令的功能和 inc 相反，dec bx 进行的操作为：(bx)=(bx)-1
        mov dx,bx
        mov ax,4c00h
        int 21h
code ends
end start
```

 

inc cx





#### 9.9	根据位移进行转移的意义

前面我们讲到：

jmp short 标号

jmp near ptr 标号

jcxz 标号

loop 标号

等几种汇编指令，它们对 IP 的修改是根据转移目的地址和转移起始地址之间的位移来进行的。在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移。

这种设计，方便了程序段在内存中的浮动装配。

例如：

​	汇编指令			机器代码

​	mov cx,6			B9 06 00

​	mov ax,10h	   B8 10 00

 s:add ax,ax		   01 c0

​	loop s				 E2 FC

这段程序装在内存中的不同位置都可正确执行，因为 loop s 在执行时只涉及 s 的位移(-4，前移 4 个字节，补码表示为 FCH)，而不是 s 的地址。如果 loop s 的机器码中包含的是 s 的地址，则就对程序段在内存中的偏移地址有了严格的限制，因为机器码中包含的是 s 的地址，如果 s 处的指令不在目的地址处，程序的执行就会出错。而 loop s 的机器码中包含的是转移的位移，就不存在这个问题了，因为，无论 s 处的指令的实际地址是多少，loop 指令的转移位移是不变的。



#### 9.10	编译器对转移位移超界的检测

注意，根据位移进行转移的指令，它们的转移范围受到转移位移的限制，如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错。

比如，下面的程序将引起编译错误：

```assembly
assume cs:code
code segment
  start:jmp short s
  		db 128 dup (0)
  	  s:mov ax,0fffh
code ends
end start
```



jmp short s  的转移范围是 -128~127，IP 最多向后移动 127 个字节。

注意，我们在第 2 章中讲到的形如 “jmp 2000:0100” 的转移指令，是在 Debug 中使用的汇编指令，汇编编译器并不认识。如果在源程序中使用，编译时也会报错。



#### 实验 8	分析一个奇怪的程序

分析下面的程序，在运行前思考：这个程序可以正确返回吗？

运行后再思考：为什么是这种结果？

通过这个程序加深对相关内容的理解。

```assembly
assume cs:codesg
codesg segment
		mov ax,4c00h
		int 21h
	
start:	mov ax,0
	s:	nop
		nop
		
		mov di,offset s
		mov si,offset s2
		mov ax,cs:[si]
		mov cs:[di],ax
		
	s0:	jmp short s
    
    s1: mov ax,0
    	int 21h
    	mov ax,0
    	
    s2:	jmp short s1
    	nop
    	
codesg ends
end start
```











### 第 10 章	CALL 和 RET 指令

call 和 ret 指令都是转移指令，它们都修改 IP，或同时修改 CS 和 IP。它们经常被共同用来实现子程序的设计。这一章，我们讲解 call 和 ret 指令的原理。



#### 10.1	ret 和 retf

ret 指令用栈中的数据，修改 IP 的内容，从而实现近转移；

retf 指令用栈中的数据，修改 CS 和 IP 的内容，从而实现远转移。

CPU 执行 ret 指令时，进行下面两步操作：

（1）(IP)=((ss)*16+(sp))

（2）(sp)=(sp)+2

CPU 执行 retf 指令时，进行下面 4 步操作：

（1）(IP)=((ss)*16+(sp))

（2）(sp)=(sp)+2

（3）(CS)=((ss)*16+(sp))

（4）(sp)=(sp)+2

可以看出，如果我们用汇编语法来解释 ret 和 retf 指令，则：

CPU 执行 ret 指令时，相当于进行：

pop IP

CPU 执行 retf 指令时，相当于进行：

pop IP

pop CS

例：

下面的程序中，ret 指令执行后，(IP)=0，CS:IP 指向代码段的第一条指令。

```assembly
assume cs:code

stack segment
  db 16 dup (0)
stack ends

code segment
		mov ax,4c00h
		int 21h	
start:	mov ax,stack
		mov ss,ax
		mov sp,16
		mov ax,0
		push ax
		mov bx,0
		ret
code ends

end start
```



下面的程序中，retf 指令执行后，CS:IP 指向代码段的第一条指令。

```assembly
assume cs:code

stack segment
  db 16 dup (0)
stack ends

code segment
		mov ax,4c00h
		int 21h
start:	mov ax,stack
		mov ss,ax
		mov sp,16
		mov ax,0
		push cs
		push ax
		mov bx,0
		retf
code ends

end start
```



##### 检测点 10.1

补全程序，实现从内存 1000:0000 处开始执行指令。

```assembly
assume cs:code

stack segment
  db 16 dup (0)
stack ends

code segment
  start:mov ax,stack
		mov ss,ax
		mov sp,16
		mov ax,1000H
		push ax
		mov ax,0
		push ax
		retf
code ends

end start
```



#### 10.2	call 指令

CPU 执行 call 指令时，进行两步操作：

（1）将当前的 IP 或 CS 和 IP 压入栈中；

（2）转移。

call 指令不能实现短转移，除此之外，call 指令实现转移的方法和 jmp 指令的原理相同，下面的几个小节中，我们以给出转移目的地址的不同方法为主线，讲解 call 指令的主要应用格式。



#### 10.3	依据位移进行转移的 call 指令

call 标号(将当前的 IP 压栈后，转到标号处执行指令)

CPU 执行此种格式的 call 指令时，进行如下的操作：

（1）(sp)=(sp)-2

​		  ((ss)*16+(sp))=(IP)

（2）(IP)=(IP)+16 位位移。

16 位位移=标号处的地址-call 指令后的第一个字节的地址；

16 位位移的范围为-32768~32767，用补码表示；

16 位位移由编译程序在编译时算出。

从上面的描述中，可以看出，如果我们用汇编语法来解释此种格式的 call 指令，则：

CPU 执行 ”call 标号“ 时，相当于进行：

push IP

jmp near ptr 标号



##### 检测点 10.2

下面的程序执行后，ax 中的数值为多少？

内存地址    机器码         汇编指令     执行后情况

1000:0       b8 00 00     mov ax,0     ax=0 ip指向1000:3

1000:3       e8 01 00     call s      	  pop ip ip指向1000:6

1000:6       40                inc ax

1000:7       58        	  s:pop ax  



指令缓冲器读取一条指令后，IP 中的值自动增加，以使 CPU 可以读取下一条指令。

ax=6



#### 10.4	转移的目的地址在指令中的 call 指令

前面讲的 call 指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前 IP 的转移位移。

”call far ptr 标号“ 实现的是段间转移。

CPU 执行此种格式的 call 指令时，进行如下的操作。

（1）(sp)=(sp)-2

​		 ((ss)*16+(sp))=(CS)

​		 (sp)=(sp)-2

​		 ((ss)*16+(sp))=(IP)

（2）(CS)=标号所在段的段地址

​		  (IP)=标号在段中的偏移地址

从上面的描述中而可以看出，如果我们用汇编语法来解释此种格式的 call 指令，则：

CPU 执行 ”call far ptr 标号“ 时，相当于进行：

push CS

push IP

jmp far ptr 标号



##### 检测点 10.3

下面的程序执行后，ax 中的数值为多少？

内存地址		机器码						汇编指令

1000:0		    b8 00 00					mov ax,0

1000:3			9A 09 00 00 10	 	call far ptr s

1000:8			40							   inc ax

1000:9			58							s:pop ax

​															add ax,ax

​															pop bx

​															add ax,bx

0008H

0010H

1000H

1010H



#### 10.5	转移地址在寄存器中的 call 指令

指令格式：call 16 位 reg

功能：

(sp)=(sp)-2

((ss)*16+(sp))=(IP)

(IP)=(16位 reg)

用汇编语法来解释此种格式的 call 指令，CPU 执行 ”call 16 位 reg“ 时，相当于进行：

push IP

jmp 16 位 reg



##### 检测点 10.4

下面的程序执行后，ax 中的数值为多少？

内存地址		机器码					汇编指令

1000:0		    b8 06 00				mov ax,6

1000:3			ff d0	 				  call ax

1000:5			40						   inc ax

1000:6											mov bp,sp

​														add ax,[bp]

sp=5

ax=6

ax=000BH





#### 10.6	转移地址在内存中的 call 指令

转移地址在内存中的 call 指令有两种格式。

（1）call word ptr 内存单元地址

用汇编语法来解释此种格式的 call 指令，则：

CPU 执行 ”call word ptr 内存单元地址“ 时，相当于进行：

push IP

jmp word ptr 内存单元地址

比如，下面的指令：

mov sp,10h

mov ax,0123h

mov ds:[0],ax

call word ptr ds:[0]

执行后，(IP)=0123H，(sp)=0EH。



（2）call dword ptr 内存单元地址

用汇编语法来解释此种格式的 call 指令，则：

CPU 执行 ”call dword ptr 内存单元地址“ 时，相当于进行：

push CS

push IP

jmp dword ptr	内存单元地址

比如，下面的指令：

mov sp,10h

mov ax,0123h

mov ds:[0],ax

mov word ptr ds:[2],0

call dword ptr ds:[0]

执行后，(cs)=0，(IP)=0123H，(sp)=0CH。



##### 检测点 10.5

（1）下面的程序执行后，ax 中的数值为多少？（注意：用 call 指令的原理来分析，不要在 Debug 中单步跟踪来验证你的结论。对于此程序，在 Debug 中单步跟踪的结果，不能代表 CPU 的实际执行结果。）

```assembly
assume cs:code

stack segment
  dw 8 dup (0)
stack ends

code segment
  start:mov ax,stack
		mov ss,ax
		mov sp,16
		mov ds,ax
		mov ax,0
		call word ptr ds:[0EH]
		inc ax,
		inc ax,
		inc ax,
		mov ax,4c00h
		int 21h
code ends
end start
```



该题中的程序的数据段和栈段使用了同一段内存 , 也就是说 ds 和 ss 是相同的
执行到 call word ptr ds:[0EH] 的时候 , 具体的流程如下 : 

1. CPU 取指令 : (call word ptr ds:[0EH])
2. ip 自增上述指令的长度 , 指向了下一条指令 (inc ax)
3. 开始执行该指令
    3.1. push ip ; 将 ip 压入栈 , 也就是 : ss:[0EH] 保存 ip 的低 8 位 , ss:[0FH] 保存高 8 位
    3.2. jmp ds:[0EH] ( (ip) = ds:[0EH] , 也就是说 , 程序又从 ds:[0EH] 中取出数据赋值给 ip , 然后继续执行 )
4. 现在其实就开始执行 ip 之前保存的地址的指令了 , 也就是三个 inc ax
5. 因此最终 ax 值为 3  



（2）下面的程序执行后，ax 和 bx 中的数值为多少？

```assembly
assume cs:code
data segment
  dw 8 dup (0)
data ends
code segment
  start:mov ax,data
		mov ss,ax
		mov sp,16
		mov word ptr ss:[0],offset s
		mov ss:[2],cs
		call dword ptr ss:[0]
		nop
	  s:mov ax,offset s
	  	sub ax,ss:[0cH]
	  	mov bx,cs
	  	sub bx,ss:[0eH]
	  	mov ax,4c00h
	  	int 21h
code ends
end start
```



0013H

cs

push cs

push ip

ax=0013H

ax=1

bx=0





#### 10.7	call 和 ret 的配合使用

前面，我们已经分别学习了 ret 和 call 指令的原理。现在来看一下，如何将它们配合使用来实现子程序的机制。



##### 问题 10.1

下面程序返回前，bx 中的值是多少？

```assembly
assume cs:code
code segment
 start:mov ax,1
 	   mov cx,3
       call s
       mov bx,ax
       mov ax,4c00h
       int 21h
     s:add ax,ax
       loop s
       ret
code ends
end start
```

**分析：**

我们来看一下 CPU 执行这个程序的主要过程。

（1）CPU 将 call s 指令的机器码读入，IP 指向了 call s 后的指令 mov bx,ax，然后 CPU 执行 call s 指令，将当前的 IP 值(指令 mov bx,ax 的偏移地址)压栈，并将 IP 的值改变为标号 s 处的偏移地址；

（2）CPU 从标号 s 处开始执行指令，loop 循环完毕后，(ax)=8;

（3）CPU 将 ret 指令的机器码读入，IP 指向了 ret 指令后的内存单元，然后 CPU 执行 ret 指令，从栈中弹出一个值(即 call s 先前压入的 mov bx,ax 指令的偏移地址)送入 IP 中。则 CS:IP 指向指令 mov bx,ax；

（4）CPU 从 mov bx,ax 开始执行指令，直至完成。

程序返回前，(bx)=8。可以看出，从标号 s 到 ret 的程序段的作用是计算 2 的 N 次方，计算前，N 的值由 cx 提供。

我们再来看下面的程序：

略。

从上面的讨论中我们发现，可以写一个具有一定功能的程序段，我们称其为子程序，在需要的时候，用 call 指令转去执行。可是执行完子程序后，如何让 CPU 接着 call 指令向下执行？call 指令转去执行子程序之前，call 指令后面的指令的地址将存储在栈中，所以可以在子程序的后面使用 ret 指令，用栈中的数据设置 IP 的值，从而转到 call 指令后面的代码处继续执行。

这样，我们可以利用 call 和 ret 来实现子程序的机制。子程序的框架如下。

标号：

​		指令

​		ret

具有子程序的源程序的框架如下。

```assembly
assume cs:code
code segment
	main: :
		  :
		  call sub1		;调用子程序 sub1
		  :
		  :
		  mov ax,4c00h
		  int 21h
	sub1: :				;子程序 sub1 开始
    	  :
    	  call sub2		;调用子程序 sub2
    	  :
    	  :
    	  ret			;子程序返回
    	  
    sub2: :				;子程序 sub2 开始
    	  :				
    	  :				
    	  ret			;子程序返回
code ends
end main
```













#### 10.8	mul 指令

略





#### 10.9	模块化程序设计

从上面我们看到，call 与 ret 指令共同支持了汇编语言编程中的模块化设计。在实际编程中，程序的模块化是必不可少的。因为现实的问题比较复杂，对现实问题进行分析时，把它转化成为相互联系、不同层次的子问题，是必须的解决方法。而 call 与 ret 指令对这种分析方法提供了程序实现上的支持。利用 call 和 ret 指令，我们可以用简捷的方法，实现多个相互联系、功能独立的子程序来解决一个复杂的问题。

下面的内容中，我们来看一下子程序设计中的相关问题和解决方法。



#### 10.10	参数和结果传递的问题

子程序一般都要根据提供的参数处理一定的事务，处理后，将结果(返回值)提供给调用者。其实，我们讨论参数和返回值传递的问题，实际上就是在探讨，应该如何存储子程序需要的参数和产生的返回值。

比如，设计一个子程序，可以根据提供的 N，来计算 N 的 3 次方。

这里面就有两个问题：

（1）将参数 N 存储在什么地方？

（2）计算得到的数值，存储在什么地方？

很显然，可以用寄存器来存储，可以将参数放到 bx 中；因为子程序中要计算 N* N*N，可以使用多个 mul 指令，为了方便，可将结果放到 dx 和 ax 中。子程序如下。

```assembly
;说明：计算 N 的 3 次方
;参数：(bx)=N
;结果：(dx:ax)=n^3

cube:mov ax,bx
	 mul bx
	 mul bx
	 ret
```



注意，我们在编程的时候要注意形成良好的风格，对于程序应有详细的注释。子程序的注释信息应该包含对子程序的功能、参数和结果的说明。因为今天写的子程序，以后可能还会用到；自己写的子程序，也很可能要给别人使用，所以一定要有全面的说明。

用寄存器来存储参数和结果是最常使用的方法。对于存放参数的寄存器和存放结果的寄存器，调用者和子程序的读写操作恰恰相反：调用者将参数送入参数寄存器，从结果寄存器中取到返回值：子程序从参数寄存器中取到参数，将返回值送入结果寄存器。

编程，计算 data 段中第一组数据的 3 次方，结果保存在后面一组 dword 单元中。

```assembly
assume cs:code
data segment
  dw 1,2,3,4,5,6,7,8
  dd 0,0,0,0,0,0,0,0
data ends

code segment
  start:mov ax,data
  		mov ds,ax
  		mov si,0			;ds:di 指向第一组 word 单元
  		mov di,16			;ds:di 指向第二组 dword 单元
  		
  		mov cx,8
  	  s:mov bx,[si]
      	call cube
      	mov [di],ax			
      	mov [di].2,dx		
      	add si,2			;ds:si 指向下一个 word 单元
      	add di,4			;ds:di 指向下一个 dword 单元
      	loop s
      	
      	mov ax,4c00h
      	int 21h
      	
 cube:	mov ax,bx
 		mul bx
 		mul bx
 		ret
 		
code ends
end start
```





#### 10.11	批量数据的传递

前面的例程中，子程序 cube 只有一个参数，放在 bx 中。如果有两个参数，那么可以用两个寄存器来放，可是如果需要传递的数据有 3 个、4 个或更多直至 N 个，该怎样存放呢？寄存器的数量终究有限，我们不可能简单地用寄存器来存放多个需要传递地数据。对于返回值，也有同样的问题。

在这种时候，我们将批量数据放到内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序。对于具有批量数据的返回结果，也可用同样的方法。

下面看一个例子，设计一个子程序，功能：将一个全是字母的字符串转化为大写。

这个子程序需要知道两件事，字符串的内容和字符串的长度。因为字符串的字母可能很多，所以不便将整个字符串中的所有字母都直接传递给子程序。但是，可以将字符串在内存中的首地址放在寄存器中传递给子程序。因为子程序中要用到循环，我们可以用 loop 指令，而循环的次数恰恰就是字符串的长度。出于方便的考虑，可以将字符串的长度放到 cx 中。

capital:	and byte ptr [si],11011111b	;将 ds:si 所指单元中的字母转化为大写

​				 inc si											;ds:si 指向下一个单元

​				 loop capital

​				 ret



编程，将 data 段中的字符串转化为大写。

```assembly
assume cs:code

data segment
 db 'conversation'
data ends

code segment
 start:mov ax,data
 	   mov ds,ax
       mov si,0			;ds:si 指向字符串(批量数据)所在空间的首地址
       mov cs,12		;cs 存放字符串的长度
       call capital
       mov ax,4c00h
       int 21h
       
capital:and byte ptr [si],11011111b   
		inc si
		loop capital
		ret
code ends
end start
```



注意，除了用寄存器传递参数外，还有一种通用的方法是用栈来传递参数。关于这种技术请参看附注 4。





#### 10.12	寄存器冲突的问题

子程序中使用的寄存器，和可能在主程序中也要使用，造成了寄存器使用上的冲突。

那么如何来避免这种冲突呢？粗略地看，可以有以下两个方案。

（1）在编写调用子程序的程序时，注意看看子程序中有没有用到会产生冲突的寄存器，如果有，调用者使用别的寄存器；

（2）在编写子程序的时候，不要使用会产生冲突的寄存器。

这两个方案显然不可行。

解决这个问题的简捷方法是，在子程序的开始将子程序中所有用到的寄存器中的内容都保存起来，在子程序返回前再恢复。可以用栈来保存寄存器中的内容。

以后，我们编写子程序的标准框架如下：

子程序开始：子程序中使用的寄存器入栈

​						子程序内容

​						子程序中使用的寄存器出栈

​						返回（ret、retf）







### 第 11 章	标志寄存器

CPU 内部的寄存器中，有一种特殊的寄存器(对于不同的处理机，个数和结构都可能不同)具有以下 3 种作用。

（1）用来存储相关指令的某些执行结果；

（2）用来为 CPU 执行相关指令提供行为依据；

（3）用来控制 CPU 的相关工作方式。

这种特殊的寄存器在 8086CPU 中，被称为标志寄存器。8086CPU 的标志寄存器有 16 位，其中存储的信息通常被称为程序状态字(PSW)。我们已经使用过 8086CPU 的 ax、bx、cx、dx、si、di、bp、sp、IP、cs、ss、ds、es 等 13 个寄存器了，本章中的标志寄存器(以下简称为 flag)是我们要学写的最后一个寄存器。

flag 和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而 flag 寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。

8086CPU 的 flag 寄存器的结构如图 11.1 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE52.jpg"/> </div><br>
flag 的 1、3、5、12、13、14、15 位在 8086CPU 中没有使用，不具有任何含义。而 0、2、4、6、7、8、9、10、11 位都具有特殊的含义。

在这一章中，我们学习标志寄存器中的 CF、PF、ZF、SF、OF、DF 标志位，以及一些与其相关的典型指令。





#### 11.1	ZF 标志

flag 的第 6 位是 ZF，零标志位。它记录相关指令执行后，其结果是否为 0。如果结果为 0，那么 zf=1；如果结果不为 0，那么 zf=0。

比如，指令：

mov ax,1

sub ax,1

执行后，结果为 0，则 zf=1。

mov ax,2

sub ax,1

执行后，结果不为 0，则 zf=0。

注意，在 8086CPU 的指令集中，有的指令的执行是影响标志寄存器的，比如，add、sub、mul、div、inc、or、and 等，它们大都是运算指令(进行逻辑或算术运算)；有的指令的执行对标志寄存器没有影响，比如，mov、push、pop 等，它们大都是传送指令。在使用一条指令的时候，要注意这条指令的全部功能，其中包括，执行结果对标志寄存器的哪些标志位造成影响。





#### 11.2	PF 标志

flag 的第 2 位是 PF，奇偶标志位。它记录相关指令执行后，其结果的所有 bit 位中 1 的个数是否为偶数。如果 1 的个数为偶数，pf=1，如果为奇数，那么 pf=0。

比如，指令：

mov al,1

add al,10

执行后，结果为 00001011B，其中有 3 个 1，则 pf=0；

mov al,1

or al,2

执行后，结果为 00000011B，其中有 2 个 1，则 pf=1；

sub al,al

执行后，结果为 00000000B，其中有 0 个 1，则 pf=1；



#### 11.3	SF 标志

flag 的第 7 位是 SF，符号标志位。它记录相关指令执行后，其结果是否为负。如果结果为负，sf=1；如果非负，sf=0。

计算机中通常用补码来表示有符号数据。计算机中的一个数据可以看作是有符号数，也可以看成是无符号数。

这也就是说，对于同一个二进制数据，计算机可以将它当作无符号数据来运算，也可以当作是有符号数据来运算。

不管我们如何看代，CPU 在执行 add 等指令的时候，就已经包含了两种含义，也将得到用同一种信息来记录的两种结果。关键在于我们的程序需要哪一种结果。

SF 标志，就是 CPU 对有符号数运算结果的一种记录，它记录数据的正负。在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当作无符号数来运算，SF 的值则没有意义，虽然相关的指令影响了它的值。

这也就是说，CPU 在执行 add 等指令时，是必然要影响到 SF 标志位的值的。至于我们需不需要这种影响，那就看我们如何看代指令所进行的运算了。

某些指令将影响标志寄存器中的多个标记位，这些被影响的标记位比较全面地记录了指令的执行结果，为相关的处理提供了所需的依据。比如指令 sub al,al 执行后，ZF、PF、SF 等标志位都要受到影响，它们分别为：1、1、0。





#### 11.4	CF 标志

flag 的第 0 位是 CF，进位标志位。一般情况下，在进行**无符号数**运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。

对于位数为 N 的无符号数来说，其对应的二进制信息的最高位，即第 N-1 位，就是它的最高有效位，而假想存在的第 N 位，就是相对于最高有效位的更高位，如图 11.2 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE53.jpg"/> </div><br>
我们知道，当两个数据相加的时候，有可能产生从最高有效位向更高位的进位。比如，两个 8 位数据：98H+98H，将产生进位。由于这个进位值在 8 位数中无法保存，我们在前面的课程中，就只是简单地说这个进位值丢失了。其实 CPU 在运算的时候，并不丢弃这个进位值，而是记录在一个特殊的寄存器的某一位上。8086CPU 就用 flag 的 CF 位来记录这个进位值。比如，下面的指令：

mov al,98H

add al,al		;执行后：(al)=30H，CF=1，CF 记录了从最高有效位向更高位的进位值

add al,al		;执行后，(al)=60H，CF=0，CF 记录了从最高有效位向更高位的进位值

而当两个数据做减法的时候，有可能向更高位借位。比如，两个 8 位数据：97H~98H，将产生借位，借位后，相当于计算 197H-98H。而 flag 的 CF 位也可以用来记录这个借位值。比如，下面的指令：

mov al,97H

sub al,98H		;执行后，(al)=FFH，CF=1，CF 记录了向更高位的借位值

sub al,al			;执行后，(al)=0，CF=0，CF 记录了向更高位的借位值





#### 11.5	OF 标志

我们先来谈谈溢出的问题。在进行有符号数运算的时候，如结果超出了机器所能表示的范围称为意出。

那么，什么是机器所能表示的范围呢？

比如说，指令运算的结果用 8 位寄存器或内存单元来存放，比如，add al,3，那么对于 8 位的有符号数据，机器所能表示的范围就是 -128~127。同理，对于 16 位有符号数据，机器所能表示的范围是 -32768~32767。

如果运算结果超出了机器所能表达的范围，将产生溢出。

注意，这里所讲的溢出，只是对有符号数运算而言。下面我们看两个溢出的例子。

mov al,98

add al,99

执行后将产生溢出。因为 add al,99 进行的有符号数运算是：

(al)=(al)+99=98+97=197

而结果 197 超出了机器所能表示的 8 位有符号数的范围：-128~127。

mov al,0F0H	;F0H，为有符号数 -16 的补码

add al,088H	 ;88H，为有符号数 -120 的补码

执行后，将产生溢出。因为 add al,088H 进行的有符号数运算数：

(al)=(al)+(-120)=(-16)+(-120)=-136

而结果 -136 超出了机器所能表示的 8 位有符号数的范围：-128~127。

如果在进行有符号数运算时发生溢出，那么运算的结果将不正确。





#### 11.6	adc 指令

adc 是带进位加法指令，它利用了 CF 位上记录的进位值。

指令格式：adc 操作对象 1，操作对象 2

功能：操作对象 1= 操作对象 1 + 操作对象 2 + CF

比如指令 adc ax,bx 实现的功能是：(ax)=(ax)+(bx)+CF

例：

mov ax,2

mov bx,1

sub bx,ax

adc ax,1

执行后，(ax)=4。adc 执行时，相当于计算：(ax)+1+CF=2+1+1=4。

mov ax,1

add ax,ax

adc ax,3

执行后，(ax)=5。adc 执行时，相当于计算：(ax)+3+CF=2+3+0=5。

mov al,98H

add al,al

adc al,3

执行后，(al)=34H。adc 执行时，相当于计算：(al)+3+CF=30H+3+1=34H。

可以看出，adc 指令比 add 指令多加了一个 CF 位的值。

为什么要加上 CF 的值呢？CPU 为什么要提供这样一条指令呢？

先来看一下 CF 的值的含义。在执行 adc 指令的时候加上的 CF 的值的含义，是由 adc 指令前面的指令决定的，也就是说，关键在于所加上的 CF 值是被什么指令设置的。显然，如果 CF 的值是被 sub 指令设置的，那么它的含义就是借位值；如果是被 add 指令设置的，那么它的含义就是进位值。



#### 11.7	sbb 指令

sbb 是错位剑法指令，它利用了 CF 位上记录的借位值。

指令格式：sub 操作对象 1，操作对象 2

功能：操作对象 1= 操作对象 1 - 操作对象 2 - CF

比如指令 sub ax,bx 实现的功能是：(ax)=(ax)-(bx)-CF

sub 指令执行后，将对 CF 进行设置。利用 sub 指令可以对任意大的数据进行减法运算。



#### 11.8	cmp 指令

comp 是比较指令，comp 的功能相当于减法指令，只是不保存结果。cmp 指令执行后，将对标志寄存器产生影响。其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。



#### 11.9	检测比较结果的条件转移指令

略



#### 11.10	DF 标志和串传送指令

flag 的第 10 位是 DF，方向标志位。在串处理指令中，控制每次操作后 si、di 的增减。

df=0	每次操作后 si、di 递增；

df=1	每次操作后 si、di 递减；

我们来看下面的一个串传送指令。

格式：movsb

功能：执行 movsb 指令相当于进行下面几步操作。

（1）((es)*16+(di))=((ds) *16+(si))

（2）如果 df=0 则：	(si)+(si)+1

​										(di)=(di)+1

​		 如果 df=1 则：	 (si)+(si)-1

​										(di)=(di)-1

用汇编语法描述 movsb 的功能如下。

mov es:[di],byte ptr ds:[si]		;8086 并不支持这样的指令，这里只是个描述

如果 df=0:

inc si

inc di

如果 df=1

dec  si

dec di

可以看出，movsb 的功能是将 ds:si 指向的内存单元中的字节送入 es:di 中，然后根据标志寄存器 df 位的值，将 si 和 di 递增或递减。

当然，也可以传送一个字，指令如下。

格式：movsw

movsw 的功能是将 ds:si 指向的内存字单元中的字送入 es:di 中，然后根据标志寄存器 df 位的值，将 si 和 di 递增 2 或递减 2。

用汇编语法描述 movsw 的功能如下。

mov es:[di],word ptr ds:[si]		;8086 并不支持这样的指令，这里只是个描述

如果 df=0:

add si,2

add di,2

如果 df=1

sub si,2

sub di,2

movsb 和 movsw 进行的是串传送操作中的一个步骤，一般来说，movsb 和 movsw 都和 rep 配合使用，格式如下：

rep movsb

用汇编语法来描述 rep movsb 的功能就是：

s:movsb

   loop s

可见，rep 的作用是根据 cx 的值，重复执行后面的串传送指令。由于每执行一次 movsb 指令 si 和 di 都会递增或递减指向后一个单元或前一个单元，则 rep movsb 就可以循环实现(cx)个字符的传送。

同理，也可以使用这样的指令：rep movsw。

相当于：

s:movsw

   loop s

由于 flag 的 df 位决定着串传送指令执行后，si 和 di 改变的方向，所以 CPU 应该提供相应的指令来对 df 位进行设置，从而使程序员能够决定传送的方向。

8086CPU 提供下面两条指令对 df 位进行设置。

cld 指令：将标志寄存器的 df 位置 0

std 指令：将标志寄存器的 df 位置 1

我们来看下面的两个程序。

（1）编程，用串传送指令，将 data 段中的第一个字符串复制到它后面的空间中。

data segment

​	db "Wlcome to masm!"

​	db 16 dup (0)

data ends

我们分析一下，使用串传送指令进行数据的传送，需要给它提供一些必要的信息，它们是：

（1）传送的原始位置：ds:si;

（2）传送的目的位置：es:di;

（3）传送的长度：cx;

（4）传送的方向：df。

在这个问题中，这些信息如下。

（1）传送的原始位置：data:0;

（2）传送的目的位置：data:0010;

（3）传送的长度：16;

（4）传送的方向：因为正向传送(每次串传送指令执行后，si 和 di 递增)比较方便，所以设置 df=0。

好了，明确了这些信息之后，我们来编写程序：

```assembly
mov ax,data
mov da,ax
mov si,0		;ds:si 指向 data:0
mov es,ax
mov di,16		;es:di 指向 data:0010
mov cx,16		;(cx)=16，rep 循环 16 次
cld				;设置 df=0，正向传送
rep movsb
```



（2）编程，用串传送指令，将 F000H 段中的最后 16 个字符复制到 data 段中

data segment

​	db 16 dup (0)

data ends

我们还是先来看一下应该位串传送指令提供什么样的信息。

要传送的字符串位于 F000H 段的最后 16 个单元中，那么它的最后一个字符的位置：F000:FFFF，是显而易见的。可以将 ds:si 指向 F000H 段的最后一个单元，将 es:di 指向 data 段中的最后一个单元，然后逆向(即从高地址向低地址)传送 16 个字节即可。

（1）传送的原始位置：F000:FFFF;

（2）传送的目的位置：data:000F;

（3）传送的长度：16;

（4）传送的方向：因为逆向传送(每次串传送指令执行后，si 和 di 递减)比较方便，所以设置 df=1。

程序如下。

```assembly
mov ax,0f00h
mov ds,ax
mov si,0ffffh		;ds:si 指向 f000:ffff
mov ax,data
mov es,ax
mov di,15			;es:di 指向 data:000F
mov cx,16			;(cx)=16，rep 循环 16 次
std					;设置 df=1，逆向传送
rep mov sb
```





#### 11.11	pushf 和 popf

pushf 的功能是将标志寄存器的值压栈，而 propf 是从栈中弹出数据，送入标志寄存器中。

pushf 和 popf，为直接访问标志寄存器提供了一种方法。





#### 11.2	标志寄存器在 Debug 中的表示

在 Debug 中，标志寄存器是按照有意义的各个标志位单独表示的。在 Debug 中，我们可以看到下面的信息。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE54.jpg"/> </div><br>
下面列出 Debug 对我们已知的标志位的表示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE55.jpg"/> </div><br>
### 第 12 章	内	中	断

任何一个通用的 CPU，比如 8086，都具备一种能力，可以在执行完当前正在执行的指令之后，检测到从 CPU 外部发送过来的或内部产生的一种特殊信息，并且可以立即对所接收到的信息进行处理。这种特殊的信息，我们可以称其为：中断信息。中断的意思是指，CPU 不再接着(刚执行完的指令)向下执行，而是转去处理这个特殊信息。

注意，我们这里所说的中断信息，是为了便于理解而采用的一种逻辑上的说法。它是对几个具有先后顺序的硬件操作所产生的事件的统一描述。“中断信息” 是要求 CPU 马上进行某种处理，并向所要进行的该种处理提供了必备的参数的通知信息。因为本书的内容不是微机原理与接口或组成原理，我们只能用一些便于理解的说法来描述一些比较复杂的机器工作原理，从而使学习者忽略一些和我们的学习重心无关的内容。但笔者又需要对这些问题有一个严谨的交代，所以，有了这些补充说明的文字。如果你不理解这些文字所讲的东西，就不必去理解了。

中断信息可以来自 CPU 的内部和外部，这一章中，我们主要讨论来自于 CPU 内部的中断信息。



#### 12.1	内中断的产生

当 CPU 的内部有什么事情发生的时候，将产生需要马上处理的中断信息呢？对于 8086CPU，当 CPU 内部有下面的情况发生的时候，将产生相应的中断信息。

（1）除法错误，比如，执行 div 指令产生的除法溢出；

（2）单步执行；

（3）执行 into 执行；

（4）执行 int 指令。

我们现在不要去管这 4 钟情况的具体含义，只要知道 CPU 内部有 4 种情况可以产生需要及时处理的中断信息即可。虽然我们现在并不是很清楚，这 4 种情况到底是什么，但是有一点是很清楚的，即，它们是不同的信息。既然是不同的信息，就需要进行不同的处理。要进行不同的处理，CPU 首先要知道，所接收到的中断信息的来源。所以中断信息种必须包含识别来源的编码。8086CPU 用称为中断类型码的数据来标识中断信息的来源。中断类型码为一个字节型数据，可以表示 256 种中断信息的来源。以后，我们将产生中断信息的事件，即中断信息的来源，简称为中断源，上述的 4 种中断源，在 8086CPU 中的中断类型码如下。

（1）除法错误：0

（2）单步执行：1

（3）执行 into 指令：4

（4）执行 int 指令，该指令的格式为 int n，指令中的 n 为字节型立即数，是提供给 CPU 的中断类型码。



#### 12.2	中断处理程序

CPU 收到中断信息后，需要对中断信息进行处理。而如何对中断信息进行处理，可以由我们编程决定。我们编写的，用来处理中断信息的程序被称为中断处理程序。一般来说，需要对不同的中断信息编写不同的处理程序。

CPU 在收到中断信息后，应该转去执行该中断信息的处理程序。我们知道，若要 8086CPU 执行某处的程序，就要将 CS:IP 指向它的入口(即程序第一条指令的地址)。可见首要的问题是，CPU 在收到中断信息后，如何根据中断信息确定其处理程序的入口。

CPU 的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系，使得 CPU 根据中断信息可以找到要执行的处理程序。

我们知道，中断信息中包含有标识中断源的类型码。根据 CPU 的设计，中断类型码的作用就是用来定位中断处理程序。比如 CPU 根据中断类型码 4，就可以找到 4 号中断的处理程序。可随之而来的问题是，若要定位中断处理程序，需要知道它的段地址和偏移地址，而如何根据 8 位的中断类型码得到中断处理程序的段地址和偏移地址呢？





#### 12.3	中断向量表

CPU 用 8 位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。那么什么是中断向量表呢？中断向量表就是中断向量的列表。那么什么又是中断向量呢？所谓中断向量，就是中断处理程序的入口地址。展开来讲，中断向量表，就是中断处理程序入口地址的列表。

中断向量表在内存中保存，其中存放着 256 个中断源所对应的中断处理程序的入口，如图 12.1 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE56.jpg"/> </div><br>
可以看到，CPU 只要知道了中断类型码，就可以将中断类型码作为中断向量表的表项号，定位相应的表项，从而得到中断处理程序的入口地址。

可见，CPU 用中断类型码，通过查找中断向量表，就可以得到中断处理程序的入口地址。在这个方案中，一个首要的问题是，CPU 如何找到中断向量表？现在，找到中断向量表成了通过中断类型码找到中断处理程序入口地址的先决条件。

中断向量表在内存中存放，对于 8086PC 机，中断向量表指定存放在内存地址 0 处。从内存 0000:0000 到 0000:03FF 的 1024 个单元中存放着中断向量表。能不能放在别处呢？不能，如果使用 8086CPU，中断向量表就必须放在 0000:0000~0000:03FF 单元中，这是规定，因为 8086CPU 就从这个地方读取中断向量表。

那么在中断向量表中，一个表项占多大的空间呢？一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，对于 8086CPU，这个入口地址包括段地址和偏移地址，所以一个表项占两个字，高地址存放段地址，低地址字存放偏移地址。



##### 检测点	12.1

（1）用 Debug 查看内存，情况如下：

0000:0000	68	10	A7	00	8B	01	70	00-16	00	9D	03	8B	01	70	00

则 3 号中断源对应的中断处理程序的入口地址为：

 0号：00A7：1068
 1号：0070：108B
 2号：039D：0016
 3号：0070：108B



（2）存储 N 号中断源对应的中断处理程序入口的偏移地址的内存单元的地址为：

[n*4]字单元



（3）存储 N 号中断源对应的中断处理程序入口的段地址的内存单元的地址为：

[n*4+2]字单元





#### 12.4	中	断	过	程

从上面的讲解中，我们知道，可以用中断类型码，在中断向量表中找到中断处理程序的入口。找到这个入口地址的最终目的是用它设置 CS 和 IP，使 CPU 执行中断处理程序。用中断类型码找到中断向量，并用它设置 CS 和 IP，这个工作是由 CPU 的硬件自动完成的。CPU 硬件完成这个工作的过程被称为中断过程。

CPU 收到中断信息后，要对中断信息进行处理，首先将引发中断过程。硬件在完成中断过程后，CS:IP 将指向中断处理程序的入口，CPU 开始执行中断处理程序。

有一个问题需要考虑，CPU 在执行完中断处理程序后，应该返回原来的执行点继续执行下面的指令。所以在中断过程中，在设置 CS:IP 之前，还要讲原来的 CS 和 IP 的值保存起来。在使用 call 指令调用子程序时有同样的问题，子程序执行后还要返回到原来的执行点继续执行，所以，call 指令先保存当前 CS 和 IP 的值，然后再设置 CS 和 IP。

下面是 8086CPU 在收到中断信息后，所引发的中断过程。

（1）(从中断信息中)取得中断类型码

（2）标志寄存器的值入栈(因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中)；

（3）设置标志寄存器的第 8 位 TF 和第 9 位 IF 的值为 0(这一步的目的后面将介绍)；

（4）CS 的内容入栈；

（5）IP 的内容入栈；

（6）从内存地址为中断类型码✖4 和中断类型码✖4+2 的两个字单元中读取中断处理程序的入口地址设置 IP 和 CS。

CPU 在收到中断信息之后，如果处理该中断信息，就完成一个由硬件自动执行的中断过程(程序员无法改变这个过程中所要作的工作)。中断过程的主要任务就是用中断类型码在中断向量表中找到中断处理程序的入口地址，设置 CS 和 IP。因为中断处理程序执行完成后，CPU 还要回过头来继续执行被中断的程序，所以要在设置 CS、IP 之前，先将它们的值保存起来。可以看到 CPU 将它们保存在栈中。我们注意到，在中断过程中还要做的一个工作就是设置标志寄存器的 TF、IF 位，对于这样做的目的，我们将在后面的内容和下一章中进行讨论。因为在执行完中断处理程序后，需要恢复在进入中断处理程序之前的 CPU 现场(某一时刻，CPU 中各个寄存器的值)。所以应该在修改标记寄存器之前，将它的值入栈保存。

我们更简洁地描述中断过程，如下：

（1）取得中断类型码 N；

（2）pushf

（3）TF=0，IF=0

（4）push CS

（5）push IP

（6）(IP)=(N*4)，(cs)=(N *4+2)

在最后一步完成后，CPU 开始执行由程序员编写的中断处理程序。





#### 12.5	中断处理程序和 iret 指令

由于 CPU 随时都可能检测到中断信息，也就是说，CPU 随时都可能执行中断处理程序，所以中断处理程序必须一致存储在内存某段空间之中。而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中。

中断处理程序的编写方法和子程序的比较类似，下面是常规的步骤：

（1）保存用到的寄存器；

（2）处理中断；

（3）恢复用到的寄存器；

（4）用 iret 指令返回。

iret 指令的功能用汇编语法描述为：

pop IP

pop CS

popf



iret 通常和硬件自动完成的中断过程配合使用。可以看到，在中断过程中，寄存器入栈的顺序是标志寄存器、CS、IP，而 iret 的出栈顺序是 IP、CS、标志寄存器，刚好和其相对应，实现了用执行中断处理程序前的 CPU 现场恢复标志寄存器和 CS、IP 的工作。iret 指令执行后，CPU 回到执行中断处理程序前的执行点继续执行程序。



#### 12.6	除法错误中断的处理

下面的内容中，我们通过对 0 号中断，即除法错误中断的处理，来体会一下前面所讲的内容。

当 CPU 执行 div 等除法指令的时候，如果发生了除法溢出错误，将产生中断类型码为 0 的中断信息，CPU 将检测到这个信息，然后引发中断过程，转去执行 0 号中断所对应的中断处理程序。我们看一下下面程序的执行结果，如图 12.2 所示(不同的操作系统下显示可能不同)。

mov ax,1000h

mov bh,1

div bh

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE57.jpg"/> </div><br>
可以看到，当 CPU 执行 div bh 时，发生了除法溢出错误，产生 0 号中断信息，从而引发中断过程，CPU 执行 0 号中断处理程序。我们从图中可以看出系统中的 0 号中断处理程序的功能：图中显示提示信息 “Divide overflow” 后，返回到操作系统中。





#### 12.7~12.10

略



#### 12.11	单	步	中	断

基本上，CPU 在执行完一条指令之后，如果检测到标志寄存器的 TF 位为 1，则产生单步中断，引发中断过程。单步中断的中断类型码为 1，则它引发的中断过程如下。

（1）取得中断类型码为 1；

（2）标志寄存器入栈，TF、IF 设置为 0；

（3）CS、IP 入栈；

（4）(IP)=(1*4)，(cs)=(1 *4+2)

如上所述，如果 TF=1，则执行一条指令后，CPU 就要转去执行 1 号中断处理程序。CPU 为什么要提供这样的功能呢？

我们在使用 Debug 的 t 命令的时候，有没有想过这样的问题，Debug 如何能让 CPU 在执行一条指令，就显示各个寄存器的状态？我们知道，CPU 在执行程序的时候是从 CS:IP 指向的某个地址开始，自动向下读取指令执行。也就是说，如果 CPU 不提供其他功能的话，就按这种方式工作，只要 CPU 一加电，它就从预设的地址开始一直执行下去，不可能有任何程序能控制它在执行完一条指令后停止，去做别的事情。可是，我们在 Debug 中看到的情况却是，Debug 可以控制 CPU 执行被加载程序的一条指令，然后让它停下来，显示寄存器的状态。

Debug 有特殊的能力吗？我们只能说 Debug 利用了 CPU 提供的一种功能。只有 CPU 提供了在执行一条指令后就转去做其他事情的功能，Debug 或是其他的程序才能利用 CPU 提供的这种功能做出我们使用 T 命令时的效果。

好了，我们来简要地考虑一下 Debug 是如何利用 CPU 所提供的单步中断的功能的。首先，Debug 提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令。然后，在使用 t 命令执行指令时，Debug 将 TF 设置为 1，使得 CPU 工作于单步中断方式下，则在 CPU 执行完这条指令后就引发单步中断，执行单步中断的中断处理程序，所有寄存器中的内容被显示在屏幕上，并且等待输入命令。

那么，接下来的问题是，当 TF=1 时，CPU 在执行完一条指令后将引发单步中断，转去执行中断处理程序。注意，中断处理程序也是由一条条指令组成的，若果在执行中断处理程序之前，TF=1，则 CPU 在执行完中断处理程序的第一条指令后，又要产生单步中断，则又要转去执行单步中断的中断处理程序，在执行完中断处理程序的第一条指令后，又要产生单步中断，又要转去执行单步中断的中断处理程序.........

看来，上面的过程将陷入一个永远不能结束的循环，CPU 永远单步中断处理程序的第一条指令。

CPU 当然不能让这种情况发生，解决的方法就是，在进入中断处理程序之前，设置 TF=0。从而避免 CPU 在执行中断处理程序的时候发生单步中断。这就是为什么在中断过程中有 TF=0 这个步骤，我们再来看一下中断过程。

（1）取得中断类型码 N；

（2）标志寄存器入栈，TF=0、IF=0；

（3）CS、IP 入栈；

（4）(IP)=(N*4)，(CS)=(N *4+2)

最后，CPU 提供单步中断功能的原因就是，为单步跟踪程序的执行过程，提供了实现机制。





#### 12.2	响应中断的特殊情况

一般情况下，CPU 在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程。可是，在有些情况下，CPU 在执行完当前指令后，即便是发生中断，也不会响应。对于这些情况，我们不一一列举，只是用一种情况来进行说明。

在执行完向 ss 寄存器传送数据的指令后，即便是发生中断，CPU 也不会响应。这样做的主要原因是，ss:sp 联合指向栈顶，而对它们的设置应该连续完成。如果在执行完设置 ss 的指令后，CPU 响应中断，引发中断过程，要在栈中压入标志寄存器、CS 和 IP 的值。而 ss 改变，sp 并未改变，ss:sp 指向的不是正确的栈顶，将引起错误。所以 CPU 在执行完设置 ss 的指令后，不响应中断。这给连续设置 ss 和 sp 指向正确的栈顶提供了一个时机。即，我们应该利用这个特性，将设置 ss 和 sp 的指令连续存放，使得设置 sp 的指令紧接着设置 ss 的指令指向，而在此之间，CPU 不会引发中断过程。比如，我们要将栈顶设为 1000:0，应该：

mov ax,1000h

mov ss,ax

mov sp,0

而不应该：

mov ax,1000h

mov ss,ax

mov ax,0

mov sp,0 

现在可以回过来看一下，实验 2 的内容。

Debug 利用单步中断来实现 T 命令的功能，也就是说，用 T 命令执行一条指令后，CPU 响应单步中断，执行 Debug 设置好的处理程序，才能在屏幕上显示寄存器的这条，并等待命令的输入。而在 mov ss,ax 指令执行后，CPU 根本就不响应任何中断，其中也包括单步中断，所以 Debug 设置好的用来显示寄存器状态和等待输入命令的中断处理程序根本没有得到执行，所以我们看不到预期的结果。CPU 接着向下执行后面的指令 mov sp,10h，然后响应单步中断，我们才看到正常的结果。





#### 第 13 章	int 指令

中断信息可以来自 CPU 的内部和外部，当 CPU 的内部有需要处理的事情发生的时候，将产生需要马上处理的中断信息，引发中断过程。在第 12 章中，我们讲解了中断过程和两种内中断的处理。

这一章中，我们讲解另一种重要的内中断，由 int 指令引发的中断。



#### 13.1	int 指令

int 指令的格式为：int n，n 为中断类型码，它的功能是引发中断过程。

CPU 执行 int n 指令，相当于引发一个 n 号中断的中断过程，执行过程如下。

（1）取中断类型码 n；

（2）标志寄存器入栈，IF=0，TF=0

（3）CS、IP 入栈；

（4）(IP)=(n✖4)，(cs)=(n✖4+2)。

从此处转去执行 n 号中断的中断处理程序。

可以在程序中使用 int 指令调用任何一个中断的中断处理程序。例如，下面的程序：

```assembly
assume cs:code
code segment
  start:mov ax,0b800h
		mov es,ax
        mov byte ptr es:[12*160+40*2],'!'
        int 0
code ends
end start
```



这个程序在 Windows 2000 中的 DOS 方式下执行时，将在屏幕中间显示一个 “！”，然后显示 “Divide overflow” 后返回到系统中。“！” 是我们编程希纳是的，而 “Divide overflow” 是哪里来的呢？我们的程序中又没有做除法，不可能产生除法溢出。

程序是没有做除法，但是在结尾处使用了 int 0 指令。CPU 执行 int 0 指令时，将引发中断过程，执行 0 号中断处理程序，而系统设置的 0 号中断处理程序的功能是显示 “Divide overflow”，然后返回到系统。

可见，int 指令的最终功能和 call 指令类似，都是调用一段程序。

一遍情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。我们在编程的时候，可以用 int 指令调用这些子程序。当然，也可以自己编写一些中断处理程序供别人使用。以后，我们可以将中断处理程序简称为中断例程。



#### 13.2	编写供应用程序调用的中断例程

略



#### 13.3	对 int、iret 和栈的深入理解

略



#### 13.4	BIOS 和 DOS 所提供的中断例程

在系统的 ROM 中存放着一套程序，称为 BIOS(基本输入输出系统)，BIOS 中主要包含以下几部分内容。

（1）硬件系统的检测和初始化程序；

（2）外部中断和内部中断的中断例程；

（3）用于对硬件设备进行 I/O 操作的中断例程；

（4）其他和硬件系统相关的中断例程。

操作系统 DOS 也提供了中断例程，从操作系统的角度来看，DOS 的中断例程就是操作系统向程序员提供的编程资源。

BIOS 和 DOS 在所提供的中断例程中包含了许多子程序，这些子程序实现了程序员在编程的时候经常需要用到的功能。程序员在编程的时候，可以用 int 指令直接调用 BIOS 和 DOS 提供的中断例程，来完成某些工作。

和硬件设备相关的 DOS 中断例程中，一般都调用了 BIOS 的中断例程。



#### 13.5	BIOS 和 DOS 中断例程的安装过程

前面的课程中，我们都是自己编写中断例程，将它们放到安装程序中，然后运行安装程序，将它们安装到指定的内存区中。此后，别的应用程序才可以调用。

而 BIOS 和 DOS 提供的中断例程是如何安装到内存中的呢？我们下面讲解它们的安装过程。

（1）开机后，CPU 一加电，初始化 (CS)=0FFFFH，(IP)=0，自动从 FFFF:0 单元开始执行程序。FFFF:0 处有一条跳转指令，CPU 执行该指令后，转去执行 BIOS 中的硬件系统检测和初始化程序。

（2）初始化程序将建立 BIOS 所支持的中断向量，即将 BIOS 提供的中断例程的入口地址登记在中断向量表中。注意，对于 BIOS 所提供的中断例程，只需将入口地址登记在中断向量表中即可，因为它们是固化到 ROM 中的程序，一直在内存中存在。

（3）硬件系统检测和初始化完成后，调用 int 19h 进行操作系统的引导。从此将计算机交由操作系统控制。

（4）DOS 启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。



##### 检测点 13.2

判断下面说法的正误：
（1）我们可以编程改变 FFFF:0 处的指令，使得 CPU 不去执行 BIOS 中的硬件系统检测和初始化程序。
解答：因为 FFFF:0 处为只读的 ROM 内存空间，无法编程改变。
（2）int 19h 中断例程，可以由 DOS 提供。
解答：因为 BIOS 调用 int 19h 进行操作系统的引导，该中断例程运行在 DOS 之前，所以不可以由 DOS 提供。



#### 13.6	BIOS 中断例程应用

int 10h 中断例程是 BIOS 提供的中断例程，其中包含了多个和屏幕输出相关的子程序。

一般来说，一个供程序员调用的中断例程中往往包括多个子程序，中断例程内部用传递进来的参数来决定执行哪一个子程序。BIOS 和 DOS 提供的中断例程，都用 ah 来传递内部子程序的编号。



#### 13.7	DOS 中断例程应用

int 21h 中断例程是 DOS 提供的中断例程，其中包含了 DOS 提供给程序员在编程时调用的子程序。

我们前面一直使用的是 int 21h 中断例程的 4ch 号功能，即程序返回功能，如下：

mov ah,4ch	;程序返回

mov al,0		 ;返回值

int 21h

(ah)=4ch 表示调用第 21h 号中断例程的 4ch 号子程序，功能为程序返回，可以提供返回值作为参数。

我们前面使用这个功能的时候经常写做：

mov ax,4c00h

int 21h





### 第 14 章	端	口

我们前面讲过，各种存储器都和 CPU 的地址线、数据线、控制线相连。CPU 在操控它们的时候，把它们都当作内存来对待，把它们总的看做一个由若干存储单元组成的逻辑存储器，这逻辑存储器我们称其为内存地址空间。

在 PC 机系统中，和 CPU 通过总线相连的芯片除各种存储器外，还有以下 3 种芯片。

（1）各种接口卡(比如，网卡、显卡)上的接口芯片，它们控制接口卡进行工作；

（2）主板上的接口芯片，CPU 通过它们对部分外设进行访问；

（3）其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理。

在这些芯片中，都有一组可以由 CPU 读写的寄存器。这些寄存器，它们在物理上可能处理不同的芯片中，但是它们在以下两点上相同。

（1）都和 CPU 的总线相连，当然这种连接是通过它们所在的芯片进行的；

（2）CPU 对它们进行读或写的时候都通过控制线向它们所在的芯片发出端口读写命令。

可见，从 CPU 的角度，将这些寄存器都当作端口，对它们进行统一编址，从而建立了一个统一的端口地址空间。每一个端口在地址空间中都有一个地址。

CPU 可以直接读写以下 3 个地方的数据。

（1）CPU 内部的寄存器；

（2）内存单元；

（3）端口。

这一章，我们讨论端口的读写。



#### 14.1	端口的读写

在访问端口的时候，CPU 通过端口地址来定位端口。因为端口所在的芯片和 CPU 通过总线相连，所以，端口地址和内存地址一样，通过地址总线来传送。在 PC 系统中，CPU 最多可以定位 64KB 个不同的端口。则端口地址的范围为 0~65535。

对端口的读写不能用 mov、push、pop 等内存读写指令。端口的读写指令只有两条：in 和 out，分别用于从端口读取数据和往端口写入数据。

我们看一下 CPU 执行内存访问指令和端口访问指令的时候，总线上的信息：

（1）访问内存：

mov ax,ds:[8]		;假设执行前(ds)=0

执行时与总线相关的操作如下所示。

1. CPU 通过地址总线将地址信息 8 发出；

2. CPU 通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据；

3. 存储器将 8 号单元中的数据通过数据线送入 CPU。

   

（2）访问端口：

in al,60h		;从 60h 号端口读入一个字节

执行时与总线相关的操作如下。

1. CPU 通过地址总线将地址信息 60h 发出；
2. CPU 通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据；
3. 端口所在的芯片将 60h 端口中的数据通过数据线送入 CPU。



注意，在 in 和 out 指令中，只能使用 ax 或 al 来存放从端口中读入的数据或要发送到端口中的数据。访问 8 位端口时用 al，访问 16 位端口时用 ax。

对 0~255 以内的端口进行读写时：

in al,20h		;从 20h 端口读入一个字节

out 20h,al	 ;从 20h 端口写入一个字节

对 256~65535 的端口进行读写时，端口号放在 dx 中：

mov dx,3f8h		;将端口号 3f8h 送入 dx

in al,dx				 ;从 3f8h 端口读入一个字节

out dx,al			  ;向 3f8h 端口写入一个字节





#### 14.2	CMOS RAM 芯片

下面的内容中，我们通过对 CMOS RAM 的读写来体会一下对端口的访问。

PC 机中，有一个 CMOS RAM 芯片，一般简称为 CMOS。此芯片的特征如下。

（1）包含一个实时钟和一个有 128 个存储单元的 RAM 存储器(早期的计算机为 64 个字节)。

（2）该芯片靠电池供应。所以，关机后其内部的实时钟仍可正常工作，RAM 中的信息不丢失。

（3）128 个字节的 RAM 中，内部实时钟占用 0~0dh 单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时 BIOS 程序读取。BIOS 也提供了相关的程序，使我们可以在开机的时候配置 CMOS RAM 中的系统信息。

（4）该芯片内部有两个端口，端口地址为 70h 和 71h。CPU 通过这两个端口来读写 CMOS RAM。

（5）70h 为地址端口，存放要访问的 CMOS RAM 单元的地址；71h 为数据端口，存放从选定的 CMOS RAM 单元中读取的数据，或要写入到其中的数据。可见，CPU 对 CMOS RAM 的读写分两步进行，比如，读 CMOS RAM 的 2 号单元：

1. 将 2 送入端口 70h；
2. 从端口 71h 读出 2 号单元的内容。



#### 检测点 14.1

（1）编程，读取CMOS RAM的2号单元的内容。  

```assembly
assume cs:code
code segment
start:  mov al,2        ;赋值al
        out 70h,al      ;将al送入端口70h
        in al,71h       ;从端口71h处读出单元内容
        mov ax,4c00h
        int 21h
code ends
end start
```



（2）编程，向CMOS RAM的2号单元写入0。  

```assembly
assume cs:code
code segment
start:  mov al,2        ;赋值al
        out 70h,al      ;将al送入端口70h
        mov al,0        ;赋值al
        out 71h,al      ;向端口71h写入数据al
        mov ax,4c00h
        int 21h
code ends
end start
```



#### 14.3	shl 和 shr 指令

shl：Shift Logical Left

shl 和 shr 是逻辑移位指令。

shl 是逻辑左移指令，它的功能为：

（1）将一个寄存器或内存单元中的数据向左移位；

（2）将最后移出的一位写入 CF 中；

（3）最低位用 0 补充。

 

指令：
mov al,01001000b

shl al,1 ;将al中数据左移一位

执行后（al）=10010000b，CF=0。

 

注意：

如果移动位数大于 1 时，必须将移动位数放在 cl 中。

比如，指令：

mov al,01010001b

mov cl,3

shl al,cl

执行后（al）=10001000b，因为最后移出的一位是0，所以CF=0。

 

shr 是逻辑右移指令，它和 shl 所进行的操作刚好相反。





#### 14.4	CMOS RAM 中存储的时间信息

略







### 第 15 章	外	中	断

以前我们讨论的都是 CPU 对指令的执行。我们知道，CPU 在计算机系统中，除了能够执行指令，进行运算以外，还应该能够对外部设备进行控制，接收它们的输入，向它们进行输出。也就是说，CPU 除了有运算能力外，还要有 I/O(Input/Output，输入/输出)能力。比如，我们按下键盘上的一个键，CPU 最重要能够处理这个键。在使用文本编辑器时，按下 a 键后，我们可以看到屏幕上出现 “a”，是 CPU 将从键盘上输入的键所对应的字符送到 显示器上的。

要及时处理外设的输入，显然需要解决两个问题：（1）外设的输入随时可能发生，CPU 如何得知 （2）CPU 从何处得到外设的输入？

这一章中，我们以键盘输入为例，讨论这两个问题。



#### 15.1	接口芯片和端口

第 14 章我们讲过，PC 系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，CPU 将这些寄存器当作端口来访问。

外设的输入不直接送入内存和 CPU，而是送入相关的接口芯片的端口中；CPU 向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。CPU 还可以向外设输出控制命令，而这些控制命令也是先送到相关芯片的端口中，然后再由相关的芯片根据命令对外设实施控制。

可见，CPU 通过端口和外部设备进行联系。



#### 15.2	外中断信息

现在，我们知道了外设的输入被存放在端口中，可是外设的输入随时都有可能到达，CPU 如何及时地知道，并进行处理呢？更一般地讲，就是外设随时都可能发生需要 CPU 及时处理的事件，CPU 如何及时得知并进行处理？

CPU 提供中断机制来满足这种需要。前面讲过，当 CPU 的内部有需要处理的事情发生的时候，将产生中断信息，引发中断过程。这种中断信息来自 CPU 的内部。

还有一种中断信息，来自于 CPU 外部，当 CPU 外部有需要处理的事情发生的时候，比如说，外设的输入到达，相关芯片将向 CPU 发出相应的中断信息。CPU 在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入。

在 PC 系统中，外中断源一共有以下两类。

##### 1.可屏蔽中断

可屏蔽中断是 CPU 可以不响应的外中断。CPU 是否响应可屏蔽中断，要看标志寄存器的 IF 位的设置。当 CPU 监测到可屏蔽中断信息时，如果 IF=1，则 CPU 在执行完当前指令后响应中断，引发中断过程：如果 IF=0，则不响应可屏蔽中断。

我们回忆一下内中断所引发的中断过程：

（1）取中断类型码 n；

（2）标志寄存器入栈，IF=0，TF=0

（3）CS、IP 入栈；

（4）(IP)=(n✖4)，(cs)=(n✖4+2)。

由此转去执行中断处理程序。

可屏蔽中断所引发的中断过程，除在第一步的实现上有所不同外，基本上和内中断的中断过程相同。因为可屏蔽中断信息来自于 CPU 外部，中断类型码是通过数据总线送入 CPU 的；而内中断的中断类型码是在 CPU 内部产生的。

现在，我们可以解释中断过程中将 IF 置为 0 的原因了。将 IF 置为 0 的原因就是，在进入中断处理程序后，禁止其他的可屏蔽中断。

当然，如果在中断处理程序中需要处理可屏蔽中断，可以用指令将 IF 置 1。8086CPU 提供的设置 IF 的指令如下：

sti，设置 IF=1；

cli，设置 IF=0。



##### 2.不可屏蔽中断

不可屏蔽中断是 CPU 必须响应的外中断。当 CPU 检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。

对于 8086CPU，不可屏蔽中断的中断类型码固定为 2，所以中断过程中，不需要取中断类型码。则不可屏蔽中断的中断过程为：

（1）标志寄存器入栈，IF=0，TF=0；

（2）CS、IP 入栈；

（3）(IP)=8，(CS)=(0AH)。

几乎所有由外设引发的外中断，都是可屏蔽中断。当外设有需要处理的事件(比如说键盘输入)发生时，相关芯片向 CPU 发出可屏蔽中断信息。不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知 CPU 的中断信息。在我们的课程中，主要讨论可屏蔽中断。





#### 15.3	PC 机键盘的处理过程

下面我们看一下键盘输入的处理过程，并以此来体会一下 PC 机处理外设输入的基本方法。

##### 1.键盘输入

键盘上的每一个键相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。

按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为 60h。

松开按下的键时，也产生要给扫描码，扫描码说明了松开的键在键盘上的位置。松开按键时产生的扫描码也被送入 60h 端口中。

一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。扫描码长度为一个字节，通码的第 7 位为 0，断码的第 7 位为 1，即：

断码=通码 + 80h

比如，g 键的通码为 22h，断码为 a2h。

表 15.1 是键盘上部分键的扫描码，只列出通码。断码=同码 + 80h。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE58.jpg"/> </div><br>

##### 2.引发 9 号中断

键盘的输入到达 60h 端口时，相关的芯片就会向 CPU 发出中断类型码为 9 的可屏蔽中断信息。CPU 检测到该中断信息后，如果 IF=1，则响应中断，引发中断过程，转去执行 int 9 中断例程。



##### 3.执行 int 9 中断例程

BIOS 提供了 int 9 中断例程，用来进行基本的键盘输入处理，主要的工作如下：

（1）读出 60h 端口中的扫描码；

（2）如果是字符键的扫描码，将该扫描码和它所对应的字符码(即 ASCII 码)送入内存中的 BIOS 键盘缓冲区；如果是控制键(比如 Ctrl)和切换键(比如 CapsLock)的扫描码，则将其转变为状态字节(用二进制位记录控制键和切换键状态的字节)写入内存中存储状态字节的单元；

（3）对键盘系统进行相关的控制，比如说，向相关芯片发出应答信息。



BIOS 键盘缓冲区是系统启动后，BIOS 用于存放 int 9 中断例程所接收的键盘输入的内存区。该内存区可以存储 15 个键盘输入，因为 int 9 中断例程除了接收扫描码外，还要产生和扫描码对应的字符码，所以在 BIOS 键盘缓冲区中，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码。

0040:17 单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下。

0：左 shift 状态，置 1 表示按下右 shift 键；

1：左 shift 状态，置 1 表示按下左 shift 键；

2：Ctrl 状态，置 1 表示按下 Ctrl 键；

3：Alt 状态，置 1 表示按下 Alt 键；

4：ScrollLock 状态，置 1 表示 Scroll 指示灯亮；

5：NumLock 状态，置 1 表示小键盘输入的是数字；

6：CapsLock 状态，置 1 表示输入大写字母；

7：Insert 状态，置 1 表示处于删除态；





#### 15.4	编写 int9 中断例程

从上面的内容中，可以看出键盘输入的处理过程：

1. 键盘产生扫描码；
2. 扫描码送入 60h 端口；
3. 引发 9 号中断；
4. CPU 执行 int9 中断例程处理键盘输入。

上面的过程中，第 1、2、3 步都是由硬件系统完成的。我们能够改变的只有 int 9 中断处理程序。我们可以重新编写 int 9 中断例程，按照自己的意图来处理键盘的输入。但是，在课程中，我们不准备完整地编写一个键盘中断地处理程序，因为要涉及一些硬件细节，而这些内容脱离了我们的内容主线。

但是，我们却还要编写新的键盘中断处理程序，来进行一些特殊的哦工作，那么这些硬件细节如何处理呢？这点比较简单，因为 BIOS 提供的 int 9 中断例程已经对这些硬件细节进行了处理。我们只要在自己编写的中断例程中调用 BIOS 的 int 9 中断例程就可以了。



#### 指令系统总结

我们对 8086CPU 的指令系统进行一下总结。读者若要详细了解 8086 指令系统中的各个指令的用法，可以查看有关的指令手册。

8086CPU 提供以下几大类指令。

##### 1、数据传送指令

比如：mov、push、pop、pushf、popf、xchg 等都是数据传送指令，这些指令实现寄存器和内存、寄存器和寄存器之间的单个数据传送。

##### 2、算术运算指令

比如：add、sub、adc、sbb、inc、dec、cmp、imul、idiv、aaa 等都是算术运算指令，这些指令实现寄存器和内存中的数据的算数运算。它们的执行结果影响标志寄存器的：sf、zf、of、cf、pf、af 位。

##### 3、逻辑指令

比如：and、or、not、xor、test、shl、shr、sal、sar、rol、ror、rcl、rcr 等都是逻辑指令。除了not指令外，它们的执行结果都影响标志寄存器的相关标志位。

##### 4、转移指令

可以修改 IP ，或同时修改 CS 和 IP 的指令统称为转移指令。转移指令分为以下几类：

（1）无条件转移指令，比如：jmp；

（2）条件转移指令，比如：jcxz、je、jb、ja、jnb、jna等；

（3）循环指令，比如：loop；

（4）过程，比如：call、ret、retf；

（5）中断，比如int、iret。

##### 5、处理机控制指令

这些指令对标志寄存器或其他处理机状态进行设置，比如：cld、std、cli、sti、nop、clc、cmc、stc、hlt、wait、esc、lock 等都是处理机控制指令。

##### 6、串处理指令

这些指令对内存中的批量数据进行处理，比如：movsb、movsw、cmps、scas、lods、stos等。若要使用这些指令方便地进行批量数据的处理，则需要和 rep、repe、repne 等前缀指令配合使用。






### 第 16 章	直接定址表

这一章，我们讨论如何有效合理地组织数据，以及相关地编程技术。



#### 16.1	描述了单元长度的标号

前面的课程中，我们一直在代码段中使用标号来标记指令、数据、段的起使地址。比如，下面的程序将 code 段中的 a 标号处的 8 个数据累加，结果存储到 b 标号处的字中。

```assembly
assume cs:code
code segment
	a: db 1,2,3,4,5,6,7,8
	b: dw 0
	
start:mov si,offset a
	  mov bx,offset b
	  mov cx,8
	s:mov al,cs:[si]
      mov ah,0
      add cs:[bx],ax
      inc si
      loop s
      
      mov ax,4c00h
      int 21h
      
code ends
end start
```



程序中，code、a、b、start、s 都是标号，这些标号仅仅表示了内存单元的地址。

但是，我们还可以使用一种标号，这种标号不但表示内存单元的地址，还表示了内存单元的长度，即表示在此标号处的单元，是一个字节单元，还是字单元，还是双字单元。上面的程序还可以写成这样：

```assembly
assume cs:code
code segment
	a db 1,2,3,4,5,6,7,8
	b dw 0
	
start:mov si,0
	  mov cx,8
	s:mov al,a:[si]
      mov ah,0
      add b,ax
      inc si
      loop s
      mov ax,4c00h
      int 21h
      
code ends
end start
```



在 code 段中使用的标号 a、b 后面没有 “: ”，它们是同时描述内存地址和单元长度的标号。标号 a，描述了地址 code:0，和从这个地址开始，以后的内存单元都是字节单元；而标号 b 描述了地址 code:8，和从这个地址开始，以后的内存单元都是字单元。

因为这种标号包含了对单元长度的描述，所以在指令中，它可以代表一个段中的内存单元。比如，对于程序中的 “b dw 0”：

指令：	mov ax,b

相当于：mov ax,cs:[8]

指令：	mov b,2

相当于：mov word ptr cs:[8],2

指令：	inc b

相当于：inc word ptr cs:[8]

在这些指令中，标号 b 代表了一个内存单元，地址为 code:8，长度为两个字节。

下面的指令会引起编译错误：

mov al,b

因为 b 代表的内存单元是字单元，而 al 是 8 位寄存器。

如果我们将程序中的指令 “add b,ax”，写为 “add b,al”，将出现同样的编译错误。

对于程序中的 “a db 1,2,3,4,5,6,7,8”：

指令：	mov al,a[si]

相当于：mov al,cs:0[si]

指令：	mov al,a[3]

相当于：mov al,cs:0[3]

指令：	mov al,a[bx+si+3]

相当于：mov al,cs:0[bx+si+3]

可见，使用这种包含单元长度的标号，可以使我们以简洁的形式访问内存中的数据。以后，我们将这种标号称为数据标号，它标记了存储数据的单元的地址和长度。它不同于仅仅表示地址的地址标号。



#### 16.2	在其他段中使用数据标号

一般来说，我们不在代码段中定义数据，而是将数据定义到其他段中。在其他段中，我们也可以使用数据标号来描述存储数据的单元的地址和长度。

注意，在后面加有 ”:“ 的地址标号，只能在代码段中使用，不能在其他段中使用。

下面的程序将 data 段中 a 标号处的 8 个数据累加，结果存储到 b 标号处的字中。

```assembly
assume cd:code,ds:data
data segment
	a db 1,2,3,4,5,6,7,8
	b dw 0
data ends

code segment
start: mov ax,data
	   mov ds,ax
       
       mov si,0
       mov cx,8
     s:mov al,a[si]
       mov ah,0
       add b,ax
       inc si
       loop s
       
       mov ax,4c00h
       int 21h
       
code ends
end start
```



注意，如果想在代码段中直接用数据标号访问数据，则需要用伪指令 assume 将标号所在的段和一个段寄存器联系起来。否则编译器在编译的时候，无法确定标号的段地址在哪一个寄存器中。当然，这种联系是编译器需要的，但绝对不是说，我们因为编译器的工作需要，用 assume 指令将段寄存器和某个段相联系，段寄存器中就会真的存放该段的地址。我们在程序中还要使用指令对段寄存器进行设置。

比如，在上面的程序汇总，我们要在代码段 code 中用 data 段中的数据标号 a、b 访问数据，则必须用 assume 将要给寄存器和 data 段相联。在程序中，我们用 ds 寄存器和 data 段相联，则编译器对相关指令的编译如下。

指令：	mov al,a[si]

编译为：mov al,[si+0]

指令：	add b,ax

编译为：add [8],ax



























