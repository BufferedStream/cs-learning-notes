## C程序设计语言读书笔记

### 第 1 章	导言

#### 1.1	入门

在 C 语言中，我们可以用下列程序打印出 “hello，world”：

```c
#include <stdio.h>				//包含标准库的信息
main()							//定义名为 main 的函数，它不接受参数值
{								//main 函数的语句都被括在花括号中
	printf("hello, world\n");	//main 函数调用库函数 printf 以显示字符序列；
}   							// \n 代表换行符
```



如何运行这个程序取决于所使用的系统。在 UNIX 操作系统中，首先必须在某个文件中建立这个源程序，并以 “.c” 作为文件的扩展名，例如 hello.c，然后再通过下列命令进行编译：cc hello.c，如果源程序没有什么错误，编辑过程将顺利进行，并生成一个可执行文件 a.out。然后，我们输入：a.out，即可运行 a.out，打印出下列信息：hello, world。在其他操作系统中，编译、加载、运行等规则会有所不同。

下面对程序本身做些说明。一个 C 语言程序，无论其大小如何，都是由函数和变量组成的。函数中包含一些语句，以指定所要执行的计算操作：变量则用于存储计算过程中使用的值。C 语言中的函数类似于 Fortan 语言中的子程序和函数，与 Pascal 语言中的过程和函数也很类似。在本例中，函数的名字为 main。通常情况下，函数的命名没有限制，但 main 是一个特殊的函数名——每个程序都从 main 函数的起点开始执行，这意味着每个程序都必须在某个位置包含一个 main 函数。

main 函数通常会调用其他函数来帮助完成某些工作，被调用的函数可以是程序设计人员自己编写的，也可以来自于函数库。上述程序段中的第一行语句

#include <stdio.h>

用于高速编译器在本程序中包含标准输入/输入库的信息。许多 C 语言源程序的开始处都包含这一行语句。我们将在第 7 章和附录 B 中对标准库进行详细介绍。

函数之间进行数据交换的一种方法是调用函数向被调用函数提供一个值（称为参数）列表。函数名后面的一对圆括号将参数列表括起来。在本例中，main 函数不需要任何参数，因此用空参数表 () 表示。

函数中的语句用一对花括号 {} 括起来。本例中的 main 函数仅包含下面一条语句：

printf("hello, world\n");

调用函数时，只需要使用函数名加上用圆括号括起来的参数表即可。上面这条语句将 “hello, world\n”。作为参数调用 printf 函数。printf 是一个用于打印输出的库函数，在此处，它打印双引号中间的字符串。

用双引号括起来的字符序列称为字符串或字符常量，如 “hello, world\n” 就是一个字符串。目前我们仅使用字符串作为 printf 及其它函数的参数。

在 C 语言中，字符序列 \n 表示换行符，在打印中遇到它时，输出打印将换行，从下一行的左端行首开始。如果去掉字符串中的 \n（这是个值得一做的联系），及时输出打印完成后也不会换行。在 printf 函数的参数中，只能用 \n 表示换行符。如果用程序的换行代替 \n，例如：

printf("hello, world

");

C 编译器将会产生一条错误信息。

printf 函数永远不会自动换行，这样我们可以多次调用该函数以分阶段得到一个长的输出行。上面给出的第一个程序也可以改写成下列形式：

```c
#include <stdio.h>
main()
{
	printf("hello, ");
	printf("world");
	printf("\n");
}
```



这段程序与前面的程序的输出相同。

请注意，\n 只代表一个字符。类似于 \n 的转义字符序列为表示无法输入的字符或不可见字符提供了一种通用的可扩充的机制。除此之外，C 语言提供的转义字符序列还包括：\t 表示制表符（类似于在记事本中输入 tab，表示 8 个空格的长度）；\b 表示回退符；\ " 表示双引号； \ \ 表示反斜杆符本身。2.3 节将给出转义字符序列的完整列表。

 



#### 1.2	变量与算术表达式

类型 int 表示其后所列变量为整数，与之相对应的，float 表示所列变量为浮点数（即可以带有小数部分的数）。int 与 float 类型的取值范围取决于具体的机器。对于 int 类型，通常为 16 位，其取值范围在 -32768~32767 之间，也有用 32 位表示的 int 类型。float 类型通常是 32 位，它至少有 6 位有效数字，取值范围一般都在 10^-38^ ~ 10^38^ 之间。

除 int 与 float 类型之外，c 语言还提供了其他一些基本数据类型，例如：

char	  	字符——一个字节

short		短整型

long	 	长整型

double	双精度浮点型

这些数据类型对象的大小也取决于具体的机器。另外，还存在这些基本数据类型的数组、结构、联合，指向这些类型的指针以及返回这些类型值的函数。 

如果某个算术运算符的所有操作符均为整型，则执行整型运算。但是，如果某个算术运算符有一个浮点型操作数和一个整型操作数，则在开始运算之前整型操作数将会被转换为浮点型。赋值语句与条件测试语句也是按照这种方式执行的。



#### 1.3	for 语句

for 语句比较适合初始化和增加步长都是单条语句并且逻辑相关的情形，因为它将循环控制语句集中放在一起，且比 while 语句更紧凑。



#### 1.4	符号常量

在程序中使用 “幻数”(magic number) 并不是一个好习惯，它们几乎无法向以后阅读该程序的人提供什么信息，而且使程序的修改变得更加困难。处理这种幻数的一种方法是赋予它们有意义的名字。#define 指令可以把符号名（或称为符号常量）定义为一个特定的字符串：

#define	名字	替换文本

在该定义之后，程序中出现的所有在 #define 中定义的名字（既没有用引号引起来，也不是其他名字的一部分）都将用相应的替换文本替换。其中，名字与普通变量名的形式相同：它们都是以字母打头的字母和数字序列：替换文本可以是任何字符序列，而不仅限于数字。

```C
#define LOWER	0	/* lower limit of table */
#define UPPER	0	/* upper limit */
#define STEP	0	/* step size */
```



符号常量名通常用大写字母拼写，这样可以很容易与小写字母拼写的变量名相区别。注意，#define 指令行的末尾没有分号。



#### 1.5	字符输入/输出

标准库提供的输入 / 输出模型非常简单。无论文本从何处输入，输出到何处，其输入 / 输出都是按照字符流的方式处理。文本流是由多行字符构成的字符序列，而每行字符则由 0 个或多个字符组成，行末是一个换行符。标准库负责使每个输入 / 输出流都能够遵守这一模型。使用标准库的 C 语言程序员不必关心在程序之外这些行是如何表示的。

标准库提供了一次读 / 写一个字符的函数，其中最简单的是 getchar 和 putchar 两个函数。每次调用时，getchar 函数从文本流中读入下一个输入字符，并将其作为结果值返回。也就是说，在执行语句

c = getchar()

之后，变量 c 中将包含输入流中的下一个字符。这种字符通常是通过键盘输入的。关于从文件输入字符的方法，我们将在第 7 章中讨论。

每次调用 putchr 函数时将打印一个字符。例如，语句

putchar()

将把整型变量 c 的内容以字符的形式打印出来，通常是显示在屏幕上。putchar 与 printf 这两个函数可以交替调用，输出的次序与调用的次序一致。



##### 1.5.1	文件复制

借助于 getchar 与 putchar 函数，可以在不了解其他输入 / 输出知识的情况下编写出数量惊人的有用的代码。最简单的例子就是把输入一次一个字符地复制到输出，其基本思想如下：

​	读一个字符

​	while (该字符不是文件结束指示符)

​		输出刚读入的字符

​		读下一个字符

将上述基本思想替换为 C 语言程序为：

```c
#include <stdio.h>

/* copy input to output; 1st version */
main()
{
	int c;

	c = getchar();
	while (c != EOF) {
		putchar(c);
		c = getchar();
	}	
}
```



其中，关系运算符 != 表示 “不等于”。

字符在键盘、屏幕或其它的任何地方无论以什么形式表现，它在机器内部都是以位模式存储的。char 类型专门用于存储这种字符型数据，当然任何整型（int）也可以用于存储字符型数据。因为某些潜在的重要原因，我们在此使用 int 类型。

这里需要解决如何区分文件中有效数据与输入结束符的问题。C 语言采取的解决方法是，在没有输入时，getchar 函数将返回一个特殊值，这个特殊值与任何实际字符都不同。这个值称为 EOF（end of file，文件结束）。我们在声明变量 C 的时候，必须让它大到足以存放 getchar 函数返回的任何值。这里之所以不把 c 声明成 char 类型，是因为它必须足够大，除了能存储任何可能的字符外还要能存储文件结束符 EOF。因此，我们将 c 声明成 int 类型。

EOF 定义在头文件 <stdio.h> 中，是个整型数，其具体数值是什么并不重要，只要它与任何 char 类型的值都不相同即可。这里使用符号常量，可以确保程序不需要依赖于其对应的任何特定的数值。

对于经验比较丰富的 C 语言程序员，可以把这个字符复制程序编写得更精炼一些。在 C 语言中，类似于

c = getchar()

之类的赋值操作是一个表达式，并且具有一个值，即赋值后左边变量保存的值。也就是说，赋值可以作为更大的表达式的一部分出现。如果将为 c 赋值的操作放在 while 循环语句的测试部分中，上述字符复制程序便可以改写成下列形式：

```c
#include <stdio.h>
/*	copy input to output; 2nd version	*/
main() 
{
	int c;
	
	while ((c = getchar()) != EOF)
		purchar(c);
}
```



在该程序中，while 循环语句首先读一个字符并将其赋值给 c，然后测试该字符是否为文件结束标志。如果该字符不是文件结束标志，则执行 while 语句体，并打印该字符。随后重复执行 while 语句。当到达输入的结尾位置时，while 循环语句终止执行，从而整个 main 函数执行结束。

以上这段程序将输入集中化，getchar 函数在程序中只出现了一次，这样就缩短了程序，整个程序看起来更紧凑。习惯这种风格后，读者就会发现按照这种方式编写的程序更易阅读。我们经常会看到这种风格。（不过，如果我们过多地使用这种类型的复杂语句，编写的程序可能会很难理解，应尽量避免这种情况。）

对 while 语句的条件部分来说，赋值表达式两边的圆括号不能省略。不等于运算符 != 的优先级比赋值运算符=的优先级要高，这样，在不使用圆括号的情况下关系测试 != 将在赋值 = 操作之前执行。因此语句

c = getchar() != EOF

等价于语句

c = (getchar() != EOF)

该语句执行后，c 的值将被置为 0 或 1 （取决于调用 getchar 函数时是否碰到文件结束标志），这并不是我们所希望的结果。



##### 1.5.2	字符计数

下列程序用于对字符数进行计数，它与上面的复制程序类似。

```c
#include <stdio.h>
/*	count characters in input; 1st version	*/
main()
{
	long nc;
    nc = 0;
    while (getchar() != EOF) {
        ++nc;
    }
    printf("%ld\n", nc);
}//在 vs 中运行这段程序，命令窗口无法输入 EOF，程序无法停止
```



其中，语句

++nc;

引入了一个新的运算符 ++，其功能是执行加 1 操作。可以用语句 nc = nc + 1 代替它，但语句 ++nc 更精炼一些，且通常效率也更高。与该运算符相应的是自减运算符 --。++ 与 -- 这两个运算符即可以作为前缀运算符（如 ++nc），也可以作为后缀运算符（如 nc++）。我们在第 2 章中将看到，这两种形式在表达式中具有不同的值。

该字符计数程序使用 long 类型的变量存放计数值，而没有使用 int 类型的变量。long 整型数（长整型）至少要占用 32 位存储单元。在某些机器上 int 与 long 类型的长度相同，但在一些机器上，int 类型的值可能只有 16 位存储单元的长度（最大值为 32767），这样，相当小的输入都可能使 int 类型的计数变量溢出。转换说明 %ld 告诉 printf 函数其对应的参数是 long 整型。

使用 double（双精度浮点数）类型可以处理更大的数字。我们在这里不使用 while 循环语句，而用 for 循环语句来展示编写此循环的另一种方法：

```c
#include <stdio.h>
/*	count characters in input; 1st version	*/
main()
{
	double nc;
    for (nc = 0; getchar() != EOF; ++nc)
       ;
    printf("%.0f\n", nc);
}
```



对于 float 与 double 类型。printf 函数都使用 %f 进行说明。%.0f 强制不打印小数点和小数部分，因此小数部分的位数为 0。



##### 1.5.3	行计数

接下来的这个程序用于统计输入中的行数。我们在上面提到过，标准库保证输入文本流以行序列的形式出现，每一行均以换行符结束。因此，统计行数等价于统计换行符的个数。

```c
#include <stdio.h>
/* count lines in input */
{
    int c,nl;
    nl = 0;
    while ((c = getchar()) != EOF) {
       if (c == '\n') {
          ++nl;  
        } 
    }
    printf("%d\n", nl);       
}
```



单引号中的字符表示一个整型值，该值等于此字符在机器字符集中对应的数值，我们称之为字符常量。但是，它只不过是小的整型数的另一种写法而已。例如，‘A’ 是一个字符常量；在 ASCII 字符集中其值为 65（即字符 A 的内部表示值为 65）.当然，用 ‘A’ 要比用 65 好，因为。‘A’ 的意义更清楚，且与特定的字符集无关。

字符串常量中使用的转义字符序列也是合法的字符常量，比如，'\n' 代表换行符的值，在 ASCII 字符集中其值为 10。我们应当注意到，'\n' 是单个字符，在表达式中它不过是一个整型数而已；而 “\n” 是一个仅包含一个字符的字符串常量。



##### 1.5.4	单词计数

我们将介绍的第 4 个实用程序用于统计行数、单词数与字符数。这里对单词的定义比较宽松，它是任何其中不包含空格、制表符或换行符的字符序列。下面这段程序是 UNIX 系统中 wc 程序的骨干部分：

```c
#include <stdio.h>

#define IN 1	/* inside a word */
#define out 0	/* outside a word */

/* count lines, words, and characters in input */
main()
{
    int c, nl, nw, nc, state;
    
    state = OUT;
    nl = nw = nc = 0;
    while ((c = getchar()) != EOF) {
        ++nc;
        if (c == '\n') {
            ++nl;
        }
        if (c == ' ' || c == '\n' || c == '\t') {
            state = OUT;
        } else if (state == OUT) {
            state = IN;
            ++nw;
        }
    }
}
printf("%d %d %d\n", nl, nw, nc);
```





#### 1.6	数组

数组下标可以是任何整型表达式，包括整型变量（如 i）以及整型常量。





#### 1.7	函数

下面是求幂函数 power(m, n) 的定义及调用它的主程序，这样我们可以看到要给完整的程序结构。

```c
#include <stdio.h>

int power(int m, int n);
/* test power function */
main()
{
    int i;
    for (i = 0; i < 10; ++i) {
        printf("%d %d %d\n", i, power(2, i), power(-3, i));
    }
    return 0;
}

int power(int base, int n) 
{
	int i, p;
    
    p = 1;
    for (i = 1; i <= n; ++i) {
        p = p * base;	
    }
    return p;
}
```



一般来说，返回值 0 表示正常终止，返回值为非 0 表示出现异常情况或出错结束条件。函数要向其调用者返回一个值，该调用者实际上就是程序的执行环境。





#### 1.8	参数——传值调用

在 C 语言中，所有函数参数都是 “通过值” 传递的。也就是说，传递给被调用函数的参数值存放在临时变量中，而不是存放在原来的变量中。这与其他某些语言是不同的，比如，Fortran 等语言是 “通过引用调用”，Pascal 则采用 var 参数的方式，在这些语言中，被调用的函数必须访问原始参数，而不是访问参数的本地副本。

最主要的区别在于，在 C 语言中，被调用函数不能直接修改主调函数中变量的值，而只能修改其私有的临时副本的值。

传值调用的利大于弊。在被调用函数中，参数可以看作是便于初始化的局部变量，因此额外使用的变量更少。这样程序可以更加紧凑简洁。

必要时，也可以让函数能够修改主调函数中的变量。这种情况下。调用者需要向被调用函数提供待设置值的变量的地址（从技术角度看，地址就是指向变量的指针），而被调用函数则需要将对应的参数声明为指针类型，并通过它间接访问变量。我们将在第 5 章中讨论指针。

如果是数组参数，情况就有所不同了。当把数组名用作参数时，传递给函数的值是数组起使元素的位置货地址——它并不复制数组元素本身。在被调用函数中，可以通过数组下标访问或修改数组元素的值。这是下一节将要讨论的问题。





#### 1.9	字符数组

字符数组是 C 语言中最常用的数组类型。函数的默认返回值类型为 int。

当在 C 语言程序中出现类似于 “hello\n” 的字符串常量时，它将以字符数组的形式参数，数组的各元素分别存储字符串的各个字符，并以 “\0” 标志字符串的结束。







printf 函数中的格式 %s 规定，对应的参数必须是以这种形式表示的字符串。



#### 1.10	外部变量与作用域

main 函数中的变量是 maim 函数的私有变量或局部变量。由于它们是在 main 函数中什么的，因此其他函数不能直接访问它们。其他函数中声明的变量也同样如此。函数中的每个局部变量只在函数被调用时存在，在函数执行完毕退出时消失。这也是其他语言通常把这类变量称为自动变量的原因。

由于自动变量只在函数调用执行期间存在，因此，在函数的两次调用之间，自动变量不保留前次调用时的赋值，且在每次进入函数时都要显示为其赋值。如果自动变量没有赋值，则其中存放的是无效值。

除自动变量外，还可以定义位于所有函数外部的变量，也就是说，在所有函数中都可以通过变量名访问这种类型的变量。由于外部变量可以在全局范围内访问，因此，函数间可以通过外部变量交换数据，而不必使用参数表。再者，外部变量在程序执行期间一直存在，而不是在函数调用时产生、在函数执行完毕时消失。即使在对外部变量赋值的函数返回后，这些变量仍将保持原来的值不变。

外部变量必须定义在所有函数之外，且只能定义一次，定义后编译程序将为它分配存储单元。在每个需要访问外部变量的函数中，必须声明相应的外部变量，此时说明其类型。声明时可以用 extern 语句显式声明，也可以通过上下文隐式声明。

从语法角度看，外部变量地定义与局部变量的定义是相同的，但由于他们位于各函数的外部，因此这些变量是外部变量。函数在使用外部变量之前，必须要知道外部变量的名字。要达到该目的，一种方式是在函数中使用 extern 类型的声明。这汇总类型的声明除了在前面加了一个关键字 extern 外，其他方面与普通变量的声明相同。

某些情况下可以省略 extern 声明。在源文件中，如果外部变量的定义出现在使用它的函数之前，那么在那个函数中就没有必要使用 extern 声明。在通常的做法中，所有外部变量的定义都放在源文件的开始处，这样就可以省略 extern 声明。

如果程序包含在多个源文件中，而某个变量在 file1 文件中定义、在 file2 和 file3 文件中使用，那么在文件 file2 与 file3 中就需要使用 extern 声明来建立该变量与其定义之间的联系。人们通常把变量和函数的 extern 声明放在一个单独的头文件中（习惯上称之为头文件），并在每个源文件的开头使用 #include 语句把所要用的头文件包含起来。后缀名 .h 约定为头文件名的扩展名。例如，标准库中的函数就是在类似于 <stdio.h> 的头文件中声明的。更详细的信息将在第 4 章中讨论，第 7 章及附录 B 将讨论函数库。

读者应该注意到，这节中我们在讨论外部变量时谨慎地使用了定义（define）与声明（declaration）这两个词。“定义” 表示创建变量或分配存储单元，而 “声明” 指的是说明变量的性纸，但并不分配存储单元。





### 第 2 章	类型、运算符与表达式

变量和常量是程序处理的两种基本数据对象。声明语句说明变量的名字及类型，也可以指定变量的初值。运算符指定将要进行的操作。表达式则把变量与常量组合起来生成新的值。对象的类型决定该对象可取值的集合以及可以对该对象执行的操作。本章将详细讲述这些内容。

ANSI 标准对语言的基本类型与表达式做了许多小的修改与增补，所有整型都包括 signed（带符号）和 unsigned（无符号）两种形式，且可以表示无符号常量与十六进制字符常量。浮点运算可以以单精度运行，还可以使用更高精度的 long double 类型运算。字符串常量可以在编译时链接。ANSI C 还支持枚举类型，该语言特性经过了长期的发展才形成。对象可以声明为 const（常量）类型，表明其值不能修改。该标准还对算术类型之间的自动强制转换规则进行了扩充，以适合于更多的数据类型。



#### 2.1	变量名

变量名是由字母和数字组成的序列，但其第一个字符必须为字母。下划线 “_” 被看作是字母，通常用于命名较长的变量名， 以提高其可读性。由于例程的名字通常以下划线开头，因此变量名不要以下划线开头。大写字母与小写字母是有区别的，所以，x 与 y 是两个不同的名字。在传统的 C 语言用法中，变量名使用小写字母，符号常量名全部使用大写字母。



#### 2.2	数据类型及长度

C 语言只提供了下列几种基本数据类型：

char		字符型，占用一个字节，可以存放本地字符集中的一个字符

int 	 	 整型，通常反映了所用机器中整数的最自然长度

float		单精度浮点型

double	双精度浮点型

此外，还可以在这些基本数据类型的前面加上一些限定符。short 与 long 两个限定符用于限定整型：

short int sh;

long int counter;

在上述这种类型的声明中，关键字 int 可以省略。通常很多人也习惯这么做。

short 与 long 两个限定符的引入可以为我们提供满足实际需要的不同长度的整型数。int 通常代表特定机器中整数的自然长度。short 类型通常为 16 位，long 类型通常为 32 位，int 类型可以为 16 位或 32 位。各编译器可以根据硬件特性自主选择合适的类型长度，但要遵循下列限制：short 与 int 类型至少为 16 位，而 long 类型至少为 32 位，并且 short 类型不得长于 int 类型，而 int 类型不得长于 long 类型。

类型限定符 signed 与 unsigned 可用于限定 char 类型或任何整型。unsigned 类型的数总是正值或 0，并遵守算术模 2^n^ 定律，其中 n 是该类型占用的位数。例如，如果 char 对象占用 8 位，那么 unsigned char 类型变量的取值范围为 0~255，而 signed char 类型变量的取值范围则为 -128~127（在采用对二的补码的机器上）。不带限定符的 char 类型对象是否带符号则取决于具体机器，但可打印字符总是正值。

long double 类型表示高精度的浮点数。同整型一样，浮点型的长度也取决于具体的实现。float、double 与 long double 类型可以表示相同的长度，也可以表示两种或三种不同的长度。

有关这些类型长度定义的符号常量以及其他与机器和编译器有关的属性可以在标准头文件 <limits.h> 与 <float.h> 中找到，这些内容将在附录 B 中讨论。



#### 2.3	常量

类似于 1234 的整数常量属于 int 类型。long 类型的常量以字母 1 或 L 结尾，如 123456789L。如果一个整数太大以至于无法用 int 类型表示时，也被当作 long 类型处理。无符号处理以字母 u 或 U 结尾。后缀 ul 或 UL 表明是 unsigned long 类型。

浮点数常量中包含一个小数电（如 123.4）或一个指数（如 1e-2），也可以两者都有。没有后缀的浮点数常量为 double 类型。后缀 f 或 F 表示 float 类型，二后缀 l 或 L 则表示 long double 类型。

整型数除了用十进制表示外，还可以用八进制或十六进制表示。带前缀 0 的整型常量表示它为八进制形式；前缀为 0x 或 0X，则表示它为十六进制形式。例如，十进制数 31 可以写成八进制形式 037，也可以写成十六进制形式 0x1f 或 0X1F。八进制与十六进制的常量也可以使用后缀 L 表示 long 类型，使用后缀 U 表示 unsigned 类型。例如，0XFUL 是一个 unsigned long 类型（无符号长整型）的常量，其值等于十进制数 15。

一个字符常量是一个整数，书写时将一个字符括在单引号中，如，’x‘。字符在机器字符集中的数值就是字符常量的值。例如，在 ASCII 字符集中，字符 ’0‘ 的值为 48，它与数值 0 没有关系。如果用字符 ’0‘ 代替这个与具体字符集有关的值（比如 48），那么，程序就无需关心该字符对应的具体值，增加了程序的易读性。字符常量一般用来与其他字符进行比较，但也可以像其他整数一样参与数值运算。

某些字符可以通过转义字符序列（例如，换行符 \n）表示为字符和字符串常量。转义字符序列看起来像两个字符，但只表示一个字符。另外，我们可以用

'\000'

表示任意的字节大小的位模式。其中，000 代表 1~3 个八进制数字（0~7）。这种位模式还可以用

'\xhh'

表示，其中，hh 是一个或多个十六进制数字（0~9，a ~f，A ~F）。因此，我们可以按照下列形式书写语句：

#define VTAB ’\013‘	/* ASCII vertical tab */

#define BELL '\007'	/* ASCII bell character */

上述语句也可以用十六进制的形式书写为：

#define VTAB '\xb'

#define BELL '\x7'

ANSI C 语言中的全部转义字符序列如下所示：

\a 响铃符        \ \ 反斜杠

\b 回退符        \? 问号

\f 换页符         \ ' 单引号

\n 换行符        \ " 双引号

\r 回车符         \ooo 八进制数

\t 横向制表符   \xhh 十六进制数

\v 纵向制表符

字符常量 ’\0‘ 表示值为 0 的字符，也就是空字符（null）。我们通常用 ’\0‘ 的形式代替 0，以强调某些表达式的字符属性，但其数字值为 0。

常量表达式是仅仅只包含常量的表达式。这种表达式在编译时求值，而不在运行时求值。它可以出现在常量可以出现的任何位置。

字符串常量也叫做字符串字面值，是用双引号括起来的 0 个或多个字符组成的字符序列。例如：

“I am a string” 

或 

"" 	/* 空字符串 */ 

都是字符串。双引号不是字符串的一部分，它只用于限定字符串。字符常量中使用的转义字符序列同样也可以用在字符串中。在字符串中使用 \ " 表示双引号字符。编译时可以将多个字符串常量连接起来，例如，下列形式：

"hello," " world"

等价于

"hello, world"

字符串常量的连接为将较长的字符串分散在若干个源文件行中提供了支持。

从技术角度看，字符串常量就是字符数组。字符串的内部表示使用一个空字符 ’\0‘ 作为串的结尾，因此。存储字符串的物理存储单元数比括在双引号中的字符数多一个。这种表示方法也说明，C 语言对字符串的长度没有限制，但程序必须扫描完整个字符串后才能确定字符串的长度。标准库函数 strlen(s) 可以返回字符串参数 s 的程度，但长度不包括末尾的 ’\0‘。

下面是我们设计的 strlen 函数的一个版本：

/* strlen：	return length of s*/

int strlen(char s[])

{

​	int i;

​	while (s[i] != '\0') {

​		++i;

​	}

​	return i;

}

标准头文件 <string.h> 中声明了 strlen 和其他字符串函数。

我们应该搞清楚字符常量与仅包含一个字符的字符串之间的区别：'x' 与 "X" 是不同的。前者是一个整数，其值是字母 x 在机器字符集中对应的数值（内部表示值）；后者是一个包含一个字符（即字母 x）以及一个结束符 '\0' 的字符数组。

枚举常量是另外一种类型的常量。枚举是一个常量整型值的列表，例如：

enum boolean { NO, YES };

在没有显式说明的情况下，enum 类型中第一个枚举名的值为 0，第二个为 1，依此类推。如果只指定了部分枚举名的值，那么未指定值的枚举名的值将依着最后一个指定值向后递增。

不同枚举中的名字必须互不相同。同一枚举中不同的名字可以具有相同的值。

枚举为建立常量值与名字之间的关联提供了一种便利的方式。相对于 #define 语句来说，它的优势在于常量值可以自动生成。尽管可以声明 enum 类型的变量，但编译器不检查这种类型的变量中存储的值是否为该枚举的有效值。不过，枚举变量提供这种检查，因此枚举比 #define 更具优势。此外，调式程序可以以符号形式打印出枚举变量的值。



#### 2.4	声明

所有变量都必须先声明后使用，尽管某些变量可以通过上下文隐式地上面。一个声明指定一种变量类型，后面所带的变量表可以包含一个或多个该类型的变量。例如：

int lower, upper, step;

char c, line[1000];

一个声明语句中的多个变量可以拆开在多个声明语句中声明。

还可以在声明的同时对变量进行初始化。在声明中，如果变量名的后面紧跟一个等号以及一个表达式，该表达式就充当对变量进行初始化的初始化表达式。

如果变量不是自动变量，则只能进行一次初始化操作，从概念上讲，应该是在程序开始执行之前进行，并且初始化表达式必须为常量表达式。每次进入函数或程序块时，显式初始化的自动变量都将被初始化一次，其初始化表达式可以是任何表达式。默认情况下，外部变量与静态变量将被初始化为 0。未经显式初始化的自动变量的值为未定义值（即无效值）。

任何变量的声明都可以使用 const 限定符限定。该限定符指定变量的值不能被修改。对数组而言，const 限定符指定数组所有元素的值都不能被修改。

const 限定符也可以配合数组参数使用，它表明函数不能修改数组元素的值；



#### 2.5	算术运算符

略



#### 2.6	关系运算符与逻辑运算符

略



#### 2.7	类型转换

略



#### 2.8	自增运算符与自减运算符

略



#### 2.9	按位运算符

略



#### 2.10	赋值运算符与表达式

略



#### 2.11	条件表达式

略



#### 2.12	运算符优先级与求值次序

略





### 第 3 章	控制流

略





### 第 4 章	函数与程序结构

函数可以把大的计算任务分解成若干个较小的任务，程序设计人员可以基于函数进一步构造程序，而不需要重新编写一些代码。一个设计得当的函数可以把程序中不需要了解的具体操作细节隐藏起来，从而使整个程序结构更加清晰，并降低修改程序的难度。

C 语言在设计中考虑了函数的高效性与易用性这两个因素。C 语言程序一般都由许多小的函数组成，而不是由少量较大的函数组成。一个程序可以保存在一个或者多个源文件中。各个文件可以单独编译，并可以与库中已编译过的函数一起加载。我们在这里不打算详细讨论这一过程，因为编译与加载的具体实现细节在各个编译系统中并不相同。



#### 4.1	函数的基本知识

首先我们来设计并编写一个程序，它将输入中包含特定 “模式” 或字符串的各行打印出来（这是 UNIX 程序 grep 的特例）例如，在下列一组文本行中查找包含字符串 “ould” 的行：

Ah Love! could you and I with Fate conspire, To grasp this sorry Scheme of Things entire, Would not we shatter it to bits -- and then Re-mould it nearer to the Heart's Desire!

程序执行后输出下列结果：

Ah Love! could you and I with Fate conspire Would not we shatter it to bits -- and then Re-mould it nearer to the Heart's Desire!

该任务可以明确地划分成下列 3 部分：

while（还有未处理的行）

​	if（该行包含指定的模式）

​		打印该行

尽管我们可以把所有的代码都放在主程序 main 中，但更好的做法是，利用其结构把每一部分设计成一个独立的函数。分别处理 3 个小的部分比处理一个大的整体更容易，因为这样可以把不相关的细节隐藏在函数中，从而减少了不必要的相互影响的机会，并且，这些函数也可以在其他程序中使用。



#### 4.2	返回非整型值的函数

略



#### 4.3	外部变量

C 语言程序可以看成由一系列的外部对象构成，这些外部对象可能是变量或函数。形容词 external 与 internal 相对的，internal 用于描述定义在函数内部的函数参数及变量。外部变量定义在函数之外，因此可以在许多函数中使用。由于 C 语言不允许在一个函数中定义其他函数，因此函数本身是 “外部的”。默认情况下，外部变量与函数具有下列性质：通过同一个名字对外部变量的所有引用（即使这种引用来自于单独编译的不同函数）实际上都是引用同一个对象（标准中把这一性质称为外部链接）。在这个意义上，外部变量类似于 Fortran 语言的 COMMON 块或 Pascal 语言中在最外层程序块中声明的变量。我们将在后面介绍如何定义只能在某一个源文件中使用的外部变量与函数。

因为外部变量可以在全局范围内访问，这就为函数之间的数据交换提供了一种可以代替函数参数与返回值的方式。任何函数都可以通过名字访问一个外部变量，当然这个名字需要通过某种方式进行声明。

如果函数之间需要共享大量的变量，使用外部变量要比使用要给很长的参数表更方便、有效。但是，我们在第 1 章中已经支持，这样做必须非常谨慎，因为这种方式可能对程序结构产生不良的影响，而且可能会导致程序中各个函数之间具有太多的数据联系。

外部变量的用途和表现在它们与内部变量相比具有更大的作用域和更长的生存期。自动变量只能在函数内部使用，从其所在的函数被调用时变量开始存在，在函数退出时变量也将消失。而外部变量是永久存在的，它们的值在一次函数调用到下一次函数调用之间保持不变。因此，如果两个函数必须共享某些数据，而这两个函数互不调用对方，这种情况下最方便的方式便是把这些共享数据定义为外部变量，而不是作为函数参数传递。

getch 与 ungetch 两个函数有什么用途呢？程序中经常会出现这样的情况：程序不能确定它已经读入的输入是否足够，除非超前多读入一些输入。读入一些字符以合成一个数字的情况便是一例：在看到第一个非数字字符之前，已经读入的数的完整性是不能确定的。由于程序要超前读入一个字符，这样就导致最后有一个字符不属于当前所要读入的数。

如果能 “反读” 不需要的字符，该问题就可以得到解决。每当程序多读入一个字符时，就把它压回到输入中，对代码其余部分而言就好像没有读入该字符一样。我们可以编写一对互相协作的函数来比较方便地模拟反取字符操作。getch 函数用于读入一个待处理的字符，而 ungetch 函数则用于把字符放回到输入中，这样，此后在调用 getch 函数时，在读入新的输入之前先返回 ungetch 函数放回的那个字符。

这两个函数之间的系统工作也很简单。ungetch 函数把要压回的字符放到一个共享缓冲区（字符数组）中，当该缓冲区不空时，getch 函数就从缓冲区中读取字符；当缓冲区为空时，getch 函数调用 getchar 函数直接从输入中读字符。这里还需要增加一个下标变量来记住缓冲区中当前字符的位置。

由于缓冲区与下标变量是供 getch 与 ungetch 函数共享的，且在两次调用之间必须保持值不变，因此它们必须是这两个函数的外部变量。

标准库中提供了 ungetc，它将一个字符压回到栈中，我们将在第 7 章中讨论该函数。





#### 4.4	作用域规则

构成 C 语言程序的函数与外部变量可以分开进行编译。一个程序可以存放在几个文件中，原先已编译过的函数可以从库中进行加载。这里我们感兴趣的问题有：

- 如何进行声明才能确保变量在编译时被正确声明？
- 如何安排声明的位置才能确保程序在加载时各部分能正确连接？
- 如何组织程序中的声明才能确保只有一份副本？
- 如何初始化外部变量？

名字的**作用域**指的是程序中可以使用该名字的部分。对于在函数开头声明的自动变量来说，其作用域是声明该变量名的函数。不同函数中声明的具有相同名字的各个局部变量之间没有任何关系。函数的参数也是这样的，实际上可以将它看做是局部变量。

外部变量或函数的作用域从声明它的地方开始，到其所在的（待编译的）文件的末尾结束。如下所示：

```C
main() { ... }

int sp = 0;
double val[MAXVAL];

void push(double f) { ... }
double pop(void) { ... }
```

那么，在 push 与 pop 这两个函数中不需要进行任何声明就可以通过名字访问变量 sp 与 val，但是，这两个变量名不能用在 main 函数中，push 与 pop 函数也不能用在 main 函数中。

另一方面，如果要在外部变量的定义之前使用该变量，或者外部变量的定义与变量的使用不在同一个源文件中，则必须在相应的变量声明中强制性地使用关键字 extern。

将外部变量的声明与定义严格区分开来很重要。变量声明用于说明变量的属性（主要是变量的类型），而变量定义除此之外还将引起存储器的分配。如果将下列语句放在所有函数的外部：

int sp;

double val[MAXVAL];

那么这两条语句将定义外部变量 sp 与 val，并为之分配存储单元，同时这两条语句还可以作为该源文件中其余部分的声明。而下面的两行语句：

extern int sp;

extern double val[];

为源文件的其余部分声明了一个 int 类型的外部变量 sp 以及一个 double 数组类型的外部变量 val（该数组的长度在其它地方确定），但这两个声明并没有建立变量或为它们分配存储单元。

在一个源程序的所有源文件中，一个外部变量只能在某个文件中定义一次，而其他文件可以通过 extern 声明来访问它（定义外部变量的源文件中也可以包含对该外部变量的 extern 声明）。外部变量的定义中必须指定数组的长度，但 extern 声明则不一定要指定数组的长度。

外部变量的初始化只能出现在其定义中。

假定函数 push 与 pop 定义在一个文件中，而变量 val 与 sp 在另一个文件中定义并被初始化（通常不大可能这样组织程序），则需要通过下面这些定义与声明把这些函数和变量 “绑定” 在一起：

在文件 file1 中：

extern int sp;

extern double val[];

void push(double f) { ... }

double pop(void) { ... }

在文件 file2 中：

int sp = 0;

double val[MAXVAL];

由于文件 file1 中的 extern 声明不仅放在函数定义的外面，而且在放在它们的前面，因此它们适用于该文件中的所有函数。对于 file1，这样一组声明就够了。如果要在同一个文件中先使用、后定义变量 sp 与 val，也需要按照这种方式组织文件。





#### 4.5	头文件

下面我们来考虑把上述的计算器程序分隔到若干个源文件中的情况。如果该程序的各组成部分很长，这么做还是有必要的。我们这样分隔：将主函数 main 单独放在文件 main.c 中；将 push 与 pop 函数以及它们使用的外部变量放在第二个文件 stack.c 中；将 getop 函数放在第三个文件 getop.c 中；将 getch 与 ungetch 函数放在第四个文件 getch.c 中。之所以分割成多个文件，主要是考虑在实际的程序中，它们分别来自于单独编译的库。

此外，还必须考虑定义和声明在这些文件之间的共享问题。我们尽可能把共享的部分集中在一起，这样就只需要一个副本，改进程序时也容易保证程序的正确性。我们把这些公共部分放在头文件 calc.h 中，在需要使用该头文件时通过 #include 指令将它包含进来（#include 指令将在 4.11 节中介绍）。这样分割后，程序的形式如下所示：





我们对下面两个因素进行了折衷：一方面是我们期望每个文件只能访问它完成任务所需的信息；另一方面是现实中维护较多的头文件比较困难。我们可以得出这样一个结论：对于某些中等规模的程序，最好只用一个头文件存放程序中各部分共享的对象。较大的程序需要使用更多的头文件，我们需要精心地组织它们。





#### 4.6	静态变量

某些变量，比如文件 stack.c 中定义的变量 sp 与 val 以及文件 getch.c 中定义的变量 buf 与 bufp，它们仅供其所在的源文件中的函数使用，其他函数不能访问。用 static 声明限定外部变量与函数，可以将其后声明的对象的作用域限定为被编译源文件的剩余部分。通过 static 限定外部对象，可以达到隐藏外部对象的目的，比如，getch-ungetch 复合结构需要共享 buf 与 bufp 两个变量，这样 buf 与 bufp 必须是外部变量，但这两个对象不应该被 getch 与 ungetch 函数的调用者所访问。

要将对象指定为静态存储，可以在正常的对象声明之前加上关键字 static 作为前缀。如果把上述两个函数和两个变量放在一个文件中编译，如下所示：

```c
static char buf[BUFSIZE];	/* buffer for ungetch */
static int bufp = 0;		/* next free position in buf */

int getch(void) { ... }

void ungetch(int c) { ... }
```



那么其它函数就不能访问变量 buf 与 bufp，因此这两个名字不会和同一程序中的其它文件中的相同的名字相冲突。同样，可以通过把变量 sp 与 val 声明为静态类型隐藏这两个由执行栈操作的 push 与 pop 函数使用的变量。

外部的 static 声明通常多用于变量，当然，它也可用于声明函数。通常情况下，函数名字是全局可访问的，对整个程序的各个部分而言都可见。但是，如果把函数声明为 static 类型，则该函数名除了对该函数声明所在的文件可见外，其它文件都无法访问。

static 也可以用于声明内部变量。static 类型的内部变量同自动变量一样，是某个特定函数的局部变量，只能在该函数中使用，但它与自动变量不同的是，不管其所在函数是否被调用，它一直存在，而不像自动变量那样，随着所在函数的被调用和退出而存在和消失。换句话说，static 类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量。





#### 4.7	寄存器变量

register 声明告诉编译器，它所声明的变量在程序中使用频率较高。其思想是，将 register 变量放在机器的寄存器中，这样可以使程序更小、执行速度更快。但编译器可以忽略此选项。

register 声明的形式如下所示：

register int x;

register char c;

register 声明只适用于自动变量以及函数的形式参数。下面是后一种情况的例子：

f (register unsigned m, register long n)

{

​	register int i;

​	...

}

实际使用时，底层硬件环境的实际情况对寄存器变量的使用会有一些限制。每个函数中只有很少的变量可以保存在寄存器中，且只允许某些类型的变量。但是，过量的寄存器声明并没有什么害处，这是因为编译器可以忽略过量的或不支持的寄存器变量声明。另外，无论寄存器变量实际上是不是存放在寄存器中，它的地址都是不能访问的（有关这一点更详细的信息，我们将在第 5 章中讨论）。在不同的机器中，对寄存器变量的数目和类型的具体限制也是不同的。





#### 4.8	程序块结构

C 语言并不是 Pascal 等语言意义上的程序块结构的语言，它不允许在函数中定义函数。但是，在函数中可以以程序块结构的形式定义变量。变量的声明（包括初始化）除了可以紧跟在函数开始的花括号之后，还可以紧跟在任何其它标识复合语句开始的左花括号之后。以这种方式声明的变量可以隐藏程序块外与之同名的变量，它们之间没有任何关系，并在与左花括号匹配的右花括号出现之前一直存在。例如，在下面的程序段中：

```c
if (n > 0) {
	int i;	/* declare a new i */
    
    for (i = 0; i < n; i++)
       ...
}
```



变量 i 的作用域是 if 语句的 “真” 分支，这个 i 与该程序块外声明的 i 无关。每次进入程序块时，在程序块内声明以及初始化的自动变量都将被初始化。静态变量只在第一次进入程序块时被初始化一次。

自动变量（包括形式参数）也可以隐藏同名的外部变量与函数。在下面的声明中：

```CQL
int x;
int y;

f(double x)
{
	double y;
}
```



函数 f 内的变量 x 引用的是函数的参数，类型为 double；而在函数 f 外，x 是 int 类型的外部变量。这段代码中的变量 y 也是如此。

在一个好的程序设计风格中，应该避免出现变量名隐藏外部作用域中相同名字的情况，否则，很可能引起混乱和错误。





#### 4.9	初始化

前面我们多次提到过初始化的概念，不过始终没有详细讨论。本节将对前面讨论的各种存储类的初始化规则做一个总结。

在不进行显式初始化的情况下，外部变量和静态变量都将被初始化为 0，而自动变量和寄存器变量的初值则没有定义（即初值为无用的信息）。

定义标量变量时，可以在变量名后紧跟一个等号和一个表达式来初始化变量：

int x = 1;

char squota = '\ '' ;

long dat = 1000L * 60L * 60L * 24L;	/* milliseconds/day */

对于外部变量与静态变量来说，初始化表达式必须是常量表达式，且只初始化一次（从概念上讲是在程序开始执行前进行初始化）。对于自动变量与寄存器常量，则在每次进入函数或程序块时都将被初始化。

对于自动变量与寄存器变量来说，初始化表达式可以不是常量表达式：表达式中可以包含任意在此表达式之前已经定义的值，包括函数调用，我们在 3.3 节中介绍的折半查找程序的初始化可以采用下列形式：

```c
int binsearch(int x, int v[], int n)
{
	int low = 0;
    int high = n - 1;
	int mid;
    ...
}
```

 

代替原来的形式：

```C
int low, high, mid;

low = 0;
high = n - 1;
```



实际上，自动变量的初始化等效于简写的赋值语句。究竟采用哪一种形式，还得看个人的习惯。考虑到变量声明中的初始化表达式容易被人忽略，且距使用的位置较远，我们一般使用显式的赋值语句。

数组的初始化可以在声明的后面紧跟一个初始化表达式列表，初始化表达式列表用花括号括起来，各初始化表达式之间通过逗号分隔。例如，如果要用一年中各月的天数初始化数组 days，其变量的定义如下：

int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

当省略数组的长度时，编译器将把花括号中的初始化表达式的个数作为数组的长度，在本例中数组的长度为 12。

如果初始化表达式的个数比数组元素数少，则对外部变量、静态变量和自动变量来说，没有初始化表达式的元素将被初始化为 0，如果初始化表达式的个数比数组元素数多，则是错误的。不能一次讲一个初始化表达式指定给多个数组元素，也不能跳过前面的数组元素而直接初始化后面的数组元素。

字符数组的初始化比较特殊：可以用一个字符串来代替用花括号括起来并用逗号分隔的初始化表达式序列。例如：

char pattern[] = "ould ";

它同下面的声明是等价的：

char pattern[] = { 'o', 'u', 'l', 'd'};

这种情况下，数组的长度是 5（4 个字符加上一个字符串结束符 '\0'）。





#### 4.10	递归

C 语言中的函数可以递归调用，即函数可以直接或间接调用自身。

有一个能较好说明递归的例子是快速排序。快速排序算法是 C.A.R.Hoare 于 1962 年发明的。对于一个给定的数组，从中选择一个元素，以该元素为界将其余元素划分为两个子集，一个子集中的所有元素都小于该元素，另一个子集中的所有元素都大于或等于该元素。对这样两个子集递归执行这一过程，当某个子集中的元素数小于 2 时，这个子集就不需要再次排序，终止递归。

从执行速度来讲，下列版本的快速排序函数可能不是最快的，但它是最简单的算法之一。在每次划分子集时，该算法总是选取各个子数组的中间元素。

```c
//qsort 函数：以递增顺序对 v[left]...v[right] 进行排序
void qsort(int v[], int left, int right)
{
    int i, last;
    void swap(int v[], int i, int j);
    if (left >= right) {	//若数组包含的元素数少于两个，则不执行任何操作	
        return;
    }
    //将划分子集的元素；整数除法会截断结果中的小数部分
    swap (v, left, (left + right)/2);	
    last = left;	//移动到 v[0]
    for (i = left + 1; i <= right; i++) {	//划分子集
        if (v[i] < v[left]) {
            swap(v, ++last, i);
        }
    }
    swap(v, left, last);	//恢复划分子集的元素
    qsort(v, left, last-1);
    qsort(v, last+1, rigth);
}

//这里之所以将数组元素交换操作放在一个单独的函数 swap 中，是因为它在 qsort 函数中要使用 3 次。

//swap 函数：交换 v[i] 与 v[j] 的值
void swap(int v[], int i, int j)
{
    int temp;
        
    temp = v[i];
    v[i] = v[j];
    v[j] = temp;
}
```



标准库中提供了一个 qsort 函数，它可用于对任何类型的对象排序。

递归并不节省存储器的开销，因为递归调用过程中必须在某个地方维护一个存储处理值的栈。递归的执行速度并不快，但递归代码比较紧凑，并且比相应的非递归代码更易于编写与理解。在描述树等递归定义的数据结构时使用递归尤其方便。我们将在 6.5 节中介绍一个比较好的例子。







































































































































































































