## C程序设计语言读书笔记

### 第 1 章	导言

#### 1.1	入门

在 C 语言中，我们可以用下列程序打印出 “hello，world”：

```c
#include <stdio.h>				//包含标准库的信息
main()							//定义名为 main 的函数，它不接受参数值
{								//main 函数的语句都被括在花括号中
	printf("hello, world\n");	//main 函数调用库函数 printf 以显示字符序列；
}   							// \n 代表换行符
```



如何运行这个程序取决于所使用的系统。在 UNIX 操作系统中，首先必须在某个文件中建立这个源程序，并以 “.c” 作为文件的扩展名，例如 hello.c，然后再通过下列命令进行编译：cc hello.c，如果源程序没有什么错误，编辑过程将顺利进行，并生成一个可执行文件 a.out。然后，我们输入：a.out，即可运行 a.out，打印出下列信息：hello, world。在其他操作系统中，编译、加载、运行等规则会有所不同。

下面对程序本身做些说明。一个 C 语言程序，无论其大小如何，都是由函数和变量组成的。函数中包含一些语句，以指定所要执行的计算操作：变量则用于存储计算过程中使用的值。C 语言中的函数类似于 Fortan 语言中的子程序和函数，与 Pascal 语言中的过程和函数也很类似。在本例中，函数的名字为 main。通常情况下，函数的命名没有限制，但 main 是一个特殊的函数名——每个程序都从 main 函数的起点开始执行，这意味着每个程序都必须在某个位置包含一个 main 函数。

main 函数通常会调用其他函数来帮助完成某些工作，被调用的函数可以是程序设计人员自己编写的，也可以来自于函数库。上述程序段中的第一行语句

#include <stdio.h>

用于高速编译器在本程序中包含标准输入/输入库的信息。许多 C 语言源程序的开始处都包含这一行语句。我们将在第 7 章和附录 B 中对标准库进行详细介绍。

函数之间进行数据交换的一种方法是调用函数向被调用函数提供一个值（称为参数）列表。函数名后面的一对圆括号将参数列表括起来。在本例中，main 函数不需要任何参数，因此用空参数表 () 表示。

函数中的语句用一对花括号 {} 括起来。本例中的 main 函数仅包含下面一条语句：

printf("hello, world\n");

调用函数时，只需要使用函数名加上用圆括号括起来的参数表即可。上面这条语句将 “hello, world\n”。作为参数调用 printf 函数。printf 是一个用于打印输出的库函数，在此处，它打印双引号中间的字符串。

用双引号括起来的字符序列称为字符串或字符常量，如 “hello, world\n” 就是一个字符串。目前我们仅使用字符串作为 printf 及其它函数的参数。

在 C 语言中，字符序列 \n 表示换行符，在打印中遇到它时，输出打印将换行，从下一行的左端行首开始。如果去掉字符串中的 \n（这是个值得一做的联系），及时输出打印完成后也不会换行。在 printf 函数的参数中，只能用 \n 表示换行符。如果用程序的换行代替 \n，例如：

printf("hello, world

");

C 编译器将会产生一条错误信息。

printf 函数永远不会自动换行，这样我们可以多次调用该函数以分阶段得到一个长的输出行。上面给出的第一个程序也可以改写成下列形式：

```c
#include <stdio.h>
main()
{
	printf("hello, ");
	printf("world");
	printf("\n");
}
```



这段程序与前面的程序的输出相同。

请注意，\n 只代表一个字符。类似于 \n 的转义字符序列为表示无法输入的字符或不可见字符提供了一种通用的可扩充的机制。除此之外，C 语言提供的转义字符序列还包括：\t 表示制表符（类似于在记事本中输入 tab，表示 8 个空格的长度）；\b 表示回退符；\ " 表示双引号； \ \ 表示反斜杆符本身。2.3 节将给出转义字符序列的完整列表。

 



#### 1.2	变量与算术表达式

类型 int 表示其后所列变量为整数，与之相对应的，float 表示所列变量为浮点数（即可以带有小数部分的数）。int 与 float 类型的取值范围取决于具体的机器。对于 int 类型，通常为 16 位，其取值范围在 -32768~32767 之间，也有用 32 位表示的 int 类型。float 类型通常是 32 位，它至少有 6 位有效数字，取值范围一般都在 10^-38^ ~ 10^38^ 之间。

除 int 与 float 类型之外，c 语言还提供了其他一些基本数据类型，例如：

char	  	字符——一个字节

short		短整型

long	 	长整型

double	双精度浮点型

这些数据类型对象的大小也取决于具体的机器。另外，还存在这些基本数据类型的数组、结构、联合，指向这些类型的指针以及返回这些类型值的函数。 

如果某个算术运算符的所有操作符均为整型，则执行整型运算。但是，如果某个算术运算符有一个浮点型操作数和一个整型操作数，则在开始运算之前整型操作数将会被转换为浮点型。赋值语句与条件测试语句也是按照这种方式执行的。



#### 1.3	for 语句

for 语句比较适合初始化和增加步长都是单条语句并且逻辑相关的情形，因为它将循环控制语句集中放在一起，且比 while 语句更紧凑。



#### 1.4	符号常量

在程序中使用 “幻数”(magic number) 并不是一个好习惯，它们几乎无法向以后阅读该程序的人提供什么信息，而且使程序的修改变得更加困难。处理这种幻数的一种方法是赋予它们有意义的名字。#define 指令可以把符号名（或称为符号常量）定义为一个特定的字符串：

#define	名字	替换文本

在该定义之后，程序中出现的所有在 #define 中定义的名字（既没有用引号引起来，也不是其他名字的一部分）都将用相应的替换文本替换。其中，名字与普通变量名的形式相同：它们都是以字母打头的字母和数字序列：替换文本可以是任何字符序列，而不仅限于数字。

```C
#define LOWER	0	/* lower limit of table */
#define UPPER	0	/* upper limit */
#define STEP	0	/* step size */
```



符号常量名通常用大写字母拼写，这样可以很容易与小写字母拼写的变量名相区别。注意，#define 指令行的末尾没有分号。



#### 1.5	字符输入/输出

标准库提供的输入 / 输出模型非常简单。无论文本从何处输入，输出到何处，其输入 / 输出都是按照字符流的方式处理。文本流是由多行字符构成的字符序列，而每行字符则由 0 个或多个字符组成，行末是一个换行符。标准库负责使每个输入 / 输出流都能够遵守这一模型。使用标准库的 C 语言程序员不必关心在程序之外这些行是如何表示的。

标准库提供了一次读 / 写一个字符的函数，其中最简单的是 getchar 和 putchar 两个函数。每次调用时，getchar 函数从文本流中读入下一个输入字符，并将其作为结果值返回。也就是说，在执行语句

c = getchar()

之后，变量 c 中将包含输入流中的下一个字符。这种字符通常是通过键盘输入的。关于从文件输入字符的方法，我们将在第 7 章中讨论。

每次调用 putchr 函数时将打印一个字符。例如，语句

putchar()

将把整型变量 c 的内容以字符的形式打印出来，通常是显示在屏幕上。putchar 与 printf 这两个函数可以交替调用，输出的次序与调用的次序一致。



##### 1.5.1	文件复制

借助于 getchar 与 putchar 函数，可以在不了解其他输入 / 输出知识的情况下编写出数量惊人的有用的代码。最简单的例子就是把输入一次一个字符地复制到输出，其基本思想如下：

​	读一个字符

​	while (该字符不是文件结束指示符)

​		输出刚读入的字符

​		读下一个字符

将上述基本思想替换为 C 语言程序为：

```c
#include <stdio.h>

/* copy input to output; 1st version */
main()
{
	int c;

	c = getchar();
	while (c != EOF) {
		putchar(c);
		c = getchar();
	}	
}
```



其中，关系运算符 != 表示 “不等于”。

字符在键盘、屏幕或其它的任何地方无论以什么形式表现，它在机器内部都是以位模式存储的。char 类型专门用于存储这种字符型数据，当然任何整型（int）也可以用于存储字符型数据。因为某些潜在的重要原因，我们在此使用 int 类型。

这里需要解决如何区分文件中有效数据与输入结束符的问题。C 语言采取的解决方法是，在没有输入时，getchar 函数将返回一个特殊值，这个特殊值与任何实际字符都不同。这个值称为 EOF（end of file，文件结束）。我们在声明变量 C 的时候，必须让它大到足以存放 getchar 函数返回的任何值。这里之所以不把 c 声明成 char 类型，是因为它必须足够大，除了能存储任何可能的字符外还要能存储文件结束符 EOF。因此，我们将 c 声明成 int 类型。

EOF 定义在头文件 <stdio.h> 中，是个整型数，其具体数值是什么并不重要，只要它与任何 char 类型的值都不相同即可。这里使用符号常量，可以确保程序不需要依赖于其对应的任何特定的数值。

对于经验比较丰富的 C 语言程序员，可以把这个字符复制程序编写得更精炼一些。在 C 语言中，类似于

c = getchar()

之类的赋值操作是一个表达式，并且具有一个值，即赋值后左边变量保存的值。也就是说，赋值可以作为更大的表达式的一部分出现。如果将为 c 赋值的操作放在 while 循环语句的测试部分中，上述字符复制程序便可以改写成下列形式：

```c
#include <stdio.h>
/*	copy input to output; 2nd version	*/
main() 
{
	int c;
	
	while ((c = getchar()) != EOF)
		purchar(c);
}
```



在该程序中，while 循环语句首先读一个字符并将其赋值给 c，然后测试该字符是否为文件结束标志。如果该字符不是文件结束标志，则执行 while 语句体，并打印该字符。随后重复执行 while 语句。当到达输入的结尾位置时，while 循环语句终止执行，从而整个 main 函数执行结束。

以上这段程序将输入集中化，getchar 函数在程序中只出现了一次，这样就缩短了程序，整个程序看起来更紧凑。习惯这种风格后，读者就会发现按照这种方式编写的程序更易阅读。我们经常会看到这种风格。（不过，如果我们过多地使用这种类型的复杂语句，编写的程序可能会很难理解，应尽量避免这种情况。）

对 while 语句的条件部分来说，赋值表达式两边的圆括号不能省略。不等于运算符 != 的优先级比赋值运算符=的优先级要高，这样，在不使用圆括号的情况下关系测试 != 将在赋值 = 操作之前执行。因此语句

c = getchar() != EOF

等价于语句

c = (getchar() != EOF)

该语句执行后，c 的值将被置为 0 或 1 （取决于调用 getchar 函数时是否碰到文件结束标志），这并不是我们所希望的结果。



##### 1.5.2	字符计数

下列程序用于对字符数进行计数，它与上面的复制程序类似。

```c
#include <stdio.h>
/*	count characters in input; 1st version	*/
main()
{
	long nc;
    nc = 0;
    while (getchar() != EOF) {
        ++nc;
    }
    printf("%ld\n", nc);
}//在 vs 中运行这段程序，命令窗口无法输入 EOF，程序无法停止
```



其中，语句

++nc;

引入了一个新的运算符 ++，其功能是执行加 1 操作。可以用语句 nc = nc + 1 代替它，但语句 ++nc 更精炼一些，且通常效率也更高。与该运算符相应的是自减运算符 --。++ 与 -- 这两个运算符即可以作为前缀运算符（如 ++nc），也可以作为后缀运算符（如 nc++）。我们在第 2 章中将看到，这两种形式在表达式中具有不同的值。

该字符计数程序使用 long 类型的变量存放计数值，而没有使用 int 类型的变量。long 整型数（长整型）至少要占用 32 位存储单元。在某些机器上 int 与 long 类型的长度相同，但在一些机器上，int 类型的值可能只有 16 位存储单元的长度（最大值为 32767），这样，相当小的输入都可能使 int 类型的计数变量溢出。转换说明 %ld 告诉 printf 函数其对应的参数是 long 整型。

使用 double（双精度浮点数）类型可以处理更大的数字。我们在这里不使用 while 循环语句，而用 for 循环语句来展示编写此循环的另一种方法：

```c
#include <stdio.h>
/*	count characters in input; 1st version	*/
main()
{
	double nc;
    for (nc = 0; getchar() != EOF; ++nc)
       ;
    printf("%.0f\n", nc);
}
```



对于 float 与 double 类型。printf 函数都使用 %f 进行说明。%.0f 强制不打印小数点和小数部分，因此小数部分的位数为 0。



##### 1.5.3	行计数

接下来的这个程序用于统计输入中的行数。我们在上面提到过，标准库保证输入文本流以行序列的形式出现，每一行均以换行符结束。因此，统计行数等价于统计换行符的个数。

```c
#include <stdio.h>
/* count lines in input */
{
    int c,nl;
    nl = 0;
    while ((c = getchar()) != EOF) {
       if (c == '\n') {
          ++nl;  
        } 
    }
    printf("%d\n", nl);       
}
```



单引号中的字符表示一个整型值，该值等于此字符在机器字符集中对应的数值，我们称之为字符常量。但是，它只不过是小的整型数的另一种写法而已。例如，‘A’ 是一个字符常量；在 ASCII 字符集中其值为 65（即字符 A 的内部表示值为 65）.当然，用 ‘A’ 要比用 65 好，因为。‘A’ 的意义更清楚，且与特定的字符集无关。

字符串常量中使用的转义字符序列也是合法的字符常量，比如，'\n' 代表换行符的值，在 ASCII 字符集中其值为 10。我们应当注意到，'\n' 是单个字符，在表达式中它不过是一个整型数而已；而 “\n” 是一个仅包含一个字符的字符串常量。



##### 1.5.4	单词计数

我们将介绍的第 4 个实用程序用于统计行数、单词数与字符数。这里对单词的定义比较宽松，它是任何其中不包含空格、制表符或换行符的字符序列。下面这段程序是 UNIX 系统中 wc 程序的骨干部分：

```c
#include <stdio.h>

#define IN 1	/* inside a word */
#define out 0	/* outside a word */

/* count lines, words, and characters in input */
main()
{
    int c, nl, nw, nc, state;
    
    state = OUT;
    nl = nw = nc = 0;
    while ((c = getchar()) != EOF) {
        ++nc;
        if (c == '\n') {
            ++nl;
        }
        if (c == ' ' || c == '\n' || c == '\t') {
            state = OUT;
        } else if (state == OUT) {
            state = IN;
            ++nw;
        }
    }
}
printf("%d %d %d\n", nl, nw, nc);
```





#### 1.6	数组

数组下标可以是任何整型表达式，包括整型变量（如 i）以及整型常量。





#### 1.7	函数

下面是求幂函数 power(m, n) 的定义及调用它的主程序，这样我们可以看到要给完整的程序结构。

```c
#include <stdio.h>

int power(int m, int n);
/* test power function */
main()
{
    int i;
    for (i = 0; i < 10; ++i) {
        printf("%d %d %d\n", i, power(2, i), power(-3, i));
    }
    return 0;
}

int power(int base, int n) 
{
	int i, p;
    
    p = 1;
    for (i = 1; i <= n; ++i) {
        p = p * base;	
    }
    return p;
}
```



一般来说，返回值 0 表示正常终止，返回值为非 0 表示出现异常情况或出错结束条件。函数要向其调用者返回一个值，该调用者实际上就是程序的执行环境。





#### 1.8	参数——传值调用

在 C 语言中，所有函数参数都是 “通过值” 传递的。也就是说，传递给被调用函数的参数值存放在临时变量中，而不是存放在原来的变量中。这与其他某些语言是不同的，比如，Fortran 等语言是 “通过引用调用”，Pascal 则采用 var 参数的方式，在这些语言中，被调用的函数必须访问原始参数，而不是访问参数的本地副本。

最主要的区别在于，在 C 语言中，被调用函数不能直接修改主调函数中变量的值，而只能修改其私有的临时副本的值。

传值调用的利大于弊。在被调用函数中，参数可以看作是便于初始化的局部变量，因此额外使用的变量更少。这样程序可以更加紧凑简洁。

必要时，也可以让函数能够修改主调函数中的变量。这种情况下。调用者需要向被调用函数提供待设置值的变量的地址（从技术角度看，地址就是指向变量的指针），而被调用函数则需要将对应的参数声明为指针类型，并通过它间接访问变量。我们将在第 5 章中讨论指针。

如果是数组参数，情况就有所不同了。当把数组名用作参数时，传递给函数的值是数组起使元素的位置货地址——它并不复制数组元素本身。在被调用函数中，可以通过数组下标访问或修改数组元素的值。这是下一节将要讨论的问题。





#### 1.9	字符数组

字符数组是 C 语言中最常用的数组类型。下面我们通过编写一个程序，来说明字符数组以及操作字符数组的函数的用法。该程序读入一组文本行，并把最长的文本行打印出来。该算法的基本框架非常简单：

while（还有未处理的行）

if （该行比已处理的最长行还要长）

​	保存该行为最长行

​	保存改行的长度

打印最长的行



从上面的框架中很容易看出，程序很自然地分成了若干片段，分别用于读入新行、测试读入的行、保存该行，其余部分则控制这一过程。

因为这种划分方式比较合理，所以可以按照这种方式编写程序。首先骂我们编写一个独立的函数 getline，它读取输入的下一行。我们尽量保持该函数再其它场合也有用。至少 getline 函数应该再读到文件末尾时返回一个信号；更为有用的设计是它能够再读入文本行时返回该行的长度，而在遇到文件结束符时返回 0。由于 0 不是有效的行长度，因此可以作为标志文件结束的返回值。每一行至少包括一个字符，只包含换行符的行，其长度为 1。

当发现某个新读入的行比以前读入的最长行还要长时，就需要把该行保存起来。也就是说，我们需要用另一个函数 copy 把新行复制到一个安全的位置。

最后，我们需要在主函数 main 中控制 getline 和 copy 这两个函数。一下便是我们编写的程序：

```c
#include <stdio.h>
#define MAXLINE 1000	//允许的输入行的最大长度

int getline(char line[], int maxline)
void copy(char to[], char from[]);

//打印最长的输入行
main()
{
    int len;	//当前行长度
    int max;	//目前为止发现的最大行的长度
    char line[MAXLINE];		//当前的输入行
    char longest[MAXLINE];	//用于保存最长的行
    
    max = 0;
    while ((len = getline(line, MAXLINE)) > 0) {
        if (len > max) {
            max = len;
            copy(longest, line);
        }
    }
    if (max > 0) {	//存在这样的行
        printf("%s", longest);
    }
    return 0;
}

//getline函数：将一行读入到 s 中并返回其长度
int getline(char s[], int lim)
{
    int c, i;
    
    for (i=0; i < lim - 1 && (c=getchar()) != EOF && c!='\n'; ++i)) {
        s[i] = c;
    }
    if (c == '\n') {
        s[i] = c;
    	++i;
    }
    s[i] = '\0';
    return i;
}

//copy函数：将 from 复制到 to；这里假定 to 足够大
void copy(char to[], char from[])
{
    int i;
    
    i = 0;
    while ((to[i] = from[i]) != '\0') {
        ++i;
    }
}
```



程序的开始对 getline 和 copy 这两个函数进行了声明，这里假定它们都存放在同一个文件中。

main 与 getline 之间通过一对参数及一个返回值进行数据交换。在 getline 函数中，两个参数是通过程序行

int getline(char s[], int lim)

声明的，它把第一个参数 s 声明为数组，把第二个参数 lim 声明为整型，声明中提供数组大小的目的是留出存储空间。在 getline 函数中没有必要指明数组 s 的长度，这是因为该数组的大小是在 main 函数中设置的。如果 power 函数一样，getline 函数使用了一个 return 语句将值返回给其调用者。上述程序行也声明了 getline 函数的返回值类型为 int。由于函数的默认返回值类型为 int，因此这里的 int 可以省略。

有些函数返回有用的值，而有些函数（如 copy）仅用于指向一些动作，并不返回值。copy 函数的返回值类型为 void，它显式说明该函数不返回任何值。

getline 函数把字符 '\0'（即空字符，其值为 0）插入到它创建的数组的末尾，以标记字符串的结束。这一约定已被 C 语言采用：当在 C 语言程序中出现类似于

"hello\0"

的字符串常量时，它将以字符数组的形式存储，数组的个元素分别存储字符串的各个字符，并以 '\0' 标志字符串的结束。

<div align=center>
	<img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/C程序设计语言 - 图1.jpg"/>
</div>

printf 函数中的格式 %s 规定，对应的参数必须是以这种形式表示的字符串。copy 函数的实现正是依赖于输入参数由 '\0' 结束这一事实，它将 '\0' 拷贝到输出参数中。（也就是说，空字符 '\0' 不是普通文本的一部分。）





#### 1.10	外部变量与作用域

main 函数中的变量是 maim 函数的私有变量或局部变量。由于它们是在 main 函数中什么的，因此其他函数不能直接访问它们。其他函数中声明的变量也同样如此。函数中的每个局部变量只在函数被调用时存在，在函数执行完毕退出时消失。这也是其他语言通常把这类变量称为自动变量的原因。

由于自动变量只在函数调用执行期间存在，因此，在函数的两次调用之间，自动变量不保留前次调用时的赋值，且在每次进入函数时都要显示为其赋值。如果自动变量没有赋值，则其中存放的是无效值。

除自动变量外，还可以定义位于所有函数外部的变量，也就是说，在所有函数中都可以通过变量名访问这种类型的变量。由于外部变量可以在全局范围内访问，因此，函数间可以通过外部变量交换数据，而不必使用参数表。再者，外部变量在程序执行期间一直存在，而不是在函数调用时产生、在函数执行完毕时消失。即使在对外部变量赋值的函数返回后，这些变量仍将保持原来的值不变。

外部变量必须定义在所有函数之外，且只能定义一次，定义后编译程序将为它分配存储单元。在每个需要访问外部变量的函数中，必须声明相应的外部变量，此时说明其类型。声明时可以用 extern 语句显式声明，也可以通过上下文隐式声明。

从语法角度看，外部变量地定义与局部变量的定义是相同的，但由于他们位于各函数的外部，因此这些变量是外部变量。函数在使用外部变量之前，必须要知道外部变量的名字。要达到该目的，一种方式是在函数中使用 extern 类型的声明。这汇总类型的声明除了在前面加了一个关键字 extern 外，其他方面与普通变量的声明相同。

某些情况下可以省略 extern 声明。在源文件中，如果外部变量的定义出现在使用它的函数之前，那么在那个函数中就没有必要使用 extern 声明。在通常的做法中，所有外部变量的定义都放在源文件的开始处，这样就可以省略 extern 声明。

如果程序包含在多个源文件中，而某个变量在 file1 文件中定义、在 file2 和 file3 文件中使用，那么在文件 file2 与 file3 中就需要使用 extern 声明来建立该变量与其定义之间的联系。人们通常把变量和函数的 extern 声明放在一个单独的头文件中（习惯上称之为头文件），并在每个源文件的开头使用 #include 语句把所要用的头文件包含起来。后缀名 .h 约定为头文件名的扩展名。例如，标准库中的函数就是在类似于 <stdio.h> 的头文件中声明的。更详细的信息将在第 4 章中讨论，第 7 章及附录 B 将讨论函数库。

读者应该注意到，这节中我们在讨论外部变量时谨慎地使用了定义（define）与声明（declaration）这两个词。“定义” 表示创建变量或分配存储单元，而 “声明” 指的是说明变量的性纸，但并不分配存储单元。





### 第 2 章	类型、运算符与表达式

变量和常量是程序处理的两种基本数据对象。声明语句说明变量的名字及类型，也可以指定变量的初值。运算符指定将要进行的操作。表达式则把变量与常量组合起来生成新的值。对象的类型决定该对象可取值的集合以及可以对该对象执行的操作。本章将详细讲述这些内容。

ANSI 标准对语言的基本类型与表达式做了许多小的修改与增补，所有整型都包括 signed（带符号）和 unsigned（无符号）两种形式，且可以表示无符号常量与十六进制字符常量。浮点运算可以以单精度运行，还可以使用更高精度的 long double 类型运算。字符串常量可以在编译时链接。ANSI C 还支持枚举类型，该语言特性经过了长期的发展才形成。对象可以声明为 const（常量）类型，表明其值不能修改。该标准还对算术类型之间的自动强制转换规则进行了扩充，以适合于更多的数据类型。



#### 2.1	变量名

变量名是由字母和数字组成的序列，但其第一个字符必须为字母。下划线 “_” 被看作是字母，通常用于命名较长的变量名， 以提高其可读性。由于例程的名字通常以下划线开头，因此变量名不要以下划线开头。大写字母与小写字母是有区别的，所以，x 与 y 是两个不同的名字。在传统的 C 语言用法中，变量名使用小写字母，符号常量名全部使用大写字母。



#### 2.2	数据类型及长度

C 语言只提供了下列几种基本数据类型：

char		字符型，占用一个字节，可以存放本地字符集中的一个字符

int 	 	 整型，通常反映了所用机器中整数的最自然长度

float		单精度浮点型

double	双精度浮点型

此外，还可以在这些基本数据类型的前面加上一些限定符。short 与 long 两个限定符用于限定整型：

short int sh;

long int counter;

在上述这种类型的声明中，关键字 int 可以省略。通常很多人也习惯这么做。

short 与 long 两个限定符的引入可以为我们提供满足实际需要的不同长度的整型数。int 通常代表特定机器中整数的自然长度。short 类型通常为 16 位，long 类型通常为 32 位，int 类型可以为 16 位或 32 位。各编译器可以根据硬件特性自主选择合适的类型长度，但要遵循下列限制：short 与 int 类型至少为 16 位，而 long 类型至少为 32 位，并且 short 类型不得长于 int 类型，而 int 类型不得长于 long 类型。

类型限定符 signed 与 unsigned 可用于限定 char 类型或任何整型。unsigned 类型的数总是正值或 0，并遵守算术模 2^n^ 定律，其中 n 是该类型占用的位数。例如，如果 char 对象占用 8 位，那么 unsigned char 类型变量的取值范围为 0~255，而 signed char 类型变量的取值范围则为 -128~127（在采用对二的补码的机器上）。不带限定符的 char 类型对象是否带符号则取决于具体机器，但可打印字符总是正值。

long double 类型表示高精度的浮点数。同整型一样，浮点型的长度也取决于具体的实现。float、double 与 long double 类型可以表示相同的长度，也可以表示两种或三种不同的长度。

有关这些类型长度定义的符号常量以及其他与机器和编译器有关的属性可以在标准头文件 <limits.h> 与 <float.h> 中找到，这些内容将在附录 B 中讨论。



#### 2.3	常量

类似于 1234 的整数常量属于 int 类型。long 类型的常量以字母 1 或 L 结尾，如 123456789L。如果一个整数太大以至于无法用 int 类型表示时，也被当作 long 类型处理。无符号处理以字母 u 或 U 结尾。后缀 ul 或 UL 表明是 unsigned long 类型。

浮点数常量中包含一个小数电（如 123.4）或一个指数（如 1e-2），也可以两者都有。没有后缀的浮点数常量为 double 类型。后缀 f 或 F 表示 float 类型，二后缀 l 或 L 则表示 long double 类型。

整型数除了用十进制表示外，还可以用八进制或十六进制表示。带前缀 0 的整型常量表示它为八进制形式；前缀为 0x 或 0X，则表示它为十六进制形式。例如，十进制数 31 可以写成八进制形式 037，也可以写成十六进制形式 0x1f 或 0X1F。八进制与十六进制的常量也可以使用后缀 L 表示 long 类型，使用后缀 U 表示 unsigned 类型。例如，0XFUL 是一个 unsigned long 类型（无符号长整型）的常量，其值等于十进制数 15。

一个字符常量是一个整数，书写时将一个字符括在单引号中，如，’x‘。字符在机器字符集中的数值就是字符常量的值。例如，在 ASCII 字符集中，字符 ’0‘ 的值为 48，它与数值 0 没有关系。如果用字符 ’0‘ 代替这个与具体字符集有关的值（比如 48），那么，程序就无需关心该字符对应的具体值，增加了程序的易读性。字符常量一般用来与其他字符进行比较，但也可以像其他整数一样参与数值运算。

某些字符可以通过转义字符序列（例如，换行符 \n）表示为字符和字符串常量。转义字符序列看起来像两个字符，但只表示一个字符。另外，我们可以用

'\000'

表示任意的字节大小的位模式。其中，000 代表 1~3 个八进制数字（0~7）。这种位模式还可以用

'\xhh'

表示，其中，hh 是一个或多个十六进制数字（0~9，a ~f，A ~F）。因此，我们可以按照下列形式书写语句：

#define VTAB ’\013‘	/* ASCII vertical tab */

#define BELL '\007'	/* ASCII bell character */

上述语句也可以用十六进制的形式书写为：

#define VTAB '\xb'

#define BELL '\x7'

ANSI C 语言中的全部转义字符序列如下所示：

\a 响铃符        \ \ 反斜杠

\b 回退符        \? 问号

\f 换页符         \ ' 单引号

\n 换行符        \ " 双引号

\r 回车符         \ooo 八进制数

\t 横向制表符   \xhh 十六进制数

\v 纵向制表符

字符常量 ’\0‘ 表示值为 0 的字符，也就是空字符（null）。我们通常用 ’\0‘ 的形式代替 0，以强调某些表达式的字符属性，但其数字值为 0。

常量表达式是仅仅只包含常量的表达式。这种表达式在编译时求值，而不在运行时求值。它可以出现在常量可以出现的任何位置。

字符串常量也叫做字符串字面值，是用双引号括起来的 0 个或多个字符组成的字符序列。例如：

“I am a string” 

或 

"" 	/* 空字符串 */ 

都是字符串。双引号不是字符串的一部分，它只用于限定字符串。字符常量中使用的转义字符序列同样也可以用在字符串中。在字符串中使用 \ " 表示双引号字符。编译时可以将多个字符串常量连接起来，例如，下列形式：

"hello," " world"

等价于

"hello, world"

字符串常量的连接为将较长的字符串分散在若干个源文件行中提供了支持。

从技术角度看，字符串常量就是字符数组。字符串的内部表示使用一个空字符 ’\0‘ 作为串的结尾，因此。存储字符串的物理存储单元数比括在双引号中的字符数多一个。这种表示方法也说明，C 语言对字符串的长度没有限制，但程序必须扫描完整个字符串后才能确定字符串的长度。标准库函数 strlen(s) 可以返回字符串参数 s 的程度，但长度不包括末尾的 ’\0‘。

下面是我们设计的 strlen 函数的一个版本：

/* strlen：	return length of s*/

int strlen(char s[])

{

​	int i;

​	while (s[i] != '\0') {

​		++i;

​	}

​	return i;

}

标准头文件 <string.h> 中声明了 strlen 和其他字符串函数。

我们应该搞清楚字符常量与仅包含一个字符的字符串之间的区别：'x' 与 "X" 是不同的。前者是一个整数，其值是字母 x 在机器字符集中对应的数值（内部表示值）；后者是一个包含一个字符（即字母 x）以及一个结束符 '\0' 的字符数组。

枚举常量是另外一种类型的常量。枚举是一个常量整型值的列表，例如：

enum boolean { NO, YES };

在没有显式说明的情况下，enum 类型中第一个枚举名的值为 0，第二个为 1，依此类推。如果只指定了部分枚举名的值，那么未指定值的枚举名的值将依着最后一个指定值向后递增。

不同枚举中的名字必须互不相同。同一枚举中不同的名字可以具有相同的值。

枚举为建立常量值与名字之间的关联提供了一种便利的方式。相对于 #define 语句来说，它的优势在于常量值可以自动生成。尽管可以声明 enum 类型的变量，但编译器不检查这种类型的变量中存储的值是否为该枚举的有效值。不过，枚举变量提供这种检查，因此枚举比 #define 更具优势。此外，调式程序可以以符号形式打印出枚举变量的值。



#### 2.4	声明

所有变量都必须先声明后使用，尽管某些变量可以通过上下文隐式地上面。一个声明指定一种变量类型，后面所带的变量表可以包含一个或多个该类型的变量。例如：

int lower, upper, step;

char c, line[1000];

一个声明语句中的多个变量可以拆开在多个声明语句中声明。

还可以在声明的同时对变量进行初始化。在声明中，如果变量名的后面紧跟一个等号以及一个表达式，该表达式就充当对变量进行初始化的初始化表达式。

如果变量不是自动变量，则只能进行一次初始化操作，从概念上讲，应该是在程序开始执行之前进行，并且初始化表达式必须为常量表达式。每次进入函数或程序块时，显式初始化的自动变量都将被初始化一次，其初始化表达式可以是任何表达式。默认情况下，外部变量与静态变量将被初始化为 0。未经显式初始化的自动变量的值为未定义值（即无效值）。

任何变量的声明都可以使用 const 限定符限定。该限定符指定变量的值不能被修改。对数组而言，const 限定符指定数组所有元素的值都不能被修改。

const 限定符也可以配合数组参数使用，它表明函数不能修改数组元素的值；



#### 2.5	算术运算符

略



#### 2.6	关系运算符与逻辑运算符

略



#### 2.7	类型转换

略



#### 2.8	自增运算符与自减运算符

略



#### 2.9	按位运算符

略



#### 2.10	赋值运算符与表达式

略



#### 2.11	条件表达式

略



#### 2.12	运算符优先级与求值次序

略





### 第 3 章	控制流

略





### 第 4 章	函数与程序结构

函数可以把大的计算任务分解成若干个较小的任务，程序设计人员可以基于函数进一步构造程序，而不需要重新编写一些代码。一个设计得当的函数可以把程序中不需要了解的具体操作细节隐藏起来，从而使整个程序结构更加清晰，并降低修改程序的难度。

C 语言在设计中考虑了函数的高效性与易用性这两个因素。C 语言程序一般都由许多小的函数组成，而不是由少量较大的函数组成。一个程序可以保存在一个或者多个源文件中。各个文件可以单独编译，并可以与库中已编译过的函数一起加载。我们在这里不打算详细讨论这一过程，因为编译与加载的具体实现细节在各个编译系统中并不相同。



#### 4.1	函数的基本知识

首先我们来设计并编写一个程序，它将输入中包含特定 “模式” 或字符串的各行打印出来（这是 UNIX 程序 grep 的特例）例如，在下列一组文本行中查找包含字符串 “ould” 的行：

Ah Love! could you and I with Fate conspire, To grasp this sorry Scheme of Things entire, Would not we shatter it to bits -- and then Re-mould it nearer to the Heart's Desire!

程序执行后输出下列结果：

Ah Love! could you and I with Fate conspire Would not we shatter it to bits -- and then Re-mould it nearer to the Heart's Desire!

该任务可以明确地划分成下列 3 部分：

while（还有未处理的行）

​	if（该行包含指定的模式）

​		打印该行

尽管我们可以把所有的代码都放在主程序 main 中，但更好的做法是，利用其结构把每一部分设计成一个独立的函数。分别处理 3 个小的部分比处理一个大的整体更容易，因为这样可以把不相关的细节隐藏在函数中，从而减少了不必要的相互影响的机会，并且，这些函数也可以在其他程序中使用。

我们用函数 getline 实现 “还有未处理的行”，该函数在第 1 章中介绍过：用 printf 函数实现 “打印该行”，这个函数是现成的，别人已经提供了。也就是说，我们只需要编写一个判定 “该行包含指定的模式” 的函数。

我们编写函数 strindex(s, t) 实现该目标。该函数返回字符串 t 在字符串 s 中出现的起始位置或索引。当 s 不包含 t 时，返回值为 -1。由于 C 语言数组的下标从 0 开始，下标的值只可能为 0 或正数，因此可以用像 -1 这样的负数表示失败的情况。如果以后需要进行更复杂的模式匹配，只需替换 strindex 函数即可，程序的其余部分可保持不变。（标准库中提供的库函数 strstr 的功能类似于 strindex 函数，但该库函数返回的是指针而不是下标值。）

完成这样的设计后，编写整个程序的细节就直截了当了。下面列出的就是一个完整的程序，读者可以查看各部分是怎样组合在一起的。我们现在查找的模式是字符串字面值，它不是一种最通用的机制。我们在这里只简单讨论字符数组的初始化方法，第 5 章将介绍如何在程序运行时将模式作为参数传递给函数。其中，getline 函数较前面的版本也稍有不同，读者可将它与第 1 章中的版本进行比较，或许会得到一些启发。

```c
#include <stdio.h>
#define MAXLINE 1000	//最大输入行长度

int getlien(char line[], int max);
int strindex(char source[], char searchfor[]);

char pattern[] = "ould";	//待查找的模式

//找出所有与模式匹配的行
main()
{
    char line[MAXLINE];
    int found = 0;
    
    while (getline(line, MAXLINE) > 0) {
        if (strindex(line, pattern) >= 0) {
            printf("%s", line);
            found++;
        }
    }        
}

//getline函数：将行保存到 s 中，并返回该行的长度
int getline(char s[], int lim)
{
	int c, i;
    
    i = 0;
    while (--lim > 0 && (c=getchar()) != EOF && c != '\n') {
        s[i++] = c;
    }
        
    if (c == '\n') {
        s[i++] = c;
    }
    s[i] = '\0';
    return i;
}

//strindex函数：返回 t 在 s 中的位置，若未找到则返回 -1
int strindex(char s[], char t[])
{
    int i, j, k;
    for (i = 0; s[i] != '\0'; i++) {
        for (j=i, k=0; t[k] != '\0' && s[j]==t[k]; j++, k++) {
            ;
        }
        if (k > 0 && t[k] == '\0') {
            return i;
        }   
    }
    return -1;
}
```





#### 4.2	返回非整型值的函数

略



#### 4.3	外部变量

C 语言程序可以看成由一系列的外部对象构成，这些外部对象可能是变量或函数。形容词 external 与 internal 相对的，internal 用于描述定义在函数内部的函数参数及变量。外部变量定义在函数之外，因此可以在许多函数中使用。由于 C 语言不允许在一个函数中定义其他函数，因此函数本身是 “外部的”。默认情况下，外部变量与函数具有下列性质：通过同一个名字对外部变量的所有引用（即使这种引用来自于单独编译的不同函数）实际上都是引用同一个对象（标准中把这一性质称为外部链接）。在这个意义上，外部变量类似于 Fortran 语言的 COMMON 块或 Pascal 语言中在最外层程序块中声明的变量。我们将在后面介绍如何定义只能在某一个源文件中使用的外部变量与函数。

因为外部变量可以在全局范围内访问，这就为函数之间的数据交换提供了一种可以代替函数参数与返回值的方式。任何函数都可以通过名字访问一个外部变量，当然这个名字需要通过某种方式进行声明。

如果函数之间需要共享大量的变量，使用外部变量要比使用要给很长的参数表更方便、有效。但是，我们在第 1 章中已经支持，这样做必须非常谨慎，因为这种方式可能对程序结构产生不良的影响，而且可能会导致程序中各个函数之间具有太多的数据联系。

外部变量的用途和表现在它们与内部变量相比具有更大的作用域和更长的生存期。自动变量只能在函数内部使用，从其所在的函数被调用时变量开始存在，在函数退出时变量也将消失。而外部变量是永久存在的，它们的值在一次函数调用到下一次函数调用之间保持不变。因此，如果两个函数必须共享某些数据，而这两个函数互不调用对方，这种情况下最方便的方式便是把这些共享数据定义为外部变量，而不是作为函数参数传递。

getch 与 ungetch 两个函数有什么用途呢？程序中经常会出现这样的情况：程序不能确定它已经读入的输入是否足够，除非超前多读入一些输入。读入一些字符以合成一个数字的情况便是一例：在看到第一个非数字字符之前，已经读入的数的完整性是不能确定的。由于程序要超前读入一个字符，这样就导致最后有一个字符不属于当前所要读入的数。

如果能 “反读” 不需要的字符，该问题就可以得到解决。每当程序多读入一个字符时，就把它压回到输入中，对代码其余部分而言就好像没有读入该字符一样。我们可以编写一对互相协作的函数来比较方便地模拟反取字符操作。getch 函数用于读入一个待处理的字符，而 ungetch 函数则用于把字符放回到输入中，这样，此后在调用 getch 函数时，在读入新的输入之前先返回 ungetch 函数放回的那个字符。

这两个函数之间的系统工作也很简单。ungetch 函数把要压回的字符放到一个共享缓冲区（字符数组）中，当该缓冲区不空时，getch 函数就从缓冲区中读取字符；当缓冲区为空时，getch 函数调用 getchar 函数直接从输入中读字符。这里还需要增加一个下标变量来记住缓冲区中当前字符的位置。

由于缓冲区与下标变量是供 getch 与 ungetch 函数共享的，且在两次调用之间必须保持值不变，因此它们必须是这两个函数的外部变量。

标准库中提供了 ungetc，它将一个字符压回到栈中，我们将在第 7 章中讨论该函数。





#### 4.4	作用域规则

构成 C 语言程序的函数与外部变量可以分开进行编译。一个程序可以存放在几个文件中，原先已编译过的函数可以从库中进行加载。这里我们感兴趣的问题有：

- 如何进行声明才能确保变量在编译时被正确声明？
- 如何安排声明的位置才能确保程序在加载时各部分能正确连接？
- 如何组织程序中的声明才能确保只有一份副本？
- 如何初始化外部变量？

名字的**作用域**指的是程序中可以使用该名字的部分。对于在函数开头声明的自动变量来说，其作用域是声明该变量名的函数。不同函数中声明的具有相同名字的各个局部变量之间没有任何关系。函数的参数也是这样的，实际上可以将它看做是局部变量。

外部变量或函数的作用域从声明它的地方开始，到其所在的（待编译的）文件的末尾结束。如下所示：

```C
main() { ... }

int sp = 0;
double val[MAXVAL];

void push(double f) { ... }
double pop(void) { ... }
```

那么，在 push 与 pop 这两个函数中不需要进行任何声明就可以通过名字访问变量 sp 与 val，但是，这两个变量名不能用在 main 函数中，push 与 pop 函数也不能用在 main 函数中。

另一方面，如果要在外部变量的定义之前使用该变量，或者外部变量的定义与变量的使用不在同一个源文件中，则必须在相应的变量声明中强制性地使用关键字 extern。

将外部变量的声明与定义严格区分开来很重要。变量声明用于说明变量的属性（主要是变量的类型），而变量定义除此之外还将引起存储器的分配。如果将下列语句放在所有函数的外部：

int sp;

double val[MAXVAL];

那么这两条语句将定义外部变量 sp 与 val，并为之分配存储单元，同时这两条语句还可以作为该源文件中其余部分的声明。而下面的两行语句：

extern int sp;

extern double val[];

为源文件的其余部分声明了一个 int 类型的外部变量 sp 以及一个 double 数组类型的外部变量 val（该数组的长度在其它地方确定），但这两个声明并没有建立变量或为它们分配存储单元。

在一个源程序的所有源文件中，一个外部变量只能在某个文件中定义一次，而其他文件可以通过 extern 声明来访问它（定义外部变量的源文件中也可以包含对该外部变量的 extern 声明）。外部变量的定义中必须指定数组的长度，但 extern 声明则不一定要指定数组的长度。

外部变量的初始化只能出现在其定义中。

假定函数 push 与 pop 定义在一个文件中，而变量 val 与 sp 在另一个文件中定义并被初始化（通常不大可能这样组织程序），则需要通过下面这些定义与声明把这些函数和变量 “绑定” 在一起：

在文件 file1 中：

extern int sp;

extern double val[];

void push(double f) { ... }

double pop(void) { ... }

在文件 file2 中：

int sp = 0;

double val[MAXVAL];

由于文件 file1 中的 extern 声明不仅放在函数定义的外面，而且在放在它们的前面，因此它们适用于该文件中的所有函数。对于 file1，这样一组声明就够了。如果要在同一个文件中先使用、后定义变量 sp 与 val，也需要按照这种方式组织文件。





#### 4.5	头文件

下面我们来考虑把上述的计算器程序分隔到若干个源文件中的情况。如果该程序的各组成部分很长，这么做还是有必要的。我们这样分隔：将主函数 main 单独放在文件 main.c 中；将 push 与 pop 函数以及它们使用的外部变量放在第二个文件 stack.c 中；将 getop 函数放在第三个文件 getop.c 中；将 getch 与 ungetch 函数放在第四个文件 getch.c 中。之所以分割成多个文件，主要是考虑在实际的程序中，它们分别来自于单独编译的库。

此外，还必须考虑定义和声明在这些文件之间的共享问题。我们尽可能把共享的部分集中在一起，这样就只需要一个副本，改进程序时也容易保证程序的正确性。我们把这些公共部分放在头文件 calc.h 中，在需要使用该头文件时通过 #include 指令将它包含进来（#include 指令将在 4.11 节中介绍）。这样分割后，程序的形式如下所示：

<div align=center>
	<img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE2.jpg"/>
</div>



我们对下面两个因素进行了折衷：一方面是我们期望每个文件只能访问它完成任务所需的信息；另一方面是现实中维护较多的头文件比较困难。我们可以得出这样一个结论：对于某些中等规模的程序，最好只用一个头文件存放程序中各部分共享的对象。较大的程序需要使用更多的头文件，我们需要精心地组织它们。





#### 4.6	静态变量

某些变量，比如文件 stack.c 中定义的变量 sp 与 val 以及文件 getch.c 中定义的变量 buf 与 bufp，它们仅供其所在的源文件中的函数使用，其他函数不能访问。用 static 声明限定外部变量与函数，可以将其后声明的对象的作用域限定为被编译源文件的剩余部分。通过 static 限定外部对象，可以达到隐藏外部对象的目的，比如，getch-ungetch 复合结构需要共享 buf 与 bufp 两个变量，这样 buf 与 bufp 必须是外部变量，但这两个对象不应该被 getch 与 ungetch 函数的调用者所访问。

要将对象指定为静态存储，可以在正常的对象声明之前加上关键字 static 作为前缀。如果把上述两个函数和两个变量放在一个文件中编译，如下所示：

```c
static char buf[BUFSIZE];	/* buffer for ungetch */
static int bufp = 0;		/* next free position in buf */

int getch(void) { ... }

void ungetch(int c) { ... }
```



那么其它函数就不能访问变量 buf 与 bufp，因此这两个名字不会和同一程序中的其它文件中的相同的名字相冲突。同样，可以通过把变量 sp 与 val 声明为静态类型隐藏这两个由执行栈操作的 push 与 pop 函数使用的变量。

外部的 static 声明通常多用于变量，当然，它也可用于声明函数。通常情况下，函数名字是全局可访问的，对整个程序的各个部分而言都可见。但是，如果把函数声明为 static 类型，则该函数名除了对该函数声明所在的文件可见外，其它文件都无法访问。

static 也可以用于声明内部变量。static 类型的内部变量同自动变量一样，是某个特定函数的局部变量，只能在该函数中使用，但它与自动变量不同的是，不管其所在函数是否被调用，它一直存在，而不像自动变量那样，随着所在函数的被调用和退出而存在和消失。换句话说，static 类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量。





#### 4.7	寄存器变量

register 声明告诉编译器，它所声明的变量在程序中使用频率较高。其思想是，将 register 变量放在机器的寄存器中，这样可以使程序更小、执行速度更快。但编译器可以忽略此选项。

register 声明的形式如下所示：

register int x;

register char c;

register 声明只适用于自动变量以及函数的形式参数。下面是后一种情况的例子：

f (register unsigned m, register long n)

{

​	register int i;

​	...

}

实际使用时，底层硬件环境的实际情况对寄存器变量的使用会有一些限制。每个函数中只有很少的变量可以保存在寄存器中，且只允许某些类型的变量。但是，过量的寄存器声明并没有什么害处，这是因为编译器可以忽略过量的或不支持的寄存器变量声明。另外，无论寄存器变量实际上是不是存放在寄存器中，它的地址都是不能访问的（有关这一点更详细的信息，我们将在第 5 章中讨论）。在不同的机器中，对寄存器变量的数目和类型的具体限制也是不同的。





#### 4.8	程序块结构

C 语言并不是 Pascal 等语言意义上的程序块结构的语言，它不允许在函数中定义函数。但是，在函数中可以以程序块结构的形式定义变量。变量的声明（包括初始化）除了可以紧跟在函数开始的花括号之后，还可以紧跟在任何其它标识复合语句开始的左花括号之后。以这种方式声明的变量可以隐藏程序块外与之同名的变量，它们之间没有任何关系，并在与左花括号匹配的右花括号出现之前一直存在。例如，在下面的程序段中：

```c
if (n > 0) {
	int i;	/* declare a new i */
    
    for (i = 0; i < n; i++)
       ...
}
```



变量 i 的作用域是 if 语句的 “真” 分支，这个 i 与该程序块外声明的 i 无关。每次进入程序块时，在程序块内声明以及初始化的自动变量都将被初始化。静态变量只在第一次进入程序块时被初始化一次。

自动变量（包括形式参数）也可以隐藏同名的外部变量与函数。在下面的声明中：

```CQL
int x;
int y;

f(double x)
{
	double y;
}
```



函数 f 内的变量 x 引用的是函数的参数，类型为 double；而在函数 f 外，x 是 int 类型的外部变量。这段代码中的变量 y 也是如此。

在一个好的程序设计风格中，应该避免出现变量名隐藏外部作用域中相同名字的情况，否则，很可能引起混乱和错误。





#### 4.9	初始化

前面我们多次提到过初始化的概念，不过始终没有详细讨论。本节将对前面讨论的各种存储类的初始化规则做一个总结。

在不进行显式初始化的情况下，外部变量和静态变量都将被初始化为 0，而自动变量和寄存器变量的初值则没有定义（即初值为无用的信息）。

定义标量变量时，可以在变量名后紧跟一个等号和一个表达式来初始化变量：

int x = 1;

char squota = '\ '' ;

long dat = 1000L * 60L * 60L * 24L;	/* milliseconds/day */

对于外部变量与静态变量来说，初始化表达式必须是常量表达式，且只初始化一次（从概念上讲是在程序开始执行前进行初始化）。对于自动变量与寄存器常量，则在每次进入函数或程序块时都将被初始化。

对于自动变量与寄存器变量来说，初始化表达式可以不是常量表达式：表达式中可以包含任意在此表达式之前已经定义的值，包括函数调用，我们在 3.3 节中介绍的折半查找程序的初始化可以采用下列形式：

```c
int binsearch(int x, int v[], int n)
{
	int low = 0;
    int high = n - 1;
	int mid;
    ...
}
```

 

代替原来的形式：

```C
int low, high, mid;

low = 0;
high = n - 1;
```



实际上，自动变量的初始化等效于简写的赋值语句。究竟采用哪一种形式，还得看个人的习惯。考虑到变量声明中的初始化表达式容易被人忽略，且距使用的位置较远，我们一般使用显式的赋值语句。

数组的初始化可以在声明的后面紧跟一个初始化表达式列表，初始化表达式列表用花括号括起来，各初始化表达式之间通过逗号分隔。例如，如果要用一年中各月的天数初始化数组 days，其变量的定义如下：

int days[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

当省略数组的长度时，编译器将把花括号中的初始化表达式的个数作为数组的长度，在本例中数组的长度为 12。

如果初始化表达式的个数比数组元素数少，则对外部变量、静态变量和自动变量来说，没有初始化表达式的元素将被初始化为 0，如果初始化表达式的个数比数组元素数多，则是错误的。不能一次讲一个初始化表达式指定给多个数组元素，也不能跳过前面的数组元素而直接初始化后面的数组元素。

字符数组的初始化比较特殊：可以用一个字符串来代替用花括号括起来并用逗号分隔的初始化表达式序列。例如：

char pattern[] = "ould ";

它同下面的声明是等价的：

char pattern[] = { 'o', 'u', 'l', 'd'};

这种情况下，数组的长度是 5（4 个字符加上一个字符串结束符 '\0'）。





#### 4.10	递归

C 语言中的函数可以递归调用，即函数可以直接或间接调用自身。

有一个能较好说明递归的例子是快速排序。快速排序算法是 C.A.R.Hoare 于 1962 年发明的。对于一个给定的数组，从中选择一个元素，以该元素为界将其余元素划分为两个子集，一个子集中的所有元素都小于该元素，另一个子集中的所有元素都大于或等于该元素。对这样两个子集递归执行这一过程，当某个子集中的元素数小于 2 时，这个子集就不需要再次排序，终止递归。

从执行速度来讲，下列版本的快速排序函数可能不是最快的，但它是最简单的算法之一。在每次划分子集时，该算法总是选取各个子数组的中间元素。

```c
//qsort 函数：以递增顺序对 v[left]...v[right] 进行排序
void qsort(int v[], int left, int right)
{
    int i, last;
    void swap(int v[], int i, int j);
    if (left >= right) {	//若数组包含的元素数少于两个，则不执行任何操作	
        return;
    }
    //将划分子集的元素；整数除法会截断结果中的小数部分
    swap (v, left, (left + right)/2);	
    last = left;	//移动到 v[0]
    for (i = left + 1; i <= right; i++) {	//划分子集
        if (v[i] < v[left]) {
            swap(v, ++last, i);
        }
    }
    swap(v, left, last);	//恢复划分子集的元素
    qsort(v, left, last-1);
    qsort(v, last+1, right);
}

//这里之所以将数组元素交换操作放在一个单独的函数 swap 中，是因为它在 qsort 函数中要使用 3 次。

//swap 函数：交换 v[i] 与 v[j] 的值
void swap(int v[], int i, int j)
{
    int temp;
        
    temp = v[i];
    v[i] = v[j];
    v[j] = temp;
}
```



标准库中提供了一个 qsort 函数，它可用于对任何类型的对象排序。

递归并不节省存储器的开销，因为递归调用过程中必须在某个地方维护一个存储处理值的栈。递归的执行速度并不快，但递归代码比较紧凑，并且比相应的非递归代码更易于编写与理解。在描述树等递归定义的数据结构时使用递归尤其方便。我们将在 6.5 节中介绍一个比较好的例子。





#### 4.11	C 预处理器

C 语言通过预处理器提供了一些语言功能。从概念上讲，预处理器是编译过程中单独执行的第一个步骤。两个最常用的预处理器指令是：#include 指令（用于在编译期间把指定文件的内容包含进当前文件中）和 #define 指令（用任意字符序列替代一个标记）。本节还将介绍预处理器的其它一些特性，如条件编译与带参数的宏。



##### 4.11.1	文件包含

文件包含指令（即 #include 指令）使得处理大量的 #define 指令以及声明更加方便。在源文件中，任何形如：

#include "文件名"

或

#include <文件名>

的行都将被替换为由文件名指定的文件的内容。如果文件名用引号引起来，则在源文件所在的位置查找该文件；如果在该位置没有找到文件，或者如果文件名是用尖括号 < 与 > 括起来的，则将根据相应的规则查找该文件，这个规则同具体的实现有关。被包含的文件本身也可包含 #include 指令。

源文件的开始处通常都会有多个 #include 指令，它们用以包含常见的 #define 语句和 extern 声明，或从头文件中访问库函数的函数原型声明，比如 <stdio.h>。（严格地说，这些内容灭有必要单独存放在文件中；访问头文件的细节同具体的实现有关。）

在大的程序中，#include 指令是将所有声明捆绑在一起的较好的方法。它保证所有的源文件都具有相同的定义与变量声明，这样可以避免出现一些不必要的错误。很自然，如果某个包含文件的内容发生了变化，那么所有依赖于该包含文件的源文件都必须重新编译。



##### 4.11.2	宏替换

宏定义的形式如下：

#define 名字 替换文本

这是一种最简单的宏替换——后续所有出现名字记号的地方都将被替换为**替换文本**。#define 指令中的名字与变量名的命名方式相同，替换文本可以是任意字符串。通常情况下，#define 指令占一行，替换文本是 #define 指令行尾部的所有剩余部分内容，但也可以把一个较长的宏定义分成若干行，这时需要在待续的行末尾加上一个反斜杆符\。#define 指令定义的名字的作用域从其定义点开始，到被编译的源文件的末尾处结束。宏定义中也可以使用前面的宏定义。替换只对记号进行，对括在引号中的字符串不起作用。例如，如果 YES 是一个通过 #define 指令定义过的名字，则在 printf("YES") 或 YESMAN 中将不执行替换。

替换文本可以是任意的，例如：

#define forever for (;;)	//无限循环

该语句为无限循环定义了一个新名字 forever。

宏定义也可以带参数，这样可以对不同的宏调用使用不同的替换文本。例如，下列宏定义定义了一个宏 max：

#define max(A, B)	((A) > (B) ? (A) : (B))

使用宏 max 看起来很像是函数调用，但宏调用直接将替换文本插入到代码中。形式参数（在此为 A 或 B）的每次出现都将被替换成对应的实际参数。因此，语句：

x = max(p+q, r+s);

将被替换为下列形式：

x = ( (p+q) > (r+s) ? (p+q) : (r+s) );

如果对各种类型的参数的处理是一致的，则可以将同一个宏定义应用于任何数据类型，而无需针对不同的数据类型需要定义不同的 max 函数。

仔细考虑一下 max 的展开式，就会发现它存在一些缺陷。其中，作为参数的表达式要重复计算两次，如果表达式存在副作用（比如含有自增运算符或输入 / 输出），则会出现不正确的情况。例如：

max(i++, j++)	//错误示例

它将对每个参数执行两次自增操作。同时还必须注意，要适当使用圆括号以保证计算次序的准确性。考虑下列宏定义：

#define square(x)	x * x	//错误示例

当用 squrare(z+1) 调用宏定义时会出现什么情况呢？

但是，宏还是很有价值的。<stdio.h> 头文件中有一个很实用的例子：getchar 与 putchar 函数在实际中常常被定义为宏，这样可以避免处理字符时调用函数所需的运行时开销。<ctype.h> 头文件中定义的函数也常常是通过宏实现的。

可以通过 #undef 指令取消名字的宏定义，这样做可以保证后续的调用是函数调用，而不是宏调用：

#undef getchar

int getchar(void)	{ ... }

形式参数不能用带引号的字符串替换。但是，如果在替换文本中，参数名以 # 作为前缀则结果将被扩展为由实际参数替换该参数的带引号的字符串。例如，可以将它与字符串连接运算结合起来编写一个调试打印宏：

#define	dpringt(expr)	printf(#expr " = %g\n", expr)

使用语句

dprint(x/y)

调用该宏时，该宏将被扩展为：

printf("x/y" " = &g\n", x/y);

其中的字符串被连接起来了，这样，该宏调用的效果等价于

printf("x/y = &g\n", x/y);

在实际参数中，每个双引号 "将被替换为 \ "，反斜杆 \ 将被替换为 \ \，因此替换后的字符串是合法的字符串常量。

预处理器运算符 ## 为宏扩展提供了一种连接实际参数的手段。如果替换文本中的参数与 ## 相邻，则该参数将被实际参数替换，## 与前后的空白符将被删除，并对替换后的结果重新描述。例如，下面定义的宏 paste 用于连接两个参数

#define	paste(front, back)	front ## back

因此，宏调用 paste(name, 1) 的结果将建立记号 name1。

##的嵌套使用规则比较难以掌握，详细细节请参阅附录 A。



##### 4.11.3	条件包含

还可以使用条件语句对预处理本身进行控制，这种条件语句的值是在预处理的过程中进行计算。这种方式为在编译过程中根据计算所得的条件值选择性地包含不同代码提供了一种手段。

#if 语句对其中的常量整型表达式（其中不能包含 sizeof、类型转运算符或 enmu 常量）进行求值，若该表达式的值不等于 0，则包含其后的各行，直到遇到 #endif、#elif 或 #else 语句为止（预处理器语句 #elif 类似于 else if）。在 #if 语句中可以使用表达式 defined(名字)，该表达式的值遵循下列规则：当名字已经定义时，其值为 1；否则，其值为 0。

例如，为了保证 hdr.h 文件的内容只被包含一次，可以将该文件的内容包含在下列形式的条件语句中：

#if !defined(HDR)

#define HDR

//hdr.h 文件的内容放在这里

#endif

第一次包含头文件 hdr.h 时，将定义名字 HDRl；此后再次包含该头文件时，会发现改名字已经定义，这样将直接跳转到 #endif 处。类似的方式也可以用来避免多次重复包含同一文件。如果多个头文件能够一致地使用这种方式，那么，每个头文件都可以将它所依赖的任何头文件包含起来，用户不必考虑和处理头文件之间的各种依赖关系。

下面的这段预处理代码首先测试系统变量 SYSTEM，然后根据该变量的值确定包含哪个版本的头文件：

#if SYSTEM == SYSV
	#define HDR "sysv.h"
#elif SYSTEM == BSD
	#define HDR "bsd.h"
#elif SYSTEM == MSDOS
	#define HDR "msdos.h"
#else
	#define HDR "default.h"
#endif
#include HDR

C 语言专门定义了两个预处理语句 #ifdef 与 #ifndef，它们用来测试某个名字是否已经定义。上面有关 #if 的第一个例子可以改写为下列形式：

#ifndef HDR
#define HDR

//hdr.h 文件的内容放在这里

#endif





### 第 5 章	指针与数组

指针是一种保存变量地址的变量。在 C 语言中，指针的使用非常广泛，原因之一是，指针常常是表达某个计算的惟一图解，另一个原因是，同其他方法比较起来，使用指针通常可以生产更高效、更紧凑的代码。指针与数组之间的关系十分密切，我们将在本章中讨论它们之间的关系，并探讨如何利用这种关系。

指针和 goto 语句一样，会导致程序难以理解。如果使用者粗心，指针很容易就指向了错误的地方。但是，如果谨慎地使用指针，便可以利用它写出简单、清晰的程序。在本章中我们将尽力说明这一点。

ANSI C 的一个最重要的变化是，它明确地制定了操作指针的规则。事实上，这些规则已经被很多优秀的程序设计人员和编译器所采纳。此外，ANSI C 使用类型 void *（指向 void 的指针）代替 char * 作为通用指针的类型。



#### 5.1	指针与地址

首先，我们通过一个简单的示意图来说明内存是如何组织的。通常的机器都有一系列连续编号或编址的存储单元，这些存储单元可以单个进行操纵，也可以连续成组的方式操纵。通常情况下，机器的一个字节可以存放一个 char 类型的数据，两个相邻的字节存储单元可存储一个 short（短整型）类型的数据，而 4 个相邻的字节存储单元可存储一个 long（长整型）类型的数据。指针是能够存放一个地址的一组存储单元（通常是两个或 4 个字节）。因此，如果 c 的类型是 char，并且 p 是指向 c 的指针，则可用图 5-1 表示它们之间的关系：

<div align=center>
	<img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE3.jpg"/>
</div>

一元运算符 & 可用于取一个对象的地址，因此，下列语句：

p = &c;

将把 c 的地址赋值给变量 p，我们称 p 为 “指向” c 的指针。地址运算符 & 只能应用于内存中的对象，即变量与数组元素。它不能作用域表达式、常量或 register 类型的变量。

一元运算符是 * 是间接寻址或间接引用运算符。当它作用于指针时，将访问指针所指向的对象。我们在这里假定 x 与 y 是整数，而 ip 是指向 int 类型的指针，下面的代码段说明了如何在程序中声明指针以及如何使用运算符 & 和 *：

int x = 1, y = 2, z[10];

int *ip;	//ip 是指向 int 类型的指针

ip = &x;	//ip 现在指向 x

y = *ip;	//y 的值现在为 1

*ip = 0;	//x 的值现在为 0

ip = &z[0];	//ip 现在指向 z[0]

变量 x、y 与 z 的声明方式我们已经在前面的章节中见到过。我们来看指针 ip 的声明，如下所示：

int *ip;

这样声明是为了便于记忆。该声明语句表明表达式 *ip 的结果是 int 类型。这种声明变量的语法与声明该变量所在表达式的语法类似。同样的原因，对函数的声明也可以采用这种方式。例如，声明

double *dp, atof(char *);

表明，在表达式中，*dp 和 atof(s) 的值都是 double 类型，且 atof 的参数是一个指向 char 类型的指针。

我们应该注意，指针只能指向某种特定类型的对象，也就是说，每个指针都必须指向某种特定的数据类型。（一个例外情况是指向 void 类型的指针可以存放指向任何类型的指针，但它不能间接引用其自身。我们将在 5.11 节钟详细讨论该问题）。

如果指针 ip 指向整型变量，那么在 x 可以出现的任何上下文中都可以使用 *ip，因此，语句

*ip = *ip + 10;

将把 *ip 的值增加 10。

一元运算符 * 和 & 的优先级比算术运算符的优先级高，因此，赋值语句

y = *ip + 1

将把 *ip 指向的对象的值取出并加 1，然后再将结果赋值给 y，而下列赋值语句：

*ip += 1

则将 ip 指向的对象的值加 1，它等同于 

++*ip

或

(*ip)++

语句的执行结果。语句 (*ip)++ 中的圆括号是必需的，否则，该表达式将对 ip 进行加 1 运算，而不是对 ip 指向的对象进行加 1 运算，这是因为，类似于 * 和 ++ 这样的一元运算符遵循从右至左的结合顺序。

最后说明一点，由于指针也是变量，所以在程序中可以直接使用，而不必通过间接引用的方法使用。例如，如果 iq 是另一个指向整型的指针，那么语句

iq = ip

将把 ip 中的值拷贝到 iq 中，这样，指针 iq 也将指向 ip 指向的对象。





#### 5.2	指针与函数参数

由于 C 语言是以传值的方式将参数值传递给被调用函数。因此，被调用函数不能直接修改主调函数中变量的值。例如，排序函数可能会使用一个名为 swap 的函数来交换两个次序颠倒的元素。但是，如果将 swap 函数定义为下列形式：

```C
void swap(int x, int y)	//错误示例
{
    int temp;
    
    temp = x;
    x = y;
    y = temp;
}
```



则下列语句无法达到该目的。

swap(a, b);

这是因为，由于参数传递采用传值方式，因此上述的 swap 函数不会影响到调用它的例程中的参数 a 和 b 的值。该函数仅仅交换了 a 和 b 的副本的值。

那么，如何实现我们的目标呢，可以使主调程序将指向所要交换的变量的指针传递给被调用函数，即

swap(&a, &b);

由于一元运算符 & 用来取变量的地址，这样 &a 就是一个指向变量 a 的指针。swap 函数的所有参数都声明为指针，并且通过这些指针来间接访问它们指向的操作数。

```c
void swap(int *px, int *py)	//交换 *px 和 *py
{
	int temp;
	
	temp = *px;
	*px = *py;
	*py = temp;
}
```



指针参数使得被调用函数能够访问和修改主调函数中对象的值。





#### 5.3	指针与数组

在 C 语言中，指针和数组之间的关系十分密切，因此，在接下来的部分中，我们将同时讨论指针与数组。通过数组下标所能完成的任何操作都可以通过指针来实现。一般来说，用指针编写的程序比用数组下标编写的程序执行速度快，但另一方面，用指针实现的程序理解起来稍微困难一些。

声明

int a[10];

定义了一个长度为 10 的数组 a。换句话说，它定义了一个由 10 个对象组成的集合，这 10 个对象存储在相邻的内存区域中，名字分别为 a[0]、a[1]、... 、a[9]（参见图 5-3）。

<div align=center>
	<img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE4.jpg"/>
</div>

a[i] 表示该数组的第 i 个元素。如果 pa 的声明为

int *pa;

则说明它是一个指向整型对象的指针，那么，赋值语句

pa = &a[0]

则可以将指针 pa 指向数组 a 的第 0 个元素，也就是说，pa 的值为数组元素 a[0] 的地址。

这样，赋值语句

x = *pa;

将把数组元素 a[0] 中的内容复制到变量 x 中。

如果 pa 指向数组中的某个特定元素，那么，根据指针运算的定义，pa+1 将指向下一个元素，pa+i 将指向 pa 所指向数组元素之后的第 i 个元素，而 pa-i 将指向 pa 所指向数组元素之前的第 i 个元素。因此，如果指针 pa 指向 a[0]，那么 *(pa+1) 引用的是数组元素 a[1] 的内容，pa+i 是数组元素 a[i] 的地址， *(pa+i) 引用的是数组元素 a[i] 的内容。

无论数组 a 中元素的类型或数组长度是什么，上面的结论都成立。“指针加 1” 就意味着，pa+1 指向 pa 所指向的对象的下一个对象。相应地，pa+i 指向 pa 所指向的对象之后的第 i 个对象。

下标和指针运算之间具有密切的对应关系。根据定义，数组类型的变量或表达式的值是该数组第 0 个元素的地址。执行赋值语句

pa = &a[0];

后，pa 和 a 具有相同的值。因为数组名所代表的就是该数组最开始的一个元素的地址，所以，赋值语句 pa=&a[0] 也可以写成下列形式：

pa = a;

对数组元素 a[i] 的引用也可以写成 *(a+i) 这种形式。对第一次接触这种写法的人来说，可能会觉得很奇怪。在计算数组元素 a[i] 的值时，C 语言实际上先将其转换为 *(a+i) 的形式，然后再进行求值，因此在程序中这两种形式是等价的。如果对这两种等价的表示形式分别施加地址运算符 &，便可以得出这样的结论：&a[i] 和 a+i 的含义也是相同的。a+i 是 a 之后第 i 个元素的地址。相应地，如果 pa 是个指针，那么，在表达式中也可以在它地后面加下标。pa[i] 与 *(pa+i) 是等价的。简而言之，一个通过数组和下标实现的表达式可等价地通过指针和偏移量实现。

但是，我们必须记住，数组名和指针之间有一个不同之处，指针是一个变量，因此，在 C 语言中，语句 pa=a 和 pa++ 都是合法的。但数组名不是变量，因此，类似于 a=pa 和 a++ 形式的语句是非法的。

当把数组名传递给一个函数时，实际上传递的是该数组第一个元素的地址。在被调用函数中，该参数是一个局部变量，因此，数组名参数必须是一个指针，也就是一个存储地址值的变量。我们可以利用该特性编写 strlen 函数的另一个版本，该函数用于计算一个字符串的长度。

```c
//strlen 函数：返回字符串 s 的长度
int strlen(char *s)
{
	int n;
	
	for (n = 0; *s != '\0'; s++) {
		n++;
	}
	return n;
}
```



因为 s 是一个指针，所以对其执行自增运算是合法的。**执行 s++ 运算不会影响到 strlen 函数的调用者中的字符串，它仅对该指针在 strlen 函数中的私有副本进行自增运算。**因此，类似于下面这样的函数调用：

strlen("hello, world");	//字符串常量

strlen(array);	//char array[100]，字符数组 array 有 100 个元素

strlen(ptr);	//char *ptr，ptr 是一个指向 char 类型对象的指针

都可以正确地执行。

在函数定义中，形式参数

char s[];

和

char *s;

是等价的。我们通常更习惯于使用后一种形式，因为它比前者更直观地表明了该参数是一个指针。如果将数组名传递给函数，函数可以根据情况盘定是按照数组处理还是按照指针处理，随后根据相应的方式操作该参数。为了直观且恰当地描述函数，在函数中甚至可以同时使用数组和指针这两种表示方法。

也可以将指向子数组起始位置的指针传递给函数，这样，就将数组的一部分传递给了函数。例如，如果 a 是一个数组，那么下面两个函数调用

f(&a[2])

与

f(a+2)

都将把起始于 a[2] 的子数组的地址传递给函数 f。在函数 f 中，参数的声明形式可以为

f(int arr[]) { ... }

或

f(int *arr) { ... }

对于函数 f 来说，它并不关心所引用的是否只是一个更大数组的部分元素。

如果确信相应的元素存在，也可以通过下标访问数组第一个元素之前的元素。类似于 p[-1]、p[-2] 这样的表达式在语法上都是合法的，它们分别引用位于 p[0] 之前的两个元素。当然，引用数组边界之外的对象是非法的。





#### 5.4	地址算术运算

如果 p 是一个指向数组中某个元素的指针，那么 p++ 将对 p 进行自增运算并指向下一个元素，而 p+=i 将对 p 进行加 i 的增量运算，使其指向指针 p 当前所指向的元素之后的第 i 个元素。这类运算是指针或地址算术运算中最简单的形式。

C 语言中的地址算术运算方法是一致且有规律的，将指针、数组和地址的算术运算集成在一起是该语言的一大优点。为了说明这一点，我们来看一个不完善的存储分配程序。它由两个函数组成。第一个函数 alloc(n) 返回一个指向 n 个连续字符存储单元的指针，alloc 函数的调用者可利用该指针存储字符序列。第二个函数 afree(p) 释放已分配的存储空间，以便以后重用。之所以说这两个函数是 ”不完善的“，是因为对 afree 函数的调用次序必须与调用 alloc 函数的次序相反。换句话说，alloc 与 afree 以栈的方式（即先进后出的列表）进行存储空间的管理。标准库中提供了具有类似功能的函数 malloc 和 free，它们没有上述限制，我们将在 8.7 节中说明如何实现这些函数。

最容易的实现方法是让 alloc 函数对一个大字符数组 allocbuf 中的空间进行分配。该数组是 alloc 和 afree 两个函数私有的数组。由于函数 alloc 和 afree 处理的对象是指针而不是数组下标，因此，其它函数无需知道该数组的名字，这样，可以在包含 alloc 和 afree 的源文件中将该数组声明为 static 类型，使得它对外不可见。实际实现时，该数组甚至可以没有名字，它可以通过 malloc 函数或向操作系统申请一个指向无名存储块的指针获得。

allocbuf 中的空间使用状况也是我们需要了解的信息。我们使用指针 allocp 指向 allocbuf 中的下一个空闲单元。当调用 alloc 申请 n 个字符的空间时，alloc 检查 allocbuf 数组中有没有足够的剩余空间。如果有足够的剩余空间，则 alloc 返回 allocp 的当前值（即空闲块的开始位置），然后将 allocp 加 n 以使它指向下一个空闲区域。如果空闲空间不够，则 alloc 返回 0。如果 p 在 allocbuf 的边界之内，则 afree(p) 仅仅只是将 allocp 的值设置为 p。

```c
#define ALLOCSIZE 10000	//可用空间大小

static char allocbuf[ALLOCSIZE];	//alloc 使用的存储区
static char *allocp = allocbuf;		//下一个空闲位置

char *alloc(int n)	
{
    if (allocbuf + ALLOCSIZE - allocp >= n) {	//有足够的空闲空间
        allocp += n;
        return allocp - n;	//分配前的指针 p
    } else {	//空闲空间不够
        return 0;
    } 
}

void afree(char *p)	//释放 p 指向的存储区
{
    if (p >= allocbuf && p < allocbuf + ALLOCSIZE) {
        allocp = p;
    }
}
```



一般情况下，同其它类型的变量一样，指针也可以初始化。通常，对指针有意义的初始化值只能是 0 或者是表示地址的表达式，对后者来说，表达式所代表的地址必须是在此之前已经定义的具有适当类型的数据的地址。例如，声明

static char* allocp = allocbuf;

将 allocp 定义为字符类型指针，并将它初始化为 allocbuf 的起始地址，该起始地址是程序执行时的下一个空闲位置。上述语句也可以写成下列形式：

static char* allocp = &allocbuf[0];

这是因为该数组名实际上就是数组第 0 个元素的地址。

下列 if 测试语句：

if (allocbuf + ALLOCSIZE - allocp >= n)	//有足够的空闲空间

检查是否有足够的空闲空间以满足 n 个字符的存储空间请求。如果空间空间足够，则分配存储空间后 allocp 的新值至多比 allocbuf 的尾端地址大 1。如果存储空间的申请可以满足，alloc 将返回一个指向所需大小的字符块首地址的指针（注意函数本身的声明）。如果申请无法满足，alloc 必须返回某种形式的信号以说明没有足够的空闲空间可供分配。C 语言保证，0 永远不是有效的数据地址，因此，返回值 0 可用来表示发生了异常事件。在本例中，返回值 0 表示没有足够的空闲空间可供分配。

指针与整数之间不能相互转换，但 0 是惟一的例外：常量 0 可以赋值给指针，指针也可以和常量 0 进行比较。程序中经常用符号常量 NULL 代替常量 0，这样便于更清晰地说明常量 0 是指针的一个特殊值。符号常量 NULL 定义在标准头文件 <stddef.h> 中。我们在后面部分经常会用到 null。

类似于

if (allocbuf + ALLOCSIZE - allocp >= n)	//有足够的空闲空间

以及

if (p >= allocbuf && p < allocbuf + ALLOCSIZE)

的条件测试语句表明指针算术运算有以下几个重要特点。首先，在某些情况下对指针可以进行比较运算。例如，如果指针 p 和 q 指向同一个数组成员，那么它们之间就可以进行类似于 ==、!=、<、>= 的关系比较运算。如果 p 指向的数组元素的位置在 q 指向的数组元素位置之前，那么关系表达式

p < q

的值为真。任何指针与 0 进行相等或不等的比较运算都有意义。但是，指向不同数组的元素的指针之间的算术或比较运算没有定义。（这里有一个特里：指针的算术运算中可使用数组最后一个元素的下一个元素的地址。）

其次。我们从前面可以看到，指针可以和整数进行相加或相减运算。例如，结果

p + n

表示指针 p 当前指向的对象之后第 n 个对象的地址。无论指针 p 指向的对象是何种类型，上述结论都成立。在计算 p+n 时，n 将根据 p 指向的对象的长度按比例缩放，而 p 指向的对象的长度则取决于 p 的说明。例如，如果 int 类型占 4 个字节的存储空间，那么在 int 类型的计算中，对应的 n 将按 4 的倍数来计算。

指针的减法运算也是有意义的：如果 p 和 q 指向相同数组中的元素，且 p<q，那么 q-p+1 就是位于 p 和 q 指向的元素之间的元素的数目。我们由此可以编写出函数 strlen 的另一个版本，如下所示：

```c
//strlen 函数：返回字符串 s 的长度
int strlen(char *s)
{
	char *p = s;
    
    while (*p != '\0') {
        p++;
    }
	return p - s;
}
```



指针的算术运算具有一致性：如果处理的数据类型是比字符型占据更多存储空间的浮点类型，并且 p 是一个指向浮点类型的指针，那么在指向 p++ 后，p 将指向下一个浮点数的地址。因此，只需要将 alloc 和 afree 函数中所有的 char 类型替换为 float 类型，就可以得到一个适用于浮点类型而非字符型的内存分配函数。所有的指针运算都会自动考虑它所指向的对象的长度。

有效的指针运算包括相同类型指针之间的赋值运算；指针同整数之间的加法或减法运算；指向相同数组中元素的两个指针间的减法或比较运算；将指针赋值为 0 或指针为 0 之间的比较运算。其它所有形式的指针运算都是非法的，例如，两个指针间的加法、乘法、除法、移位或屏蔽运算；指针同 float 或 double 类型之间的加法运算；不经强制类型转换而直接将指向同一种类型对象的指针赋值给另一种类型对象的指针的运算（两个指针之一是 void * 类型的情况除外）。





#### 5.5	字符指针与函数

字符串常量是一个字符数组，例如：

"I am a string"

在字符串的内部表示中，字符数组以空字符 '\0' 结尾，所以，程序可以通过检查空字符找到字符数组的结尾。字符串常量占据的存储单元数也因此比双引号内的字符数大 1。

字符串常量最常见的用法也许是作为函数参数，例如：

printf("hello, world\n");

当类似于这样的一个字符串出现在程序中时，实际上是通过字符指针访问该字符串的。在上述语句中，printf 接受的是一个指向字符数组第一个字符的指针。也就是说，字符串常量可通过一个指向其第一个元素的指针访问。

除了作为函数参数外，字符串常量还有其他用法。假定指针 pmessage 的声明如下：

char *pmessage

那么，语句

pmessage = "now is the time";

将把一个指向该字符数组的指针赋值给 pmessage。该过程并没有进行字符串的复制，而只是涉及到指针的操作。C 语言没有提供将整个字符串作为一个整体进行处理的运算符。

下面两个定义之间有很大的差别

char amessage[] = "nw is the time";	//定义一个数组

char *pmessage = "nw is the time";	//定义一个指针

上述声明中，amessage 是一个仅仅足以存放初始化字符串以及空字符 '\0' 的的一维数组。数组中的单个字符可以进行修改，但 amessage 始终指向同一个存储位置。另一方面，pmessage 是一个指针，其初值指向一个字符串常量，之后它可以被修改以指向其它地址，但如果试图修改字符串的内容，结果是没有定义的（参见图 5-7）。

<div align=center>
	<img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE5.jpg"/>
</div>

为了更进一步地讨论指针和数组其它方面地问题，下面以标准库中两个有用的函数为例来研究它们的不同实现版本。第一个函数 strcpy(s, t) 把指针 t 指向的字符串复制到指针 s 指向的位置。如果使用语句 s=t 实现该功能，其实质上只是拷贝了指针，而并没有复制字符。为了进行字符的复制，这里使用了一个循环语句。strcpy 函数的第 1 个版本是通过数组方法实现的，如下所示：

```c
//strcpy函数：将指针 t 指向的字符串复制到指针 s 指向的位置；使用数组下标实现的版本
void strcpy(char *s, char *t)
{
    int i;
    
    i = 0;
    while ((s[i] = t[i]) != '\0') {
    	i++;   
    }
}
```



为了进行比较，下面是用指针方法实现的 strcpy 函数：

```c
//strcpy函数：将指针 t 指向的字符串复制到指针 s 指向的位置；使用指针方式实现的版本1
void strcpy(char *s, char *t)
{
    int i;
    
    i = 0;
    while ((*s = *t) != '\0') {
    	s++;
        t++;
    }
}
```



因为参数是通过值传递的，所以在 strcpy 函数中可以以任何方式使用参数 s 和 t。在此，s 和 t 是方便地进行了初始化的指针，循环每执行一次，它们就沿着相应的数组前进一个字符，直到将 t 中的结束符 '\0' 复制到 s 为止。

实际上，strcpy 函数并不会按照上面的这些方式编写。经验丰富的程序员更喜欢将它编写成下列形式：

```c
//strcpy函数：将指针 t 指向的字符串复制到指针 s 指向的位置；使用指针方式实现的版本2
void strcpy(char *s, char *t)
{
    while ((*s++ = *t++) != '\0') {
        ;
    }
}
```



在该版本中，s 和 t 的自增运算放到了循环的测试部分中。表达式 *t++ 的值是执行自增运算之前 t 所指向的字符。后缀运算符 ++ 表示在读取该字符之后才改变 t 的值。同样的道理，在 s 执行自增运算之前，字符就被存储到了指针 s 指向的旧位置。该字符值同时也用来和空字符 '\0' 进行比较运算，以控制循环的执行。最后的结果是一次将 t 指向的字符复制到 s 指向的位置，直到遇到结束符 '\0' 为止（同时也复制该结束符）。

为了更进一步地精炼程序，我们注意到，表达式同 '\0' 地比较是多余的，因为只需要判断表达的值是否为 0 即可。因此，该函数可进一步写成下列形式：

```c
//strcpy函数：将指针 t 指向的字符串复制到指针 s 指向的位置；使用指针方式实现的版本3
void strcpy(char *s, char *t)
{
    while (*s++ = *t++) {
        ;
    }
}
```



该函数初看起来不太容易理解，但这种表示方法是很有好处的，我们应该掌握这种方法，C 语言程序中经常会采用这种写法。

标准库 (<string.h>) 中提供的函数 strcpy 把目标字符串作为函数值返回。

我们研究的第二个函数是字符串比较函数 strcmp(s, t)。该函数比较字符串 s 和 t，并且根据 s 按照字典顺序小于、等于或大于 t 的结果分别返回负整数、0 或正整数。该返回值是 s 和 t 由前向后逐字符比较时遇到的第一个不相等字符处的字符的差值。

```c
//strcmp函数：根据 s 按照字典顺序小于、等于或大于 t 的结果分别返回负整数、0 或正整数
int strcmp(char *s, char *t)
{
	int i;
	
	for (i = 0; s[i] == t[i]; i++) {
		if (s[i] == '\0') {
			return 0;
		}
	}
	return s[i] - t[i];
}
```



下面是指针方式实现的 strcmp 函数：

```c
//strcmp函数：根据 s 按照字典顺序小于、等于或大于 t 的结果分别返回负整数、0 或正整数
int strcmp(char *s, char *t)
{	
	for (; *s == *t; s++, t++) {
		if (*s == '\0') {
			return 0;
		}
	}
	return *s - *t;
}
```



由于 ++ 和 -- 即可以作为前缀运算符，也可以作为后缀运算符，所以还可以将运算符 * 与运算符 ++ 和 -- 按照其他方式组合使用，但这些用法并不多见。例如，下列表达式

*--p

在读取指针 p 指向的字符之前先对 p 执行自减运算。事实上，下面的两个表达式：

*p++ = val;	//将 val 压入栈

val = *--p;		//将栈顶元素弹出到 val 中

是进栈和出栈的标准用法。更详细的信息，请参见 4.3 节。

头文件 <string.h> 中包含本节提到的函数的声明，另外还包括标准库中其它一些字符串处理函数的声明。



#### 5.6	指针数组以及指向指针的指针

由于指针本身也是变量，所以它们也可以像其它变量一样存储在数组中。下面通过编写 UNIX 程序 sort 的一个简化版本说明这一点。该程序按字母顺序对文本行组成的集合进行排序。

我们在第 3 章中曾描述过一个用于对整型数组中的元素进行排序的 shell 排序函数，并在第 4 章中用快速排序算法对它进行了改进。这些排序算法在此仍然是有效的，但是，现在处理的是长度不一的文本行。并且与整数不同的是，它们不能在单个运算中完成比较或移动操作。我们需要一个能够高效、方便地处理可变长度文本行的数据表示方法。

我们引入指针数组处理这种问题。如果待排序的文本行首尾相连地存储在一个长字符数组中，那么每个文本行可通过指向它的第一个字符的指针来访问。这些指针本身可以存储在一个数组中。这样，将指向两个文本行的指针传递给函数 strcmp 就可实现对这两个文本行的比较。当交换次序颠倒的两个文本行时，实际上交换的是指针数组中可与这两个文本行相对应的指针，而不是这两个文本行本身（参见图 5-8）。

<div align=center>
	<img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE6.jpg"/>
</div>

这种实现方法消除了因移动文本行本身所带来的复杂的存储管理和巨大的开销这两个孪生问题。

排序过程包括下列 3 个步骤：

1. 读取所有输入行
2. 对文本进行排序
3. 按次序打印文本行

通常情况下，最好将程序划分成若干个与问题的自然划分相一致的函数，并通过主函数控制其它函数的执行。关于对文本行排序这一步，我们稍后再做说明，现在主要考虑数据结构以及输入和输出函数。

输入函数必须收集和保存每个文本行中的字符，并建立一个指向这些文本行的指针的数组。它同时还必须统计输入的行数，因为在排序和打印时要用到这一信息。由于输入函数只能处理有限数目的输入行，所以在输入行数过多而超过限定的最大行数时，该函数返回某个用于表示非法行数的数值，例如 -1。

输出函数只需要按照指针数组中的次序依次打印这些文本行即可。

```c
#include <stdio.h>
#include <string.h>

#define MAXLINES 5000	//进行排序的最大文本行数

char *lineptr[MAXLINES]	//指向文本行的指针数组

int readlines(char *lineptr[], int nlines);
void writelines(char *lineptr[], int nlines);

void qsort(char *lineptr[], int left, int right);

//对输入的文本行进行排序
main()
{
	int nlines;	//读取的输入行数目 
   	
    if ((nlines = readlines(lineptr, MAXLINES)) >= 0) {
        qsort(lineptr, 0, nlines-1);
        writelines(lineptr, nlines);
        return 0;
    } else {
        printf("error: input too big to sort\n");
        return 1;
    }
}

#define MAXLEN 1000	//每个输入文本行的最大长度
int getline(char *, int);
char *alloc(int);

//readlines函数：读取输入行
int readlines(char *lineptr[], int maxlines)
{
    int len, nlines;
    char *p, line[MAXLEN];
    
    nlines = 0;
    while ((len = getline(line, MAXLEN)) > 0) {
        if (nlines >= maxlines || p = alloc(len) == NULL) {
            return -1;
        } else {
            line[len-1] = '\0';	//删除换行符
            strcpy(p, line);
            lineptr[nlines++] = p;
        }
    }
    return nlines;
}

//writelines函数：写输出行
void writelines(char *lineptr[], int nlines)
{
    int i;
    
    for (i = 0; i < nlines; i++) {
        printf("%s\n", lineptr[i]);
    }
}
```



有关函数 getline 的详细信息参见 1.9 节。

在该例子中，指针数组 lineptr 的声明是新出现的重要概念：

char *lineptr[MAXLINES];

它表示 lineptr 是一个具有 MAXLINES 个元素的一维数组，其中数组的每个元素是一个指向字符类型对象的指针。也就是说，lineptr[i] 是要给字符指针，而 *lineptr[i] 是该指针指向的第 i 个文本行的首字符。

由于 lineptr 本身是一个数组名，因此，可按照前面例子中相同的方法将其作为指针使用，这样，writelines 函数可以改写为：

//writelines函数：写输出行

void writelines(char *lineptr[], int nlines)

{

​	while (nlines-- > 0) {

​		printf("%s\n", *lineptr++);

​	}

}

（注意这里的数组变量 lineptr 可以改变值）

循环开始执行时，*lineptr 指向第一行，每执行依次自增运算都使得 lineptr 指向下一行，同时对 nlines 进行自减运算。

在明确了输入和输出函数的实现方法之后，下面便可以着手考虑文本行得排序问题了。在这里需要对第 4 章得快速排序函数做一些小改动：首先，需要修改该函数得声明部分；其次，需要调用 strcmp 函数完成文本行得比较运算。但排序算法在这里仍然有效，不需要做任何改动。

```c
//qsort 函数：以递增顺序对 v[left]...v[right] 进行排序
void qsort(char *v[], int left, int right)
{
    int i, last;
    void swap(char *v[], int i, int j);
    if (left >= right) {	//若数组包含的元素数少于两个，则不执行任何操作	
        return;
    }
    //将划分子集的元素；整数除法会截断结果中的小数部分
    swap (v, left, (left + right)/2);	
    last = left;	//移动到 v[0]
    for (i = left + 1; i <= right; i++) {	//划分子集
        if (stccmp(v[i], v[left]) < 0) {
            swap(v, ++last, i);
        }
    }
    swap(v, left, last);	//恢复划分子集的元素
    qsort(v, left, last-1);
    qsort(v, last+1, right);
}

//这里之所以将数组元素交换操作放在一个单独的函数 swap 中，是因为它在 qsort 函数中要使用 3 次。

//同样，swap 函数也只需要做一些很小的改动：
void swap(char *v[], int i, int j)
{
    char *temp;
        
    temp = v[i];
    v[i] = v[j];
    v[j] = temp;
}
```



因为 v（别名为 lineptr）的所有元素都是字符指针，并且 temp 也必须是字符指针，因此 temp 与 v 的任意元素之间可以互相复制。





#### 5.7	多维数组

略





#### 5.8	指针数组的初始化

考虑这样一个问题：编写一个函数 month_name(n)，它返回一个指向第 n 个月名字的字符串的指针。这是内部 static 类型数组的一种理想的应用。month_name 函数中包含一个私有的字符串数组，当它被调用时，返回一个指向正确元素的指针。本节将说明如何初始化该名字数组。

指针数组的初始化语法和前面所讲的其它类型对象的初始化语法类似：

```c
//month_name函数：返回第 n 个月份的名字
char *month_name(int n)
{
    static char *name[] = {
        "Illegal month",
        "January", "February", "March",
        "April", "May", "June",
        "July", "August", "September",
        "October", "November", "December"
    };
    
    return (n < 1 || n > 12) ? name[0] : name[n];
}
```



其中，name 的声明与排序例子中 lineptr 的声明相同，是一个一维数组，数组的元素为字符指针。name 数组的初始化通过一个字符串列表实现，列表中的每个字符串赋值给数组相应位置的元素。第 i 个字符串的所有字符存储在存储器中的某个位置，指向它的指针存储在 name[i] 中。由于上述声明中没有指明 name 的长度，因此，编译器编译时将对初值个数进行统计，并将这一准确数字填入数组的长度。





#### 5.9	指针与多维数组

略





#### 5.10	命令行参数

在支持 C 语言的环境中，可以在程序开始执行时将命令行参数传递给程序。调用主函数 main 时，它带有两个参数。第一个参数（习惯上称为 argc，用于参数计数）的值表示运行程序时命令行中参数的数目；第二个参数（称为 argv，用于参数向量）是要给指向字符串数组的指针，其中每个字符串对应一个参数。我们通常用多级指针处理这些字符串。

最简单的例子时程序 echo，它将命令行参数回显在屏幕上的一行中，其中命令行中各参数之间用空格隔开。也就是说，命令

echo hello, world

将打印下列输出：

hello, world

按照 C 语言的约定，argv[0] 的值是启动该程序的程序名，因此 argc 的值至少为 1。如果 argc 的 值为 1，则说明程序名后面没有命令行参数。在上面的例子中，argc 的值为 3，argv[0]、argv[1]  和 argv[2] 的值分别为  "echo"、"hello,"，以及 "world"。第一个可选参数为 argv[1]，而最后一个可选参数为 argv[argc-1]。另外，ANSI 标准要求 argv[argc] 的值必须为一空指针（参见图 5-11）。

<div align=center>
	<img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80%20-%20%E5%9B%BE7.jpg"/>
</div>

程序 echo 的第一个版本将 argv 看成是一个字符指针数组：

```c
#include <stdio.h>

//回显程序命令行参数；版本1
main(int argc, char *argv[])
{
	int i;

    for (i = 1; i < argc; i++) {
        printf("%s%s", argv[i], (i < argc-1) ? " " : "");
    }
    printf("\n");
    return 0;
}
```



因为 argv 是一个指针数组的指针，所以，可以通过指针而非数组下标的方式处理命令参数。echo 程序的第二个版本是在对 argv 进行自增运算、对 argc 进行自减运算的基础实现的，其中 argv 是一个指向 char 类型的指针的指针：

```c
#include <stdio.h>

//回显程序命令行参数；版本2
main(int argc, char *argv[])
{
    while (--argc > 0) {
        printf("%s%s", *++argv, (argc > 1) ? " " : "");
    }
    printf("\n");
    return 0;
}
```



因为 argv 是一个指向参数字符串数组起始位置的指针，所以，自增运算（++argv）将使得它在最开始指向 argv[1] 而非 argv[0]。每执行依次自增运算，就使得 argv 指向下一个参数，*argv 就是指向那个参数的指针。与此同时，argc 执行自减运算，当它变成 0 时，就完成了所有参数的打印。

也可以将 printf 语句写成下列形式：

printf((argc > 1) ? "%s " : "%s", *++argv);

这就说明，printf 的格式化参数也可以是表达式。

我们来看第二个例子。在该例子中，我们将增强 4.1 节中模式查找程序的功能。在 4.1 节中，我们将查找模式内置到程序中了，这种解决方法显然不能令人满意。下面我们来效仿 UNIX 程序 grep 的实现方法改写模式查找程序，通过命令行的第一个参数指定待匹配的模式。

```c
#include <stdio.h>
#include <string.h>
#define MAXLINE 1000

int getline(char *line, int max);

//find函数：打印与第一个参数指定的模式匹配的行
main(int argc, char *argvp[])
{
    char line[MAXLINE];
    int found = 0;
    
    if (argc != 2) {
        printf("Usage: find pattern\n");
    } else {
        while (getline(line, MAXLINE) > 0) {
            if (strstr(line, argv[1]) != NULL) {
                printf("%s", line);
                found++;
            }
        }
    }
    return found;
}
```



标准库函数 strstr(s, t) 返回一个指针，该指针指向字符串 t 在字符串 s 中第一次出现的位置；如果字符串 t 没有在字符串 s 中出现，函数返回 NULL（空指针）。该函数声明在头文件 <string.h>。

为了更进一步地解释指针结构，我们来改进模式查找程序。假定允许程序带两个可选参数。其中一个参数表示 “打印除匹配模式之外的所有行”，另一个参数表示 “每个打印的文本行前面加上相应的行号”。

UNIX 系统中的 C 语言程序有一个公共的约定：以符号开头的参数表示一个可选标志或参数。假定用 -x（代表 “除....之外”）表示打印所有与模式不匹配的文本行，用 -n（代表 “行号”）表示打印行号，那么下列命令：

find -x -n 模式

将打印所有与模式不匹配的行，并在每个打印行的前面加上行号。

可选参数应该允许以任意次序出现，同时，程序的其余部分应该与命令行中参数的数目无关。此外，如果可选参数能够组合使用，将会给使用者带来更大的方便，比如：

find -nx 模式

改写后的模式查找程序如下所示：

```c
#include <stdio.h>
#include <string.h>
#define MAXLINE 1000

int getline(char *line, int max);

//find函数：打印与第一个参数指定的模式相匹配的行
main(int argc, char *argv[])
{
    char line[MAXLINE];
    long lineno = 0;
    int c, except = 0, number = 0, found = 0;
    
    wihle (--argc > 0 && (*++argv)[0] == '-') {
        while (c = *++argv[0]) {
            switch (c) {
                case 'x':
                   except = 1;
                   break;
                case 'h':
                   number = 1;
                   break;
                default:
                   printf("find: illegal option %c\n", c);\
                   argc = 0;
                   found = -1;
                   break;
            }
        }
    }
    if (argc != 1) {
        printf("Usage: find -x -n pattern\n");
    } else {
        while (getline(line, MAXLINE) > 0) {
            lineno++;
            if ((strstr(line, *argv) != NULL) != except) {
                if (number) {
                    printf("%ld:", lineno);
                }
                printf("%s", line);
                found++;
            }
        }
    }
    return found;
}
```



在处理每个可选参数之前，argc 执行自减运算，argv 执行自增运算。循环语句结束时，如果没有错误，则 argc 的值表示还没有处理的参数数目，而 argv 则指向这些未处理参数中的第一个参数。因此，这时 argc 的值应为 1，而 *argv 应该指向模式。注意， *++argv 是一个指向参数字符串的指针，因此 ( *++argv)[0] 是它的第一个字符（另一种有效形式是 **++argv）。因为 [] 与操作符的集合优先级比 * 和 ++ 高，所以在上述表达式中必须使用圆括号，否则编译器将会把该表达式当作 *++(argv[0])。实际上，我们在内层循环中就使用了表达式 *++argv[0]，其目的是遍历一个特定的参数串。在内层循环中，表达式 *++argv[0] 对指针 argv[0] 进行了自增运算。

很少有人使用比这更复杂的指针表达式。如果遇到这种情况，可以将它们分为两步三步来理解，这样会更直观一些。



#### 5.11	指向函数的指针

在 C 语言中，函数本身不是变量，但可以定义指向函数的指针。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等。为了说明指向函数的指针的用法，我们接下来将修改本章前面的排序函数，在给定可选参数 -n 的情况下，该函数将按数值大小而非字典顺序对输入行进行排序。

排序程序通常包括 3 部分：判断任何两个对象之间次序的比较操作、颠倒对象次序的交换操作、一个用于比较和交换对象直到所有对象都按正确次序排序的排序算法。由于排序算法与比较、交换操作无关，因此，通过在排序算法中调用不同的比较和交换函数，便可以实现不同的标准排序。这就是我们的新版本排序函数所采用的方法。

我们在前面讲过，函数 strcmp 按字典顺序比较两个输入行。在这里，我们还需要一个以数值为基础来比较两个输入行，并返回与 strcmp 同样的比较结果的函数 numcmp。这些函数在 main 之前声明，并且，指向恰当函数的指针将被传递给 qsort 函数。在这里，参数的出错问题并不是问题的重点，我们将主要考虑指向函数的指针问题。

```c
#include <stdio.h>
#include <string.h>

#define MAXLINES 5000		//待排序的最大行数
char *lineptr[MAXLINES];	//指向文本行的指针

int readlines(char *lineptr[], int nlines);
void writeliens(char *lineptr[], int nlines);

void qsort(void *lineptr[], int left, int right, 
		 int (*comp)(void *, void *));
int numcmp(char *, char *);

//对输入的文本进行排序
main(int argc, char *argv[])
{
	int nlines;			//读入的输入行数
    int numeric = 0;	//若进行数值排序，则 numeric 的值为 1
    
    if (argc > 1 && strcmp(argv[1], "-n") == 0) {
        numeric = 1;
    }
    if ((nlines = readlines(lineptr, MAXLINES)) >= 0) {
        qsort((void**) lineptr, 0, nlines-1,
             (int (*)(void*, void*))(numeric ? numcmp : strcmp));
        writelines(lineptr, nlines);
        return 0;
    } else {
        printf("input too big to sort\n");
    }
}
```



在调用函数 qsort 的语句中，strcmp 和 numcmp 是函数的地址。因为它们是函数，所以前面不需要加上取地址运算符 &，同样的原因，数组名前面也不需要 & 运算符。

改写后的 qsort 函数能够处理任何数据类型，而不仅仅限于字符串。从函数 qsort 的原型可以看出，它的参数表包括一个指针数组、两个整数和一个有两个指针参数的函数。其中，指针数组参数的类型为通用指针类型 void *。**由于任何类型的指针都可以转换为 void * 类型，并且在将它转换回原来的类型时不会丢失信息**，所以，调用 qsort 函数时可以将参数强制转换为 void * 类型。比较函数的参数也要执行这种类型的转换。这种转换通常不会影响到数据的实际表示，但要确保编译器不会报错。

```c
//qsort函数：以递增顺序对 v[left]...v[right] 进行排序
void qsort(void *v[], int left, int right, 
          int (*comp)(void *, void *))
{
    int i, last;
    void swap(void *v[], int, int);
    if (left >= right) {	//若数组包含的元素数少于两个，则不执行任何操作	
        return;
    }
    //将划分子集的元素；整数除法会截断结果中的小数部分
    swap (v, left, (left + right)/2);	
    last = left;	//移动到 v[0]
    for (i = left + 1; i <= right; i++) {	//划分子集
        if ((*comp)(v[i], v[left]) < 0) {
            swap(v, ++last, i);
        }
    }
    swap(v, left, last);	//恢复划分子集的元素
    qsort(v, left, last-1, comp);
    qsort(v, last+1, right, comp);
}
```



我们仔细研究一下其中的声明。qsort 函数的第四个参数声明如下：

int (*comp)(void *, void *)

它表明 comp 是一个指向函数的指针，该函数具有两个 void * 类型的参数，其返回值类型为 int。

在下列语句中：

if ((*comp)(v[i], v[left]) < 0)

comp 的使用和其声明是一致的，comp 是一个指向函数的指针，*comp 代表一个函数。下列语句是对该函数进行调用：

(*comp)(v[i], v[left])

其中的圆括号是必须的，这样才能够保证其中的各个部分正确结合。如果没有括号，例如写成下面的形式：

int *comp(void *, void *)	//错误示例

则表明 comp 是一个函数，该函数返回一个指向 int 类型的指针，这同我们的本意显然有很大的差别。

我们在前面讲过函数 strcmp，它用于比较两个字符串。这里介绍的函数 numcmp 也是比较两个字符串，但它通过调用 atof 计算字符串对应的数值，然后在此基础上进行比较：

```c
#include <stdlib.h>
//numcmp函数：按数值顺序比较字符串 s1 和 s2
int numcmp(char *s1, char *s2)
{
    double v1, v2;
    
    v1 = atof(s1);
    v2 = atof(s2);
    if (v1 < v2) {
        return -1;
    } else if(v1 > v2) {
        return 1;
    } else {
        return 0;
    }
}
```



交换两个指引的 swap 函数和本章前面所述的 swap 函数相同，但它的参数声明为 void * 类型。

```c
void swap(void *v[], int i, int j)
{
    void *temp;
    
    temp = v[i];
    v[i] = v[j];
    v[j] = temp;
}
```





#### 5.12	复杂声明

C 语言常常因为声明的语法问题而受到人们的批评，特别是涉及到函数指针的语法。C 语言的语法力图使声明和使用相一致。对于简单的情况，C 语言的做法是很有效的，但是，如果情况比较复杂，则容易让人混淆，原因在于，C 语言的声明不能从左至右阅读，而且使用了太多的圆括号。我们来看下面所示的两个声明：

int *f();		//f：是一个函数，它返回一个指向 int 类型的指针

int (*pf)();	//pf：是一个指向函数的指针，该函数返回一个 int 类型的对象

它们之间的含义差别说明：* 是一个前缀运算符，其优先级低于 ()，所以，声明中必须使用圆括号以保证正确的结合顺序。

尽管实际中很少用到过于复杂的说明，但是，懂得如何理解甚至如何使用这些复杂的说明是很重要的。如何创建复杂的声明呢？一种比较好的方法是，使用 typedef 通过简单的步骤合成，这种方法我们将在 6.7 节中讨论。这里介绍另一种方法。略。	





### 第 6 章	结构

















































































































































































































































































































































































































































































































































































