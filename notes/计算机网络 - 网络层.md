## 网络层

#### 概述

**网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务**。这里的数据报（datagram）就是 “分组”。

网络在发送分组时不需要先建立连接。每一个分组独立发送，与其前后的分组无关（不进行编号）。**网络层不提供服务质量的承诺**。也就是说，所传送的分组可能出错、丢失、重复和失序（即不按序到达终点），当然也不保证分组交付的时限。由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器比较简单，且价格低廉（与电信网的交换机相比较）。如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制等）。



#### 网际协议 IP

与 IP 协议配套使用的还有三个协议：

- **地址解析协议 ARP**（Address Resolution Protocol）
- **网际控制报文协议 ICMP**（Internet Control Message Protocol）
- **网际组管理协议 IGMP**（Internet Group Management Protocol）

图 4-2 画出了这三个协议和网际协议 IP 的关系。在这一层中，ARP 画在最下面，因为 IP 经常要使用这个协议。ICMP 和 IGMP 画在这一层的上部，因为它们要使用 IP 协议。由于网际协议 IP 是用来使互接起来的许多计算机网络能够进行通信的，因此 TCP/IP 体系中的网络层常常被称为**网际层**（internet layer），或 IP 层。使用 “网际层” 这个名称的好处是强调这是由很多网络构成的互连网络。 

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE1.jpg"/> </div><br>
#### 分类的 IP 地址

##### 1.IP 地址及其表示方法

整个的互联网就是一个**单一的、抽象的网络**。IP 地址就是给互联网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的 32 位的标识符。IP 地址的结构使我们可以在互联网上很方便地进行寻址。

IP 地址的编址方法共经过了三个历史阶段。

（1）**分类的 IP 地址**。这是最基本的编址方法。

（2）**子网的划分**。这是对最基本的编址方法的改进。

（3）**构成超网**。这是比较新的无分类编址方法。

所谓 “分类的 IP 地址” 就是将 IP 地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成，其中第一个字段是**网络号**（net-id），它标志主机（或路由器）所连接到的网络。一个网络号在整个互联网范围内必须是唯一的。第二个字段是主机号（host-id），它标志该主机（或路由器）。一台主机号在它前面的网络号所指明的网络范围内必须是唯一的。由此可见，一个 IP 地址**在整个互联网范围内是唯一的**。

这种两级的 IP 地址可以记为：

IP 地址 ::={<网络号>,<主机号>}



图 4-5 给出了各种 IP 地址的网络号字段和主机号字段，这里 A 类、 B 类和 C 类地址都是**单播地址**（一对一通信），是最常用的。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE2.png"/> </div><br>
从图 4-5 可以看出：

- A 类、 B 类和 C 类地址的网络号字段（在途中这个字段是灰色的）分别为 1 个、 2 个和 3 个字节长，而在网络号字段的最前面有 1~3 位的**类别位**，其数指分别规定为 0， 10 和 110。
- A 类、 B 类和 C 类地址的主机号字段分别为 3 个、 2 个和 1 个字节长。
- D 类地址（前 4 位是 1110）用于**多播**（一对多通信）。
- E 类地址（前 4 位是 1111）保留为以后用。	

这里要指出，由于近年来已经广泛使用无分类 IP 地址进行路由选择，A 类、 B 类和 C 类地址的区分已成为历史。为了理解概念的演进，我们这里还要从分类的 IP 地址讲起。

从 IP 地址的结构来看，**IP** 地址并不仅仅指明一台主机，而是还指明了主机所连接到的网络。

把 IP 地址划分为 A 类、 B 类和 C 类三个类别，当初是这样考虑的。各种网络的差异很大，有的网络拥有很多主机，而有的网络上的主机则很少。把 IP 地址划分为 A 类、 B 类和 C 类是为了更好地满足不同用户的要求。当某个单位申请到一个 IP 地址时，实际上是获得了具有同样网络号的一块地址。其中具体的各台主机号则由该单位自行分配，只要做到在该单位管辖的范围内无重复的主机号即可。

对主机或路由器来说，IP 地址都是 32 位的二进制代码。为了提高可读性，我们常常把 32 位的 IP 地址中的每 8 位插入一个空格（**但在机器中并没有这样的空格**）。为了便于书写，可用其等效的十进制数字表示，并且在这些数字之间加上一个点。这就叫做**点分十进制记法**（dotted decimal notation）。图 4-6 是一个 B 类 IP 地址的表示方法。显然，128.11.3.31 比 10000000 00001011 00000011 00011111 书写起来要方便得多。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE3.jpg"/> </div><br>
##### 2.常用的三种类别的 IP 地址

A 类地址的网络号字段占 1 个字节，只有 7 位可供使用（该字段的第一位已固定为 0），但可指派的网络号是 126 个（即 2^32^ - 2）。减 2 的原因是：第一，IP 地址中的全 0 表示 “**这个**（this）”。网络号字段为全 0 的 IP 地址是个保留地址，意思是 “本网络”；第二，网络号为 127（即 01111111）保留作为本地软件**环回测试**（loopback test）本主机的进程之间的通信之用。若主机发送一个目的地址为环回地址（例如 127.0.0.1）的 IP 数据报，则本主机中的协议软件就处理数据报中的数据，而不会把数据报发送到任何网络。目的地址为环回地址的 IP 数据报永远不会出现在任何网络上，因为网络号为 127 的地址根本不是一个网络地址。

关于全 1 和全 0 还可以再举两个例子。例如，B 类地址 128.7.255.255 表示 “在网络 128.7.0.0 上的所有主机”。而 A 类地址 0.0.0.35 则表示 ”在这个网络上主机号为 35 的主机“。

A 类地址的主机号占 3 个字节，因此每一个 A 类网络中的最大主机数是 2^24^ - 2，即 16777214。这里减 2 的原因是：全 0 的主机号字段表示该 IP 地址是 “本主机” 所连接到的**单个网络地址**（例如，一主机的 IP 地址为 5.6.7.8，则该主机所在的网络地址就是 5.0.0.0），而全 1 表示 “**所有的**（all）”，因此全 1 的主机号字段表示该网络上的所有主机。

如果主机号全 0，IP 地址代表仅网络号指向的那个网段，该 IP 代表一个网段；如果主机号全 1，IP 地址代表网络号指向的全部主机，IP 地址代表广播地址 ；其他就是普通的 IP 地址，指向网域中的一个主机了。

在 A 类、B 类、C 类 IP 地址中，如果主机号是全 1，那么这个地址为直接广播地址，它是用来使路由器将一个分组以广播形式发送给特定网络上的所有主机。32 位全为 1 的 **IP地址 ** “255.255.255.255” 为**受限广播地址**（"limited broadcast" destination address），用来将一个分组以广播方式发送给本网络中的所有主机，路由器则阻挡该分组通过，将其广播功能限制在本网内部。

IP 地址空间共有 2^32^（即 4294967296）个地址。整个 A 类地址空间共有 2^31^ 个地址，占整个 IP 地址空间的 50%。

B 类地址的网络号字段有 2 个字节，但前面两位（1 0）已经固定了，只剩下 14 位可以进行分配。因为网络号字段后面的 14 位无论怎样取值也不可能出现使整个 2 字节的网络号字段成为全 0 或全 1，因此这里不存在网络总数减 2 的问题。但实际上 B 类网络地址 128.0.0.0 是不指派的，而可以指派的 B 类最小网络地址是 128.1.0.0[COME06]。因此 B 类地址可指派的网络数为 2^14^ - 1，即 16383。B 类地址的每一个网络上的最大主机数是 2^16^ - 2，即 65534。这里需要减 2 是因为要扣除全 0 和全 1 的主机号。整个 B 类地址空间共约有 2^30^ 个地址，占整个 IP 地址空间的 25%。

C 类地址有 3 个字节的网络号字段，最前面的 3 位是（1 1 0），还有 21 位可以进行分配。C 类网络地址 192.0.0.0 也是不指派的，可以指派的 C 类最小网络是 192.0.1.0[COME06]，因此 C 类地址可指派的网络总数是 2^21^ - 1，即 2097151。每一个 C 类地址的最大主机是 2^8^ - 2，即 254。整个 C 类地址空间共约有 2^29^ 个地址，占整个 IP 地址的 12.5%。

这样，我们就可得出表 4-2 所示的 IP 地址的指派范围。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE4.jpg"/> </div><br>
IP 地址具有以下一些重要特点。

（1）每一个 IP 地址都由网络号和主机号两部分组成。从这个意义上说，IP 地址是一种**分等级的地址结构**。分两个等级的好处是：第一，IP 地址管理机构在分配 IP 地址时**只分配网络号**（第一级），而剩下的主机号（第二级）则由得到该网络号的单位来自行分配。这样就方便了 IP 地址的管理；第二，路由器**仅根据目的主机所连接的网络号来转发分组**（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度较少，从而**减小了路由表所占的存储空间以及查找路由表的时间**。

（2）实际上 IP 地址是标志一台主机（或路由器）和一条链路的**接口**。当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号必须是不同的。这种主机称为**多归属主机**（multihomed host）。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的 IP 地址。这好比一个建筑正好处在北京路和上海路的交叉口上，那么这个建筑就可以拥有两个门牌号码。例如，北京路 4 号和上海路 37 号。

（3）按照互联网的观点，一个网络是指具有相同网络号 net-id 的主机的集合，因此，**用转发器或网桥连接起来的若干个局域网仍为一个网络**，因为这些局域网都具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连。

（4）在 IP 地址中，所有分配到网络号的网络（不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网）都是**平等**的。所谓平等，是指互联网同等对待每一个 IP 地址。



#### IP 地址与硬件地址

从层次的角度看，**物理地址是数据链路层和物理层使用的地址**，而 **IP 地址是网络层和以上各层使用的地址，是一种逻辑地址**（称 IP 地址为逻辑地址是因为 IP 地址是用软件实现的）。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE5.jpg"/> </div><br>
在发送数据时，数据从高层下到低层，然后才到通信链路上传输。使用 IP 地址的 IP 数据报一旦交给了数据链路层，就被封装成 MAC 帧了。MAC 帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在 MAC 帧的首部中。

连接在通信链路上的设备（主机或路由器）在收到 MAC 帧时，根据 MAC 帧首部中的硬件地址决定收下或丢弃。只有在剥去 MAC 帧的首部和尾部后把 MAC 层的数据上交给网络层后，网络层才能在 IP 数据报的首部中找到源 IP 地址和目的 IP 地址。

总之，IP 地址放在 IP 数据报的首部，而硬件地址则放在 MAC 帧的首部。在网络层和网络层以上使用的是 IP 地址，而数据链路层及以下使用的是硬件地址。在图 4-8 中，当 IP 数据报放入数据链路层的 MAC 帧中以后，整个的 IP 数据报就成为 MAC 帧的数据，因而在数据链路层看不见数据报的 IP 地址。

图 4-9(a)画的是三个局域网用两个路由器 R~1~ 和 R~2~ 互连的情况。现在主机 H1 要和主机 H2 通信。这两台主机的 IP 地址分别是 IP~1~ 和 IP~2~，而它们的硬件地址分别为 HA~1~ 和 HA~2~（HA 表示 Hardware Address）。通信的路径是：H~1~——经过 R~1~ 转发——再经过 R~2~ 转发——H~2~。路由器 R~1~ 因同时连接到两个局域网上，因此说它有两个硬件地址，即  HA~3~ 和 HA~4~。同理，路由器 R~2~ 也有两个硬件地址 HA~5~ 和 HA~6~。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE6.jpg"/> </div><br>
图 4-9(b)特别强调了 IP 地址与硬件地址的区别。表 4-4 归纳了这种区别。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE7.jpg"/> </div><br>
这里要强调指出以下几点：

（1）**在 IP 层抽象的互联网上只能看到 IP 数据报**。虽然 IP 数据报要经过路由器 R~1~ 和 R~2~ 的两次转发，但在它的首部中的源地址和目的地址**始终**分别是 IP~1~ 和 IP~2~。图中的数据报上写的 “从 IP~1~ 到 IP~2~” 就表示前者是源地址而后者是目的地址。数据报中间经过的两个路由器的 IP 地址并不出现在 IP 数据报的首部中。

（2）虽然在 IP 数据报首部有源站 IP 地址，但**路由器只根据目的站的 IP 地址的网络号进行路由选择**。

（3）**在局域网的链路层，只能看见 MAC 帧**。IP 数据报被封装在 MAC 帧中。MAC 帧在不同网络上传送时，其 MAC 帧首部中的源地址和目的地址要发生变化，见图 4-9(b)。开始在 H~1~ 和 R~1~ 间传送时，MAC 帧首部中写的是从硬件地址 HA~1~ 发送到硬件地址 HA~3~，路由器 R~1~ 收到此 MAC 帧后，在数据链路层，要丢弃原来的 MAC 帧的首部和尾部。在转发时，在数据链路层，要重新加上 MAC 帧的首部和尾部。这时首部中的源地址和目的地址分别便成为 HA~4~ 和 HA~5~。路由器 R~2~ 收到此帧后，再次更换 MAC 帧的首部和尾部，首部中的源地址和目的地址分别变为 HA~6~ 和 HA~2~。MAC 帧的首部的这种变化，在上面的 IP 层上是看不见的。

（4）尽管互连在一起的网络的硬件地址体系各不相同，但 **IP 层抽象的互联网却屏蔽了下层这些很复杂的细节。只要我们在网络层上讨论问题，就能够使用统一的、抽象的 IP 地址研究主机和主机或路由器之间的通信**。上述的这种 “屏蔽” 概念是一个很有用、很普遍的基本概念。例如，计算机中广泛使用的图形用户界面使得用户只需简单地点击几下鼠标就能让计算机完成很多任务。实际上计算机要完成这些任务必须执行很多条指令。但这些复杂的过程全都被设计良好的图形用户界面屏蔽掉了，使用户看不见这些复杂过程。

以上这些概念是计算机网络的精髓所在，对这些重要概念务必仔细思考和掌握。





#### 地址解析协议 ARP

在实际应用中，我们经常会遇到这样的问题：已经知道了一个机器（主机或路由器）的 IP 地址，需要找出其相应的硬件地址。地址解析协议 ARP 就是用来解决这样的问题的。图 4-10 说明了 ARP 协议的作用。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE8.jpg"/> </div><br>
由于是 IP 协议使用了 ARP 协议，因此通常就把 ARP 协议划归网络层。但 ARP 协议的用途是为了从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。因此，有的教科书就按照协议的作用，把 ARP 协议划归在数据链路层。这样做当然也是可以的。

我们知道，网络层使用的是 IP 地址，但在实际网络的链路上传送数据帧时，最终还是必须使用该网络的硬件地址。但 IP 地址和下面的网络的硬件地址之间由于格式不同而不存在简单的映射关系（例如，IP 地址有 32 位，而局域网的硬件地址是 48 位）。此外，在一个网络上可能经常会有新的主机加入进来，或撤走一些主机。更换网络适配器也会使主机的硬件地址改变。**地址解析协议** ARP 解决这个问题的方法是在主机 ARP 高速缓存中存放一个从 IP 地址到硬件地址的映射表，并且这个映射表还经常动态更新（新增或超时删除）。

每一台主机都设有一个 ARP **高速缓存**（**ARP cache**），里面有**本局域网上**的各主机和路由器的 IP 地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。那么主机怎样知道这些地址呢？我们可以通过下面的例子来说明。

当主机 A 要向**本局域网**上的某台主机 B 发送 IP 数据报时，就现在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就在 ARP 高速缓存中查出其对应的硬件地址，再把这个硬件地址写入 MAC 帧，然后通过局域网把该 MAC 帧发往此硬件地址。

也有可能查不到主机 B 的 IP 地址的项目。这可能是主机 B 才入网，也可能是主机 A 刚刚加电，其高速缓存还是空的。在这种情况下，主机 A 就自动运行 ARP，然后按以下步骤找出主机 B 的硬件地址。

（1）ARP 进程在本局域网上广播发送一个 ARP 请求分组。图 4-11(a) 是主机 A 广播发送 ARP 请求分组的示意图。ARP 请求分组的主要内容是：“我的 IP 地址是 209.0.0.5，硬件地址是 00-00-C0-15-AD-18。我想知道 IP 地址为 209.0.0.6 的主机的硬件地址。”

（2）在本局域网上的所有主机上运行的 ARP 进程都收到此 ARP 请求分组。

（3）主机 B 的 IP 地址与 ARP请求分组中要查询的 IP 地址一致，就收下这个 ARP 请求分组，并向主机 A 发送 ARP 响应分组，同时在这个 ARP 响应分组中写入自己的硬件地址。由于其余的所有主机的 IP 地址都与 ARP 请求分组中要查询的 IP 地址不一致，因此都不理睬这个 ARP 请求分组，见图 4-11(b)。ARP 响应分组的主要内容是：“我的 IP 地址是 209.0.0.6，我的硬件地址是 08-00-2B-00-EE-0A。” 请注意：虽然 ARP 请求分组是广播发送的，但 ARP 响应分组是普通的单播，即从一个源地址发送到一个目的地址。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE9.jpg"/> </div><br>
（4）主机 A 收到主机 B 的 ARP 响应分组后，就在其 ARP 高速缓存中写入主机 B 的 IP 地址到硬件地址的映射。

当主机 A 向 B 发送数据报时，很可能以后不久主机 B 还要向 A 发送数据报，因而主机 B 也可能要向 A 发送 ARP 请求分组。为了减少网络上的通信量，主机 A 在发送其 ARP 请求分组时，就把自己的 IP 地址到硬件地址的映射写入 ARP 请求分组。当主机 B 收到 A 的 ARP 请求分组时，就把主机 A 的这一地址映射写入主机 B 自己的 ARP 高速缓冲中。以后主机 B 向 A 发送数据报时就很方便了。

可见 ARP 高速缓存非常有用。如果不使用 ARP 高速缓存，那么任何一台主机只要进行一次通信，就必须在网络上用广播方式发送 ARP 请求分组，这就使网络上的通信量大大增加。ARP 把已经得到的地址映射保存在高速缓存中，这样就使得该主机下次再和具有同样目的地址的主机通信时，可以直接从高速缓存中找到所需的硬件地址而不必再用广播方式发送 ARP 请求分组。

ARP 对保存在高速缓存中的每一个映射地址项目都设置生存时间（例如，10 ~ 20 分钟）。凡超过生存时间的项目就从高速缓存中删除掉。设置这种地址映射项目的生存时间是很重要的。设想有一种情况。主机 A 和 B 通信。A 的 ARP 高速缓存里保存有 B 的硬件地址。但 B 的网络适配器突然坏了，B 立即更换了一块，因此 B 的硬件地址就改变了。假定 A 还要和 B 继续通信。A 在其 ARP 高速缓存中查找到 B 原先的硬件地址，并使用该硬件地址向 B 发送数据帧。但 B 原先的硬件地址已经失效了，因此 A 无法找到主机 B。但是过了一段不长的生存时间，A 的 ARP 高速缓存中已经删除了 B 原先的硬件地址，于是 A 重新广播发送 ARP 请求分组，又找到了 B。

请注意，ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，例如，在前面的图 4-9 中，主机 H~1~ 就无法解析出另一个局域网上主机 H~2~ 的硬件地址（实际上主机 H~1~ 也不需要知道远程主机 H~2~ 的硬件地址）。主机 H~1~ 发送给 H~2~ 的 IP 数据报首先需要通过与主机 H~1~ 连接在在同一个局域网上的路由器 R~1~ 来转发。因此主机 H~1~ 这时需要把路由器 R~1~ 的 IP 地址 IP~3~ 解析为硬件地址 HA~3~，以便能够把 IP 数据报传送到路由器 R~1~。以后，R~1~ 从转发表找出了下一跳路由器 R~2~，同时使用 ARP 解析出 R~2~ 的硬件地址 HA~5~。于是 IP 数据报按照硬件地址 HA~5~ 转发到路由器 R~2~。路由器 R~2~ 在转发这个 IP 数据报时用类似方法解析出目的主机 H~2~ 的硬件地址 HA~2~，使 IP 数据报最终交付主机 H~2~。

从 IP 地址到硬件地址的解析是自动运行的，**主机的用户对这种地址解析过程是不知道的**。只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地把这个 IP 地址解析为链路层所需要的硬件地址。

既然在网络链路上传送的帧最终是按照硬件地址找到目的主机的，那么为什么我们还要使用抽象的 IP 地址，而不直接使用硬件地址进行通信？这样似乎可以免除使用 ARP。

谢希仁老师的计算机网络（第7版）原文解释的不清晰，可以参考知乎的回答：

[谢希仁 计算机网络（第七版）第四章，说为什么不直接使用硬件地址通信，解释实在没看懂，求解答?](https://www.zhihu.com/question/327977420)





#### IP 数据报的格式

IP 数据报的格式能够说明 IP 协议都具有什么功能。在 TCP/IP 的标准中，各种数据格式常常以 32 位（即 4 字节）为单位来描述。图 4-13 是 IP 数据报的完整格式。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE10.jpg"/> </div><br>
从图 4-13 可看出，一个 IP 数据报由首部和数据两部分组成。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。在首部的固定部分的后面是一些可选字段，其长度是可变的。

下面介绍首部各字段的意义。

##### 1. IP 数据报首部的固定部分中的各字段

（1）**版本**：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议的版本必须一致。目前广泛使用的 IP 协议版本号为 4（即 IPv4）。

（2）**首部长度**：占 4 位，可表示的最大十进制数值是 15。请注意，首部长度字段所表示的单位是 32 位字（1 个 32 位字长是 4 字节）。因为 IP 首部的固定长度是 20 字节，因此首部长度字段的最小值是 5（即二进制表示的首部长度是 0101）。而当首部长度为最大值 1111 时（即十进制的 15），就表明首部长度达到最大值 15 个 32 位字长，即 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此 IP 数据报的数据部分永远在 4 字节的整数倍时开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度是 20 字节（即首部长度位 0101），这时不使用任何选项。

（3）**区分服务**：占 8 位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998 年 IETF 把这个字段改名为区分服务 DS（Differentiated Services）。只有在使用区分服务时，这个字段才起作用。在一般的情况下都不使用这个字段。

（4）**总长度**：总长度指首部和数据之和的长度，单位为字节。总长度字段为 16 位，因此数据报的最大长度位 2^16^ - 1 = 65535 字节。然而实际上传送这样长的数据报在现实中是极少遇到的。

我们知道，在 IP 层下面的每一种数据链路层协议都规定了一个数据帧中的**数据字段的最大长度**，这称为**最大传送单元** MTU（Maximum Transfer Unit）。当一个 IP 数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层所规定的 MTU 值。例如，最常用的以太网就规定其 MTU 值是 1500 字节。若所传送的数据报长度超过数据链路层的 MTU 值，就必须把过长的数据报进行分片处理。

虽然使用尽可能长的 IP 数据报会使传输效率得到提高（因为每一个 IP 数据报中首部长度占数据报总长度的比例就会小些），但数据报短也有好处。每一个 IP 数据报越短，路由器转发的速度就越快。为此，IP 协议规定，在互联网中所有的主机和路由器，必须能够接受长度不超过 576 字节的数据报。这是假定上层交下来的数据长度有 512 字节（合理的长度），加上最长的 IP 首部 60 字节，再加上 4 字节的富余量，就得到 576 字节。当主机需要发送长度超过 576 字节的数据报时，应当先了解一下，目的主机能否接受所要发送的数据报长度。否则，就要进行分片。

在进行分片时（见后面的 “片偏移” 字段），数据报首部中的 “总长度” 字段时指**分片后的每一个分片**的首部长度与该分片的数据长度的总和。

（5）**标识**（identification）：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段。但这个 “标识” 并不是序号，因为 IP 是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能被正确地重装成为原来的数据报。

（6）**标志**（flag）：占 3 位，但目前只有两位有意义。

- 标志字段中的最低位记为 **MF**（More Fragment）。MF = 1 即表示后面 “**还有分片**” 的数据报。MF = 0 表示这已是若干数据报片中的最后一个。
- 标志字段中间的一位记为 **DF**（Don't Fragment），意思是 “**不能分片**”。只有当 DF = 0 时才允许分片。

（7）**片偏移**：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以 8 个字节为偏移单位。也就是说，每个分片的长度一定是 8 字节（64 位）的整数倍。

（8）**生存时间**：占 8 位，生存时间字段常用的英文缩写是 TTL（Time To Live），表明这是数据在网络上的**寿命**。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在互联网中兜圈子（例如从路由器 R~1~ 转发到 R~2~，再转发到 R~3~，然后又转发到 R~1~），因而白白消耗网络资源。最初的设计是以秒作为 TTL 值得得。每经过一个路由器时，就把 TTL 减去数据报在路由器所消耗掉得一段时间。若数据报在路由器消耗得时间小于 1 秒，就把 TTL 值减 1。当 TTL 值减为零时，就丢弃这个数据报。

然而随着技术的进步，路由器处理数据报所需的时间不断在缩短，一般都远远小于 1 秒，后来就把 TTL 字段的功能改为 “**跳数限制**”（但**名称不变**）。路由器在每次转发数据报之前就把 TTL 值减 1。若 TTL 值减小到零，就丢弃这个数据报，不再转发。因此，现在 TTL 的单位不再是秒，而是**跳数**。TTL 的意义是指明数据报在互联网中至多可经过多少个路由器。显然，数据报能在互联网中经过的路由器的最大数值是 255。若把 TTL 的初始值设置为 1，就表示这个数据报只能在本局域网中传送。因为这个数据报一传送到局域网上的某个路由器，在被转发之前 TTL 值就减小为零，因而就会被这个路由器丢弃。

（9）**协议**：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个协议进行处理。

常用的一些协议和相应的协议字段值如下：

|   协议名   | ICMP | IGMP |  IP  | TCP  | EGP  | IGP  | UDP  | IPv6 | ESP  | OSPF |
| :--------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 协议字段值 |  1   |  2   |  4   |  6   |  8   |  9   |  17  |  41  |  50  |  89  |

（10）**首部检验和**：占 16 位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。



（11）**源地址**：占 32 位。

（12）**目的地址**：占 32 位。



##### 2.IP 数据报首部的可变部分

IP 数据报首部的可变部分就是一个选项字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。而有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。

增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。很多路由器都不考虑 IP 首部的选项字段，因此新的 IP 版本 IPv6 就把 IP 数据报的首部长度做成固定的。





#### IP 层转发分组的流程

路由器若针对主机进行转发记录的话，数量太大不现实，在实际应用中，都是针对网络进行转发。在路由表中，对每一条路由最重要的是以下两个信息：

（目的网络地址，下一跳地址）

虽然互联网所有的分组转发都是**基于目的主机所在的网络**，但在大多数情况下都允许这样的特例，即对特定的目的主机指明一个路由。这种路由叫做**特定主机路由**。采用特定主机路由可使网络管理人员更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。在对网络的连接或路由表进行排错时，指明到某一台主机的特殊路由就十分有用。

路由器还可采用**默认路由**（default rout）以减小路由表所占用的空间和搜索路由表所用的时间。这种转发方式在一个网络只有很少的对外连接时是很有用的。实际上，默认路由在主机发送 IP 数据报时往往更能显示出它的好处。主机在发送每一个 IP 数据报时都要查找自己的路由表。如果一台主机连接在一个小网络上，而这个网络只用要给路由器和互联网连接，那么在这种情况下使用默认路由是非常合适的。

需要强调的是，在 IP 数据报的首部中没有地方可以用来指明 "下一跳路由器的 IP 地址"。在 IP 数据报的首部写上的 IP 地址是源 IP 地址和目的 IP 地址，而没有中间经过的路由器的 IP 地址。我们是通过其他方式来寻址的。

当路由器收到一个待转发的数据报，在从路由表得出下一跳路由器的 IP 地址后，不是把这个地址填入 IP 数据报，而是送交数据链路层的网络接口软件。网络接口软件负责把下一跳路由器的 IP 地址转换成硬件地址（必须使用 ARP），并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。由此可见，当发送一连串的数据报时，上述的这种查找路由表、用 ARP 得到硬件地址、把硬件地址写入 MAC 帧的首部等过程，将不断地重复进行，造成了一定的开销。

根据以上所述，可归纳出**分组转发算法**如下：

（1）从数据报的首部提取目的主机的 IP 地址 D，得出目的网络地址为 N。

（2）若 N 就是与此路由器直接相连的某个网络地址，则进行**直接交付**，不需要再经过其他的路由器，直接把数据报交付目的主机（这里包括把目的主机地址 D 转换为具体的硬件地址，把数据报封装为 MAC 帧，再发送此帧）；否则就是间接交付，执行（3）

（3）若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（4）

（4）若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（5）

（5）若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行（6）

（6）报告转发分组出错

上面所讨论的是 IP 层怎样根据路由表的内容进行分组转发，而没有涉及到路由表一开始是如何建立的以及路由表中的内容应如何进行更新。





#### 划分子网

##### 1.从两级 IP 地址到三级 IP 地址

在今天看来，在 ARPANET 的早期，IP 地址的设计确实不够合理。

第一，**IP 地址空间的利用率有时很低**。

第二，给每一个物理网络分配一个网络号会**使路由表变得太大**而使网络性能变坏。

第三，**两级 IP 地址不够灵活**。

有时情况紧急，一个单位需要在新的地点马上开通一个新的网络。但是在申请到一个新的 IP 地址之前，新增加的网络是不可能连接到互联网上工作的。我们希望有一种方法，使一个单位能随时灵活地增加本单位地网络，而不必事先到互联网管理机构去申请新的网络号。原来的两级 IP 地址无法做到这一点。

为解决上述问题，从 1985 年起在 IP 地址中又增加了一个 ”**子网号字段**“，使两级 IP 地址变成为三级 IP 地址，它能够较好地解决上述问题，并且使用起来也很灵活。这种做法叫做**划分子网**（subnetting），或**子网寻址**或**子网路由选择**。划分子网已成为互联网的正式标准协议。

划分子网的基本思路如下：

（1）一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个**子网**（subnet）。划分子网纯属一个单位内部的事情。本单位以外的网络**看不见**这个网络是由多少个子网组成，因为这个单位**对外仍然表现为一个网络**。

（2）划分子网的方法是从网络的主机号借用若干位作为子网号（subnet-id），当然主机号也就相应减少了同样的位数。于是两级 IP 地址在**本单位内部**就变成**三级** IP 地址：网络号、子网号和主机号。也可以用以下记法来表示：

IP 地址 ::= {<网络号>，<子网号>，<主机号>}

（3）凡是从其他网络发送给本单位某台主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号找到连接在本单位网络上的路由器。但此路由器在收到 IP 数据报后，再按目的网络号和子网号找到目的的子网，把 IP 数据报交付目的主机。

总之，当没有划分子网时，IP 地址是两级结构。划分子网后 IP 地址变成了三级结构。划分子网只是把 IP 地址的主机号这部分进行再划分，而不改变 IP 地址原来的网络号。



##### 2.子网掩码

我们知道，从 IP 数据报的首部无法看出源主机或目的主机所连接的网络是否进行了子网的划分。这是因为 32 位的 IP 地址本身以及数据报的首部都没有包含任何有关任何有关子网划分的信息。因此必须另外想办法，这就是使用子网掩码（subnet mask）（见图 4-20）。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE11.jpg"/> </div><br>
图 4-20（a）是 IP 地址为 145.13.3.10 的主机本来的二级 IP 地址结构。图 4-20（b）是这个两级 IP 地址的子网掩码。图 4-20（c）是同一地址的三级 IP 地址结构，也就是说，现在从原来 16 位的主机号中拿出 8 位作为子网号，而主机号从 16 位减少到 8 位。请注意，现在子网号为 3 的网络的**网络地址**是 145.13.3.0（既不是原来两级 IP 地址的网络地址 145.13.0.0，也不是简单的子网号 3）。为了使路由器 R~1~ 能够很方便地从数据报中的目的 IP 地址中提取出所要找的子网的网络地址，路由器 R~1~ 就要使用三级 IP 地址的子网掩码。图 4-20（d）是三级 IP 地址的子网掩码，它也是 32 位，由一串 24 个 1 和跟随的一串 8 个 0 组成。子网掩码中的 1 对应于 IP 地址中原来二级地址中的 16 位网络号加上新增加的 8 位子网号，而子网掩码中的 0 对应于现在的 8 位主机号。虽然 RFC 文档中没有规定子网掩码中的一串 1 必须是连续的，但却极力推荐在子网掩码中选用**连续的** 1，以免出现可能发生的差错。

图 4-20（e）表示 R~1~ 把三级 IP 地址的子网掩码和收到的数据报的目的 IP 地址 145.13.3.10 逐位相 “与”（AND）（计算机进行这种逻辑 AND 运算是很容易的），得出了所要找的**子网的网络地址** 145.13.3.0。

使用子网掩码的好处就是：不管网络有没有划分子网，只要把子网掩码和 IP 地址进行逐位的 “与” 运算（AND），就立即得出网络地址来。这样在路由器处理到来的分组时就可采用同样的算法。

归纳一下上述的要点。从网络 145.13.0.0 **外面**看，这就是一个普通的 B 类网络，其子网掩码为 16 个连 1后面跟上 16 个连 0。但**进入**到这个网络后（即到了路由器 R1），就看到了还有许多网络（即划分了子网后的许多网络），其网络地址是 145.13.x.0（这里 x 可以表示不同的数值），而这些网络的子网掩码都是 24 个连 1 后面跟上 8 个连 0。总之，在这个 B 类网络的外面和里面，看到的网络是不一样的。

这里还要弄清一个问题，这就是：在不划分子网时，既然没有子网，为什么还要使用子网掩码？这就是为了更便于查找路由表。现在互联网的标准规定：所有的网络都必须使用子网掩码，同时在路由器的路由表中也必须有子网掩码这一栏。如果一个网络不划分子网，那么该网络的子网掩码就使用**默认子网掩码**。默认子网掩码中 1 的位置和 IP 地址中的网络号字段 net-id 正好相对应。因此，若用默认子网掩码和某个不划分子网的 IP 地址逐位相 “与”（AND）。就应当能够得出该 IP 地址的网络地址来。这样做可以不用查找该地址的类别位就能知道这是哪一类的 IP 地址。显然，

A 类地址的默认子网掩码是 255.0.0.0，或 0xFF000000。

B 类地址的默认子网掩码是 255.255.0.0，或 0xFFFF0000。

C 类地址的默认子网掩码是 255.255.255.0，或 0xFFFFFF00。

图 4-21 是这三类 IP 地址的网络地址和相应的默认子网掩码。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE12.jpg"/> </div><br>
**子网掩码是一个网络或一个子网的重要属性**。在 RFC950 成为互联网的正式标准后，路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。在路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。若一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码。

为何子网数要除去全 0 和全 1 这两种情况？

看看 RFC950 提到的原因：
假设我们有一个网络：192.168.0.0/24，我们现在需要两个子网，那么按照 RFC950，应该使用使用两位子网号，即 /26，得到两个可以使用的子网 192.168.0.64/26 和 192.168.0.128/26
对于主网络 192.168.0.0/24，网络地址是 192.168.0.0，广播地址是 192.168.0.255
对于子网 192.168.0.0/26（子网号全 0），网络地址是 192.168.0.0，广播地址是 192.168.0.63
对于子网 192.168.0.64/26，网络地址是 192.168.0.64，广播地址是 192.168.0.127
对于子网 192.168.0.128/26，网络地址是 192.168.0.128，广播地址是 192.168.0.191
对于子网 192.168.0.192/26（子网号全 1），网络地址是 192.168.0.192，广播地址是 192.168.0.255

可以看出，对于第一个子网，网络地址和主网络的网络地址是重叠的，对于最后一个子网，广播地址和主网络的广播地址也是重叠的。这样的重叠将导致极大的混乱。比如，一个发往 192.168.0.255 的广播是发给主网络的还是子网的？这就是为什么在当时不建议使用全 0 和全 1 子网。





#### 使用子网时分组的转发

在划分子网的情况下，分组转发的算法必须做相应的改动。

我们应当注意到，使用子网划分后，路由表必须包含以下三项内容：**目的网络地址**、**子网掩码**和**下一跳地址**。

在划分子网的情况下：路由器转发分组的算法如下：

（1）从收到的数据报的首部提取目的 IP 地址 D。

（2）先判断是否为直接交付。对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和 D 诸位相 “与”（AND 操作），看结果是否和相应的网络地址匹配。若匹配，则把分组直接进行交付（当然还需要把 D 转换成物理地址，把数据报封装成帧发送出去），转发任务结束。否则就是间接交付，执行（3）

（3）若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（4）

（4）若路由表中的每一行（目的网络地址，子网掩码，下一跳地址），用其中的子网掩码和 D 逐位相 “与”（AND 操作），若结果为 N。若 N 与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器；否则，执行（5）。

（5）若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行（6）

（6）报告转发分组出错







#### 无分类编址 CIDR（构造超网）

##### 1.网络前缀

划分子网在一定程度上缓解了互联网在发展中遇到的困难。然而在 1992 年互联网仍然面临三个必须尽早解决的问题，这就是：

（1）B 类地址在 1992 年已分配了近一半，眼看很快就将全部分配完毕！

（2）互联网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）。

（3）整个 IPv4 的地址空间最终将全部耗尽。在 2011 年 2 月 3 日，IANA 宣布 IPv4 地址已经耗尽了。

为了解决前两个问题，IETF 很快就研究出采用**无分类编址**的方法。对于第三个问题，IETF 专门成立了 IPv6 工作组负责研究解决新版本 IP 协议的问题。

其实早在 1987 年，RFC 1009 就指明了在一个划分子网的网络中可同时使用几个不同的子网掩码。

使用**变长子网掩码** VLSM（Variable Length Subnet Mask）可进一步提高 IP 地址资源的利用率。在 VLSM 的基础上又进一步研究出**无分类编址**方法，它的正式名字时**无分类域间路由选择** CIDR（Classless Inter-Domain Routing，CIDR 的读音是 “sider”）。

CIDR 最主要的特点有两个：

（1）CIDR **消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念**，因而能更加有效地分配 IPv4 的地址空间，并且在新的 IPv6 使用之前容许互联网的规模继续增长。CIDR 把 32 位的 IP 地址划分为前后两个部分。前面部分是 “**网络前缀**”（network-prefix）（或简称为 “**前缀**”），用来指明网络，后面部分用来指明主机。因此 CIDR 使 IP 地址从三级编址（使用子网掩码）又回到了两级编址，但这已是**无分类的两级编址**。其记法是：

IP 地址 ::= {<网络前缀>，<主机号>}

CIDR 还使用 “**斜线记法**”（slash notation），或称为 **CIDR** 记法，即在 IP 地址后面加上斜线 “/”，然后写上网络前缀所占的位数。

（2）CIDR 把**网络前缀都相同**的连续的 IP 地址组成一个 “**CIDR 地址块**”。我们只要知道 CIDR 地址块中的任何一个地址，就可以知道这个地址块的起始地址（即最小地址）和最大地址，以及地址块中的地址数。

我们可以用地址块中的最小地址和网络前缀的位数指明这个地址块。

为了更方便地进行路由选择，CIDR 使用 32 位的**地址掩码**（address mask）。地址掩码由一串 1 和一串 0 组成，而 1 的个数就是网络前缀的长度。虽然 CIDR 不使用子网了，但由于目前仍有一些网络还使用子网划分和子网掩码，因此 CIDR 使用的地址掩码也可继续称为**子网掩码**。**斜线记法中，斜线后面的数字就是地址掩码中 1 的个数**。

在之前的分类网络中，IP 地址的分配把 IP 地址的 32 位按每 8 位为一段分开。这使得前缀必须为 8，16 或者 24 位。因此，可分配的最小的地址块有 254 个地址，而这对大多数企业来说太少了。大一点的地址块包含 65534 个地址，而这对大公司来说都太多了。这导致不能充分使用 IP 地址和在路由上的不便，因为大量的需要单独路由的小型网络（C 类网络）因在地域上分得很开而很难进行聚合路由，于是给路由设备增加了很多负担。

无类别域间路由是基于**可变长子网掩码（VLSM）**来进行任意长度的前缀的分配的。在 RFC 950（1985）中有关于可变长子网掩码的说明。CIDR 包括：

- 指定任意长度的前缀的可变长子网掩码技术。遵从CIDR规则的地址有一个后缀说明前缀的位数，例如：192.168.0.0/16。这使得对日益缺乏的IPv4地址的使用更加有效。
- 将多个连续的前缀聚合成**超网**，以及，在互联网中，只要有可能，就显示为一个聚合的网络，因此在总体上可以减少路由表的表项数目。聚合使得互联网的路由表不用分为多级，并通过 VLSM 逆转 “划分子网” 的过程。
- 根据机构的实际需要和短期预期需要而不是分类网络中所限定的过大或过小的地址块来管理 IP 地址的分配的过程。



##### 2.最长前缀匹配

在使用 CIDR 时，由于采用了网络前缀这种记法，IP 地址由网络前缀和主机号这两个部分组成，因此在路由表中的项目也要有相应的改变。这时，每个项目由 “**网络前缀**” 和 “**下一跳地址**” 组成。但是在查找路由表时**可能会得到不止一个匹配结果**。这时**应当从匹配结果中选择具有最长网络前缀的路由**。这就叫做**最长前缀匹配**（longest-prefix matching），这是因为网络前缀越长，其地址块就越小，因而路由就越具体（more specific）。最长前缀匹配又称为**最长匹配**或**最佳匹配**。



##### 3.使用二叉线索查找路由表





#### 网际控制报文协议 ICMP

为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了**网际控制报文协议 ICMP**（Internet Control Message Protocol）。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 是互联网的标准协议。但 ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议。ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。ICMP 报文格式如图 4-27 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE14.png"/> </div><br>
##### ICMP 报文的种类

ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。

ICMP 报文的前 4 个字节是统一的格式，共有三个字段：类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。最后面是数据字段，其长度取决于 ICMP 的类型。表 4-8 给出了几种常用的 ICMP 报文类型。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE13.png"/> </div><br>
ICMP 标准在不断更新。已不再使用的 ICMP 报文有：“信息请求与回答报文”、“地址掩码请求与回答报文”、“路由器请求与通告报文” 以及 “源点抑制报文”。现在不再把这几种报文列入。

ICMP 报文的代码字段是为了进一步区分某种类型中的几种不同情况。检验和字段用来检验整个 ICMP 报文。我们应当还记得，IP 数据报首部的检验和并不检验 IP 数据报的内容，因此不能保证经过传输的 ICMP 报文不产生差错。

表 4-8 给出的 ICMP 差错报告报文共有四种，即：

（1）**终点不可达**：当路由器或主机不能交付数据报时就向源点发送终点不可达报文。

（2）**时间超过**：当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。

（3）**参数问题**：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。

（4）**改变路由（重定向）**：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。

下面对改变路由报文进行简短的解释。我们知道，在互联网的主机中也要有一个路由表。当主机要发送数据报时，首先是查找主机自己的路由表，看应当从哪一个接口把数据报发送出去。在互联网中主机的数量远大于路由器的数量，出于效率的考虑，这些主机不和连接在网络上的路由器定期交换路由信息。在主机刚开始工作时，一般都在路由表中设置一个默认路由器的 IP 地址。不管数据报要发送到哪个目的地址，都一律先把数据报传送给这个默认路由器，而这个默认路由器知道到每一个目的网络的最佳路由（通过和其他路由器交换路由信息）。如果默认路由器发现主机发往某个目的地址的数据报的最佳路由应当经过网络上的另一个路由器 R 时，就用改变路由报文把这情况告诉主机。于是，该主机就在其路由表中增加一个项目：到某某目的地址应经过路由器 R（而不是默认路由器）。

所有的 ICMP 差错报告报文中的数据字段都具有同样的格式（图 4-28）。把收到的需要进行差错报告的 IP 数据报的首部和数据字段的前 8 个字节提取出来，作为 ICMP 报文的数据字段。再加上相应的 ICMP 差错报告报文的前 8 个字节，就构成了 ICMP 差错报告报文。提取收到的数据报的数据字段前 8 个字节是为了得到运输层的端口号（对于 TCP 和 UDP）以及运输层报文的发送序号（对于 TCP）。这些信息对源点通知高层协议是有用的。整个 ICMP 报文作为 IP 数据报的数据字段发送给源点。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/网络层 - 图15.jpg"/> </div><br>
下面是不应发送 ICMP 差错报告报文的几种情况。

- 对 ICMP 差错报告报文，不再发送 ICMP 差错报告报文。

- 对第一个分片的数据报片的所有后续数据报片，都不发送 ICMP 差错报告报文。

- 对具有多播地址的数据报，都不发送 ICMP 差错报告报文。

- 对具有特殊地址（如 127.0.0.0 或 0.0.0.0）的数据报，不发送 ICMP 差错报告报文。

  

常用的 ICMP 询问报文有两种，即：

（1）**回送请求和回答**：ICMP 回送请求报文是由主句或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态。

（2）**时间戳请求和回答**：ICMP 时间戳请求报文是请某台主机或路由器回答当前的日期和时间。在 ICMP 时间戳回答报文中有一个 32 位的字段，其中写入的整数代表从 1900 年 1 月 1 日起到当前时刻一共有多少秒。时间戳请求与回答可用于时钟同步和时间测量。





##### ICMP 的应用举例

ICMP 的一个重要应用就是分组网间探测 **PING**（Packet InterNet Groper），用来测试两台主机之间的连通性。PING 使用了 ICMP 回送请求与回送回答报文。PING 是应用层直接使用网络层 ICMP 的一个例子。它没有通过运输层的 TCP 或 UDP。





#### 互联网的路由选择协议

本节将讨论几种常见的路由选择协议，也就是要讨论路由表中的路由是怎样得出的。

##### 有关路由协议的几个基本概念

1.理想的路由算法

路由选择协议的核心就是路由算法，即需要何种算法来获得路由表中的各项目。一个理想的路由算法应具有如下的一些特点：

（1）**算法必须是正确的和完整的**。这里，正确意味着：沿着各路由表所指引的路由，分组一定能够最终达到目的网络和目的主机。

（2）**算法在计算上应简单**。路由选择的计算不应使网络通信量增加太多的额外开销。

（3）**算法应能适应通信量和网络拓扑的变化**，这就是说，要有**自适应性**。当网络中的通信量发生变化时，算法能自适应地改变路由以均衡各链路的负载。当某个或某些节点、链路发生故障不能工作，或者修理好了再投入运行时，算法也能及时地改变路由。有时称这种自适应性为 “**稳健性**”（robustness）。

（4）**算法应具有稳定性**。在网络通信量和网络拓扑相对稳定地情况下，路由算法应收敛于一个可以接受的解，而不应使得出的路由不停地变化。

（5）**算法应是公平的**。路由选择算法应对所有用户（除对少数优先级高的用户）都是平等的。例如，若仅仅使某一对用户的端到端时延为最小，但却不考虑其他的广大用户，这就明显地不符合公平性的要求。

（6）**算法应是最佳的**。路由选择算法应当能够找出最好的路由，使得分组平均时延最小而网络的吞吐量最大。虽然我们希望得到 “最佳” 的算法，但这并不总是最重要的。对于某些网络，网络的可靠性有时要比最小的分组平均时延或最大吞吐量更加重要。因此，**所谓 “最佳” 只能是相对于某一种特定要求下得出的较为合理的选择而已**。

一个实际的路由选择算法，应尽可能接近于理想的算法。再不同的应用条件下，对以上提出的六个方面也可有不同的侧重。

应当指出，路由选择是个非常复杂的问题，因为它是网络中的所有节点共同协调工作的结果。其次，路由选择的环境往往是不断变化的，而这种变化有时无法事先知道，例如，网络中出了某些故障。此外，当网络发生拥塞时，就特别需要能缓解这种拥塞的路由选择策略，但恰好再这种条件下，很难从网络中的各节点获得所需的路由选择信息。

倘若从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，则只有两大类，即**静态路由选择策略**与**动态路由选择策略**。静态路由选择也叫做**非自适应路由选择**，其特点是简单和开销较小，但不能适应网络状态地变化。对于很简单的小网络，完全可以采用静态路由选择，用人工配置每一条路由。动态路由选择也叫做**自适应路由选择**，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。因此，动态路由选择适用于较复杂的大网络。



2.分层次的路由选择协议

互联网采用的路由选择协议主要是自适应的（即动态的）、分布式路由选择协议。由于以下两个原因，互联网采用分层次的路由选择协议：

（1）互联网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会使互联网的通信链路饱和。

（2）许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议（这属于本部门内部的事情），但同时还希望连接到互联网上。

为此，可以把整个互联网划分未许多较小的**自治系统**（autonomous system），一般都记为 AS。自治系统 AS 是在单一技术管理下的一组路由器，而这些路由器使用一种自治系统内部的路由选择协议和共同的度量。一个 AS 对其他 AS 表现出的是**一个单一的和一致的路由选择策略**。

在目前的互联网中，一个大的 ISP 就是一个自治系统。这样，互联网就把路由选择协议划分为两大类，即：

（1）**内部网关协议** IGP（Interior Gateway Protocol）：即在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统使用什么路由选择协议无关。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。

（2）**外部网关协议** EGP（External Gateway Protocol）：若源主机和目的主机处在不同的自治系统中（这两个自治系统可能使用不同的内部网关协议），当数据报传送到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。目前使用最多的外部网关协议是 BGP 的版本 4（BGP-4）。

自治系统之间的路由选择也叫做**域间路由选择**（interdomain routing），而在自治系统内部的路由选择叫做**域内路由选择**（intradomain ）。

对于比较大的自治系统，还可将所有的网络再进行一次划分。例如，可以构筑一个链路速率较高的主干网和许多速率较低的区域网。每个区域网通过路由器连接到主干网。当在一个区域内找不到目的站时，就通过路由器经过主干网到达另一个区域网，或者通过外部路由器到别的自治系统中去找。下面对这两类协议分别进行介绍。





##### 内部网关协议 RIP

1.工作原理

RIP（Routing Information Protocol）是内部网关协议 IGP 中最先得到广泛使用的协议，它的中文名称叫做路由信息协议，但很少被使用。RIP 是一种分布式的**基于距离向量的路由选择协议**，是互联网的标准协议，其最大优点就是简单。

RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录（因此，这是**一组距离**，即 “**距离向量**”）。RIP 协议将 “**距离**” 定义如下：

从一路由器到直接连接的网络的距离定义为 1。从一路由器到非直接连接的网络的距离定义为所经过的路由器数加 1。“加 1” 是因为到达目的网络后就进行直接交付，而到直接连接的网络的距离已经定义为 1。

RIP 协议的 “距离” 也称为 “**跳数**”（hop count），因为每经过一个路由器，跳数就加 1。RIP 认为好的路由就是它通过的路由器的数目少，即 “距离短”。RIP 允许一条路径最多只能包含 15 个路由器。因此 “距离” 等于 16 时即相当于不可达。可见 **RIP 只适用于小型互联网**。

需要注意的是，到直接连接的网络的距离也可定义为 0（采用这种定义的理由是：路由器在和直接连接到该网络上的主机通信时，不需要经过路由器的距离就应当为 0）。两种不同的定义对实现 RIP 协议并无影响，因为最重要的是要找出最短距离，将所有的距离都加 1 或都减 1，对选择最佳路由其实是一样的。

RIP 不能在两个网络之间同时使用多条路由。RIP 选择一条具有最少路由器的路由（即最短路由），哪怕还存在另一条高速（低时延）但路由器较多的路由。

本节讨论的 RIP 协议和下一节要讨论的 OSPF 协议，都是分布式路由选择协议。它们的共同特点就是每一个路由器都要不断地和其他一些路由器交换路由信息。我们一定要弄清以下三个要点，**即和哪些路由器交换信息**？**交换什么信息**？**在什么时候交换信息**？

RIP 协议的特点是：

（1）**仅和相邻路由器交换信息**。如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的。RIP 协议规定，不相邻的路由器不交换信息。

（2）路由器交换的信息是**当前本路由器所知道的全部信息**，**即自己现在的路由表**。也就是说，交换的信息是：“我到本自治系统中所有网络的（最短）距离，以及到每个网络应经过的下一跳路由器”。

（3）**按固定的时间间隔**交换路由信息，例如，每隔 30 秒。然后路由器根据收到的路由信息更新路由表。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。

这里要强调一点：路由器**在刚刚开始工作时**，它的路由表是空的。然后路由器就得出到直接相连的几个网络的距离（这些距离定义为 1）。接着，每一个路由器也只和**数目非常有限的**相邻路由器交换并更新路由信息。但经过若干次的更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。

路由表中最主要的信息就是：到某个网络的距离（即最短距离），以及应经过的下一跳地址。路由表更新的原则是找出到每个目的网络的**最短距离**。这种更新算法又称为**距离向量算法**。下面就是 RIP 协议使用的距离向量算法。



2.距离向量算法

对**每一个相邻路由器**发送过来的 RIP 报文，进行以下步骤：

（1）对地址为 X 的相邻路由器发来的 RIP 报文，先修改此报文中的所有项目：把 “下一跳” 字段中的地址都改为 X，并把所有的 “距离” 字段的值加 1。每一个项目都有三个关键数据，即：到目的网络 N，距离是 d，下一跳路由器是 X。

（2）对修改后的 RIP 报文中的每一个项目，进行以下步骤：

若原来的路由表中没有目的网络 N，则把该项目添加到路由表中。

否则（即在路由表中有目的网络 N，这时就再查看下一跳路由器地址）

​	若下一跳路由器地址是 X，则把收到的项目替换原路由表中的项目。

​	否则（即这个项目是：到目的网络 N，但下一跳路由器不是 X）

​		若收到的项目中的距离 d 小于路由表中的距离，则进行更新，

​		否则什么也不做。



RIP 协议让一个自治系统中的所有路由器都和自己的相邻路由器定期交换路由信息，并不断更新其路由表，使得从**每一个路由器到每一个目的网络的路由都是最短的**（即跳数最少）。这里还应注意：虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的。





3.RIP 协议的报文格式

现在较新的 RIP 版本是 1998 年 11 月公布的 RIP2（已成为互联网标准），新版本协议本身并无多大变化，但性能上有些改进。RIP2 可以支持变长子网掩码和无非类域间路由选择 CIDR。此外，RIP2 还提供简单的鉴别过程支持多播。

图 4-32 是 RIP2 的报文格式，它和 RIP1 的首部相同，但后面的路由部分不一样。从图 4-32 还可看出，RIP 协议使用运输层的用户数据报 UDP 进行传送（使用 UDP 的端口 520）.





RIP 报文由首部和路由部分组成。

RIP 的首部占 4 个字节，其中的命令字段指出报文的意义。例如，1 表示请求路由信息，2 表示对请求路由信息的响应或未被请求而发出的路由更新报文。首部后面的 “必为 0” 是为了 4 字节字的对齐。

RIP2 报文中的路由部分由若干个路由信息组成。每个路由信息需要用 20 个字节。**地址族标识符**（又称为**地址类别**）字段用来标志所使用的地址协议。如采用 IP 地址就令这个字段的值为 2（原来考虑 RIP 也可用于其他非 TCP/IP 协议的情况）。**路由标记**填入**自治系统号** ASN（Autonomous System Number），这是考虑使 RIP 有可能收到本自治系统以外的路由选择信息。再后面指出某个**网络地址**、该网络的**子网掩码**、**下一跳路由器地址**以及**到此网络的距离**。一个 RIP 报文最多可包括 25 个路由，因而 RIP 报文的最大长度是 4 + 20 * 25 = 504 字节。如超过，必须再用一个 RIP 报文来传送。

RIP2 还具有简单的鉴别功能。若使用鉴别功能，即将原来写入第一个路由信息（20 字节）的位置用作鉴别。这时应将地址标识符置为全 1（即 0xFFFF），而路由标记写入鉴别类型，剩下的 16 字节为鉴别数据。在鉴别数据之后才写入路由信息，但这时最多只能再放入 24 个路由信息。

RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。RIP 协议的这一特点叫做：**好消息传播得块，而坏消息传播得慢**。网络出故障得传播时间往往需要较长得时间（例如数分钟）。这是 RIP 得一个主要缺点。

但如果一个路由器发现了更短的路由，那么这种更新信息就传播得很快。

为了使坏消息传播得更快些，可以次啊去多种措施。例如，让路由器记录收到某特定路由信息得接口，而不让同一路由信息再通过此接口向反方向传送。

总之，RIP 协议最大的优点就是实现简单，开销较小。但 RIP 协议的缺点也较多。首先，RIP 限制了网络的规模，它能使用的最大距离为 15（16表示不可达）。其次，路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。最后，“坏消息传播得慢”，使更新过程的收敛时间过长。因此，对于规模较大的网络就应当使用下一节所述的 OSPF 协议。然而目前再规模较小的网络中，使用 RIP 协议的仍占多数。





##### 内部网关协议 OSPF

1.OSPF 协议的基本特点

这个协议的名字是**开放最短路径优先** OSPF（Open Shortest Path First）。它是为克服 RIP 的缺点在 1989 年开发出来的。OSPF 的原理很简单，但实现起来却较复杂。“**开放**” 表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。“**最短路径优先**” **是因为使用了 Dijkstra 提出的最短路径算法 SPF**。**OSPF 的第二个版本 OSPF2 已成为互联网**标准协议。

OSPF 最主要的特征就是使用分布式的**链路状态协议**（link state protocol），而不是像 RIP 那样的距离向量协议。和 RIP 协议相比，OSPF 的三个要点和 RIP 的都不一样。

（1）向本自治系统中**所有路由器**发送信息。这里使用的方法是**洪泛法**（flooding），这就是路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻路由器又再将此信息发往其所有的相邻路由器（但不再发送给刚刚发来信息的那个路由器）。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。我们应注意，RIP 协议仅仅是向自己相邻的几个路由器发送信息。

（2）发送的信息就是与本路由器**相邻的所有路由器的链路状态**，但这只是路由器所知道的**部分信息**。所谓 “链路状态” 就是说明本路由器都和哪些路由器相邻，以及该链路的 “**度量**”（metric）。OSPF 将这个 “度量” 用来表示费用、距离、时延、带宽，等等。这些都由网络管理人员决定，因此比较灵活。有时为了方便就称这个度量为 “**代价**”。我们应注意，对于 RIP 协议，发送的信息是：“到所有网络的距离和下一跳路由器”。

（3）只有当链路状态**发生变化时**，路由器才向所有路由器用洪泛法发送此信息。而不像 RIP 那样，不管网络拓扑有无发生变化，路由器之间都要定期交换路由表的信息。

从上述的三个方面可以看出，OSPF 和 RIP 的工作原理相差较大。

由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个**链路状态数据库**（link-state database），这个数据库实际上就是**全网的拓扑结构图**。这个拓扑结构图在全网范围内是**一致的**（这称为**链路状态数据库的同步**）。因此，每一个路由器都知道全网共有多少个路由器，以及哪些路由器是相连的，其代价是多少，等等。每一个路由器使用链路状态数据库中的数据，构造出自己的路由表（例如，使用 SPF 算法）。我们注意到，RIP 协议的每一个路由器虽然知道所有的网络的距离以及下一跳路由器，但却**不知道全网的拓扑结构**（只有到了下一跳路由器，才能知道再下一跳应当怎样走）。

OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。OSPF 的**更新过程收敛得快**是其重要优点。

为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫做区域（area）。图 4-34 就表示一个自治系统划分为四个区域。每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。当然，一个区域也不能太大，在一个区域内的路由器最好不要超过 200 个。





划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。为了使每一个区域能够和本区域以外的区域进行通信，OSPF 使用**层次结构的区域划分**。在上层的区域叫做**主干区域**（backbone area）。主干区域的标识符规定为 0.0.0.0。主干区域的作用是用来连通其他在下层的区域。从其他区域来的信息都由**区域边界路由器**（area border router）进行概括。在图 4-34 中，路由器 R~3~，R~4~ 和 R~7~ 都是区域边界路由器，而显然，每一个区域至少应当有一个区域边界路由器。在主干区域内的路由器叫做**主干路由器**（backbone router），如 R~3~，R~4~，R~5~，R~6~ 和 R~7~。一个主干路由器可以同时是区域边界路由器，如 R~3~，R~4~ 和 R~7~。在主干区域内还要有一个路由器专门和本自治系统外的其他自治系统交换路由信息。这样的路由器叫做**自治系统边界路由器**（如图中的 R~6~）。

采用分层次划分区域的方法虽然使交换信息的种类增多了，同时也使 OSPF 协议更加复杂了。但这样却能使每一个区域内部交换路由信息的通信量大大减小，因而使 OSPF 协议能够用于规模很大的自治系统中。这里，我们再一次地看到划分层次在网络设计中的重要性。

OSPF 不用 UDP 而是直接用 IP 数据报传送（其 IP 数据报首部的协议字段值为 89）。OSPF 构成的数据报很短。这样做可减少路由信息的通信量。数据报很短的另一好处是可以不必将很长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。

OSPF 分组使用 24 字节的固定长度首部（见图 4-35），分组的数据部分可以是五种类型分组中的一种。下面简单介绍 OSPF 首部各字段的意义。

（1）**版本**：当前的版本号是 2。

（2）**类型**：可以是五种类型分组中的一种。

（3）**分组长度**：包括 OSPF 首部在内的分组长度，以字节为单位。

（4）**路由器标识符**：标志发送该分组的路由器的接口的 IP 地址。

（5）**区域标识符**：分组属于的区域的标识符。

（6）**检验和**：用来检测分组中的差错。

（7）**鉴别类型**：目前只有两种，0（不用）和 1（口令）。

（8）**鉴别**：鉴别类型为 0 时就填入 0，鉴别类型为 1 则填入 8 个字符的口令。





除了以上的几个基本特点外，OSPF 还具有下列的一些特点：

（1）OSPF 允许管理员给每条路由指派不同的代价。例如，高带宽的卫星链路对于非实时的业务可设置为较低的代价，但对于时延敏感的业务就可设置为非常高的代价。因此，OSPF **对于不同类型的业务可计算出不同的路由**。链路的代价可以是 1 至 65535 中的任何一个无量纲的数，因此十分灵活。商用的网络在使用 OSPF 时，通常根据链路带宽来计算链路的代价。这种灵活性是 RIP 所没有的。

（2）如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫做多路径间的**负载平衡**（load balancing）。在代价相同的多条路径上分配通信量是通信量工程中的简单形式。RIP 只能找出到某个网络的一条路径。

（3）所有在 OSPF 路由器之间交换的分组（例如，链路状态更新分组）都具有**鉴别**的功能，因而保证了仅在可信赖的路由器之间交换链路状态信息。

（4）OSPF 支持可变长度的子网划分和无分类的编址 CIDR。

（5）由于网络中链路状态可能经常发生变化，因此 OSPF 让每一个链路状态都带上一个 32 位的**序号**，序号越大状态就越新。OSPF 规定，链路状态序号增长的速率不得超过每 5 秒钟 1 次。这样，全部序号空间在 600 年内不会产生重复号。

































