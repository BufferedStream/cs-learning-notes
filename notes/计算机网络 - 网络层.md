## 网络层

#### 概述

**网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务**。这里的数据报（datagram）就是 “分组”。

网络在发送分组时不需要先建立连接。每一个分组独立发送，与其前后的分组无关（不进行编号）。**网络层不提供服务质量的承诺**。也就是说，所传送的分组可能出错、丢失、重复和失序（即不按序到达终点），当然也不保证分组交付的时限。由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器比较简单，且价格低廉（与电信网的交换机相比较）。如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制等）。



#### 网际协议 IP

与 IP 协议配套使用的还有三个协议：

- **地址解析协议 ARP**（Address Resolution Protocol）
- **网际控制报文协议 ICMP**（Internet Control Message Protocol）
- **网际组管理协议 IGMP**（Internet Group Management Protocol）

图 4-2 画出了这三个协议和网际协议 IP 的关系。在这一层中，ARP 画在最下面，因为 IP 经常要使用这个协议。ICMP 和 IGMP 画在这一层的上部，因为它们要使用 IP 协议。由于网际协议 IP 是用来使互接起来的许多计算机网络能够进行通信的，因此 TCP/IP 体系中的网络层常常被称为**网际层**（internet layer），或 IP 层。使用 “网际层” 这个名称的好处是强调这是由很多网络构成的互连网络。 

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE1.jpg"/> </div><br>
#### 分类的 IP 地址

##### 1.IP 地址及其表示方法

整个的互联网就是一个**单一的、抽象的网络**。IP 地址就是给互联网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的 32 位的标识符。IP 地址的结构使我们可以在互联网上很方便地进行寻址。

IP 地址的编址方法共经过了三个历史阶段。

（1）**分类的 IP 地址**。这是最基本的编址方法。

（2）**子网的划分**。这是对最基本的编址方法的改进。

（3）**构成超网**。这是比较新的无分类编址方法。

所谓 “分类的 IP 地址” 就是将 IP 地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成，其中第一个字段是**网络号**（net-id），它标志主机（或路由器）所连接到的网络。一个网络号在整个互联网范围内必须是唯一的。第二个字段是主机号（host-id），它标志该主机（或路由器）。一台主机号在它前面的网络号所指明的网络范围内必须是唯一的。由此可见，一个 IP 地址**在整个互联网范围内是唯一的**。

这种两级的 IP 地址可以记为：

IP 地址 ::={<网络号>,<主机号>}



图 4-5 给出了各种 IP 地址的网络号字段和主机号字段，这里 A 类、 B 类和 C 类地址都是**单播地址**（一对一通信），是最常用的。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE2.png"/> </div><br>
从图 4-5 可以看出：

- A 类、 B 类和 C 类地址的网络号字段（在途中这个字段是灰色的）分别为 1 个、 2 个和 3 个字节长，而在网络号字段的最前面有 1~3 位的**类别位**，其数指分别规定为 0， 10 和 110。
- A 类、 B 类和 C 类地址的主机号字段分别为 3 个、 2 个和 1 个字节长。
- D 类地址（前 4 位是 1110）用于**多播**（一对多通信）。
- E 类地址（前 4 位是 1111）保留为以后用。	

这里要指出，由于近年来已经广泛使用无分类 IP 地址进行路由选择，A 类、 B 类和 C 类地址的区分已成为历史。为了理解概念的演进，我们这里还要从分类的 IP 地址讲起。

从 IP 地址的结构来看，**IP** 地址并不仅仅指明一台主机，而是还指明了主机所连接到的网络。

把 IP 地址划分为 A 类、 B 类和 C 类三个类别，当初是这样考虑的。各种网络的差异很大，有的网络拥有很多主机，而有的网络上的主机则很少。把 IP 地址划分为 A 类、 B 类和 C 类是为了更好地满足不同用户的要求。当某个单位申请到一个 IP 地址时，实际上是获得了具有同样网络号的一块地址。其中具体的各台主机号则由该单位自行分配，只要做到在该单位管辖的范围内无重复的主机号即可。

对主机或路由器来说，IP 地址都是 32 位的二进制代码。为了提高可读性，我们常常把 32 位的 IP 地址中的每 8 位插入一个空格（**但在机器中并没有这样的空格**）。为了便于书写，可用其等效的十进制数字表示，并且在这些数字之间加上一个点。这就叫做**点分十进制记法**（dotted decimal notation）。图 4-6 是一个 B 类 IP 地址的表示方法。显然，128.11.3.31 比 10000000 00001011 00000011 00011111 书写起来要方便得多。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE3.jpg"/> </div><br>
##### 2.常用的三种类别的 IP 地址

A 类地址的网络号字段占 1 个字节，只有 7 位可供使用（该字段的第一位已固定为 0），但可指派的网络号是 126 个（即 2^32^ - 2）。减 2 的原因是：第一，IP 地址中的全 0 表示 “**这个**（this）”。网络号字段为全 0 的 IP 地址是个保留地址，意思是 “本网络”；第二，网络号为 127（即 01111111）保留作为本地软件**环回测试**（loopback test）本主机的进程之间的通信之用。若主机发送一个目的地址为环回地址（例如 127.0.0.1）的 IP 数据报，则本主机中的协议软件就处理数据报中的数据，而不会把数据报发送到任何网络。目的地址为环回地址的 IP 数据报永远不会出现在任何网络上，因为网络号为 127 的地址根本不是一个网络地址。

关于全 1 和全 0 还可以再举两个例子。例如，B 类地址 128.7.255.255 表示 “在网络 128.7.0.0 上的所有主机”。而 A 类地址 0.0.0.35 则表示 ”在这个网络上主机号为 35 的主机“。

A 类地址的主机号占 3 个字节，因此每一个 A 类网络中的最大主机数是 2^24^ - 2，即 16777214。这里减 2 的原因是：全 0 的主机号字段表示该 IP 地址是 “本主机” 所连接到的**单个网络地址**（例如，一主机的 IP 地址为 5.6.7.8，则该主机所在的网络地址就是 5.0.0.0），而全 1 表示 “**所有的**（all）”，因此全 1 的主机号字段表示该网络上的所有主机。

如果主机号全 0，IP 地址代表仅网络号指向的那个网段，该 IP 代表一个网段；如果主机号全 1，IP 地址代表网络号指向的全部主机，IP 地址代表广播地址 ；其他就是普通的 IP 地址，指向网域中的一个主机了。

在 A 类、B 类、C 类 IP 地址中，如果主机号是全 1，那么这个地址为直接广播地址，它是用来使路由器将一个分组以广播形式发送给特定网络上的所有主机。32 位全为 1 的 **IP地址 ** “255.255.255.255” 为**受限广播地址**（"limited broadcast" destination address），用来将一个分组以广播方式发送给本网络中的所有主机，路由器则阻挡该分组通过，将其广播功能限制在本网内部。

IP 地址空间共有 2^32^（即 4294967296）个地址。整个 A 类地址空间共有 2^31 个地址，占整个 IP 地址空间的 50%。

B 类地址的网络号字段有 2 个字节，但前面两位（1 0）已经固定了，只剩下 14 位可以进行分配。因为网络号字段后面的 14 位无论怎样取值也不可能出现使整个 2 字节的网络号字段成为全 0 或全 1，因此这里不存在网络总数减 2 的问题。但实际上 B 类网络地址 128.0.0.0 是不指派的，而可以指派的 B 类最小网络地址是 128.1.0.0[COME06]。因此 B 类地址可指派的网络数为 2^14^ - 1，即 16383。B 类地址的每一个网络上的最大主机数是 2^16^ - 2，即 65534。这里需要减 2 是因为要扣除全 0 和全 1 的主机号。整个 B 类地址空间共约有 2^30^ 个地址，占整个 IP 地址空间的 25%。

C 类地址有 3 个字节的网络号字段，最前面的 3 位是（1 1 0），还有 21 位可以进行分配。C 类网络地址 192.0.0.0 也是不指派的，可以指派的 C 类最小网络是 192.0.1.0[COME06]，因此 C 类地址可指派的网络总数是 2^21^ - 1，即 2097151。每一个 C 类地址的最大主机是 2^8^ - 2，即 254。整个 C 类地址空间共约有 2^29^ 个地址，占整个 IP 地址的 12.5%。

这样，我们就可得出表 4-2 所示的 IP 地址的指派范围。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE4.jpg"/> </div><br>
IP 地址具有以下一些重要特点。

（1）每一个 IP 地址都由网络号和主机号两部分组成。从这个意义上说，IP 地址是一种**分等级的地址结构**。分两个等级的好处是：第一，IP 地址管理机构在分配 IP 地址时**只分配网络号**（第一级），而剩下的主机号（第二级）则由得到该网络号的单位来自行分配。这样就方便了 IP 地址的管理；第二，路由器**仅根据目的主机所连接的网络号来转发分组**（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度较少，从而**减小了路由表所占的存储空间以及查找路由表的时间**。

（2）实际上 IP 地址是标志一台主机（或路由器）和一条链路的**接口**。当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号必须是不同的。这种主机称为**多归属主机**（multihomed host）。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的 IP 地址。这好比一个建筑正好处在北京路和上海路的交叉口上，那么这个建筑就可以拥有两个门牌号码。例如，北京路 4 号和上海路 37 号。

（3）按照互联网的观点，一个网络是指具有相同网络号 net-id 的主机的集合，因此，**用转发器或网桥连接起来的若干个局域网仍为一个网络**，因为这些局域网都具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连。

（4）在 IP 地址中，所有分配到网络号的网络（不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网）都是**平等**的。所谓平等，是指互联网同等对待每一个 IP 地址。



#### IP 地址与硬件地址

从层次的角度看，**物理地址是数据链路层和物理层使用的地址**，而 **IP 地址是网络层和以上各层使用的地址，是一种逻辑地址**（称 IP 地址为逻辑地址是因为 IP 地址是用软件实现的）。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE5.jpg"/> </div><br>
在发送数据时，数据从高层下到低层，然后才到通信链路上传输。使用 IP 地址的 IP 数据报一旦交给了数据链路层，就被封装成 MAC 帧了。MAC 帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在 MAC 帧的首部中。

连接在通信链路上的设备（主机或路由器）在收到 MAC 帧时，根据 MAC 帧首部中的硬件地址决定收下或丢弃。只有在剥去 MAC 帧的首部和尾部后把 MAC 层的数据上交给网络层后，网络层才能在 IP 数据报的首部中找到源 IP 地址和目的 IP 地址。

总之，IP 地址放在 IP 数据报的首部，而硬件地址则放在 MAC 帧的首部。在网络层和网络层以上使用的是 IP 地址，而数据链路层及以下使用的是硬件地址。在图 4-8 中，当 IP 数据报放入数据链路层的 MAC 帧中以后，整个的 IP 数据报就成为 MAC 帧的数据，因而在数据链路层看不见数据报的 IP 地址。

图 4-9(a)画的是三个局域网用两个路由器 R~1~ 和 R~2~ 互连的情况。现在主机 H1 要和主机 H2 通信。这两台主机的 IP 地址分别是 IP~1~ 和 IP~2~，而它们的硬件地址分别为 HA~1~ 和 HA~2~（HA 表示 Hardware Address）。通信的路径是：H~1~——经过 R~1~ 转发——再经过 R~2~ 转发——H~2~。路由器 R~1~ 因同时连接到两个局域网上，因此说它有两个硬件地址，即  HA~3~ 和 HA~4~。同理，路由器 R~2~ 也有两个硬件地址 HA~5~ 和 HA~6~。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE6.jpg"/> </div><br>
图 4-9(b)特别强调了 IP 地址与硬件地址的区别。表 4-4 归纳了这种区别。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE7.jpg"/> </div><br>
这里要强调指出以下几点：

（1）**在 IP 层抽象的互联网上只能看到 IP 数据报**。虽然 IP 数据报要经过路由器 R~1~ 和 R~2~ 的两次转发，但在它的首部中的源地址和目的地址**始终**分别是 IP~1~ 和 IP~2~。图中的数据报上写的 “从 IP~1~ 到 IP~2~” 就表示前者是源地址而后者是目的地址。数据报中间经过的两个路由器的 IP 地址并不出现在 IP 数据报的首部中。

（2）虽然在 IP 数据报首部有源站 IP 地址，但**路由器只根据目的站的 IP 地址的网络号进行路由选择**。

（3）**在局域网的链路层，只能看见 MAC 帧**。IP 数据报被封装在 MAC 帧中。MAC 帧在不同网络上传送时，其 MAC 帧首部中的源地址和目的地址要发生变化，见图 4-9(b)。开始在 H~1~ 和 R~1~ 间传送时，MAC 帧首部中写的是从硬件地址 HA~1~ 发送到硬件地址 HA~3~，路由器 R~1~ 收到此 MAC 帧后，在数据链路层，要丢弃原来的 MAC 帧的首部和尾部。在转发时，在数据链路层，要重新加上 MAC 帧的首部和尾部。这时首部中的源地址和目的地址分别便成为 HA~4~ 和 HA~5~。路由器 R~2~ 收到此帧后，再次更换 MAC 帧的首部和尾部，首部中的源地址和目的地址分别变为 HA~6~ 和 HA~2~。MAC 帧的首部的这种变化，在上面的 IP 层上是看不见的。

（4）尽管互连在一起的网络的硬件地址体系各不相同，但 **IP 层抽象的互联网却屏蔽了下层这些很复杂的细节。只要我们在网络层上讨论问题，就能够使用统一的、抽象的 IP 地址研究主机和主机或路由器之间的通信**。上述的这种 “屏蔽” 概念是一个很有用、很普遍的基本概念。例如，计算机中广泛使用的图形用户界面使得用户只需简单地点击几下鼠标就能让计算机完成很多任务。实际上计算机要完成这些任务必须执行很多条指令。但这些复杂的过程全都被设计良好的图形用户界面屏蔽掉了，使用户看不见这些复杂过程。

以上这些概念是计算机网络的精髓所在，对这些重要概念务必仔细思考和掌握。





#### 地址解析协议 ARP

在实际应用中，我们经常会遇到这样的问题：已经知道了一个机器（主机或路由器）的 IP 地址，需要找出其相应的硬件地址。地址解析协议 ARP 就是用来解决这样的问题的。图 4-10 说明了 ARP 协议的作用。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE8.jpg"/> </div><br>
由于是 IP 协议使用了 ARP 协议，因此通常就把 ARP 协议划归网络层。但 ARP 协议的用途是为了从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。

我们知道，网络层使用的是 IP 地址，但在实际网络的链路上传送数据帧时，最终还是必须使用该网络的硬件地址。但 IP 地址和下面的网络的硬件地址之间由于格式不同而不存在简单的映射关系（例如，IP 地址有 32 位，而局域网的硬件地址是 48 位）。此外，在一个网络上可能经常会有新的主机加入进来，或撤走一些主机。更换网络适配器也会使主机的硬件地址改变。**地址解析协议** ARP 解决这个问题的方法是在主机 ARP 高速缓存中存放一个从 IP 地址到硬件地址的映射表，并且这个映射表还经常动态更新（新增或超时删除）。

每一台主机都设有一个 ARP **高速缓存**（**ARP cache**），里面有**本局域网上**的各主机和路由器的 IP 地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。那么主机怎样知道这些地址呢？我们可以通过下面的例子来说明。

当主机 A 要向**本局域网**上的某台主机 B 发送 IP 数据报时，就现在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就在 ARP 高速缓存中查出其对应的硬件地址，再把这个硬件地址写入 MAC 帧，然后通过局域网把该 MAC 帧发往此硬件地址。

也有可能查不到主机 B 的 IP 地址的项目。这可能是主机 B 才入网，也可能是主机 A 刚刚加电，其高速缓存还是空的。在这种情况下，主机 A 就自动运行 ARP，然后按以下步骤找出主机 B 的硬件地址。

（1）ARP 进程在本局域网上广播发送一个 ARP 请求分组。图 4-11(a) 是主机 A 广播发送 ARP 请求分组的示意图。ARP 请求分组的主要内容是：“我的 IP 地址是 209.0.0.5，硬件地址是 00-00-C0-15-AD-18。我想知道 IP 地址为 209.0.0.6 的主机的硬件地址。”

（2）在本局域网上的所有主机上运行的 ARP 进程都收到此 ARP 请求分组。

（3）主机 B 的 IP 地址与 ARP请求分组中要查询的 IP 地址一致，就收下这个 ARP 请求分组，并向主机 A 发送 ARP 响应分组，同时在这个 ARP 响应分组中写入自己的硬件地址。由于其余的所有主机的 IP 地址都与 ARP 请求分组中要查询的 IP 地址不一致，因此都不理睬这个 ARP 请求分组，见图 4-11(b)。ARP 响应分组的主要内容是：“我的 IP 地址是 209.0.0.6，我的硬件地址是 08-00-2B-00-EE-0A。” 请注意：虽然 ARP 请求分组是广播发送的，但 ARP 响应分组是普通的单播，即从一个源地址发送到一个目的地址。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE9.jpg"/> </div><br>
（4）主机 A 收到主机 B 的 ARP 响应分组后，就在其 ARP 高速缓存中写入主机 B 的 IP 地址到硬件地址的映射。

当主机 A 向 B 发送数据报时，很可能以后不久主机 B 还要向 A 发送数据报，因而主机 B 也可能要向 A 发送 ARP 请求分组。为了减少网络上的通信量，主机 A 在发送其 ARP 请求分组时，就把自己的 IP 地址到硬件地址的映射写入 ARP 请求分组。当主机 B 收到 A 的 ARP 请求分组时，就把主机 A 的这一地址映射写入主机 B 自己的 ARP 高速缓冲中。以后主机 B 向 A 发送数据报时就很方便了。

可见 ARP 高速缓存非常有用。如果不使用 ARP 高速缓存，那么任何一台主机只要进行一次通信，就必须在网络上用广播方式发送 ARP 请求分组，这就使网络上的通信量大大增加。ARP 把已经得到的地址映射保存在高速缓存中，这样就使得该主机下次再和具有同样目的地址的主机通信时，可以直接从高速缓存中找到所需的硬件地址而不必再用广播方式发送 ARP 请求分组。

ARP 对保存在高速缓存中的每一个映射地址项目都设置生存时间（例如，10 ~ 20 分钟）。凡超过生存时间的项目就从高速缓存中删除掉。设置这种地址映射项目的生存时间是很重要的。设想有一种情况。主机 A 和 B 通信。A 的 ARP 高速缓存里保存有 B 的硬件地址。但 B 的网络适配器突然坏了，B 立即更换了一块，因此 B 的硬件地址就改变了。假定 A 还要和 B 继续通信。A 在其 ARP 高速缓存中查找到 B 原先的硬件地址，并使用该硬件地址向 B 发送数据帧。但 B 原先的硬件地址已经失效了，因此 A 无法找到主机 B。但是过了一段不长的生存时间，A 的 ARP 高速缓存中已经删除了 B 原先的硬件地址，于是 A 重新广播发送 ARP 请求分组，又找到了 B。

请注意，ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，例如，在前面的图 4-9 中，主机 H~1~ 就无法解析出另一个局域网上主机 H~2~ 的硬件地址（实际上主机 H~1~ 也不需要知道远程主机 H~2~ 的硬件地址）。主机 H~1~ 发送给 H~2~ 的 IP 数据报首先需要通过与主机 H~1~ 连接在在同一个局域网上的路由器 R~1~ 来转发。因此主机 H~1~ 这时需要把路由器 R~1~ 的 IP 地址 IP~3~ 解析为硬件地址 HA~3~，以便能够把 IP 数据报传送到路由器 R~1~。以后，R~1~ 从转发表找出了下一跳路由器 R~2~，同时使用 ARP 解析出 R~2~ 的硬件地址 HA~5~。于是 IP 数据报按照硬件地址 HA~5~ 转发到路由器 R~2~。路由器 R~2~ 在转发这个 IP 数据报时用类似方法解析出目的主机 H~2~ 的硬件地址 HA~2~，使 IP 数据报最终交付主机 H~2~。

从 IP 地址到硬件地址的解析是自动运行的，**主机的用户对这种地址解析过程是不知道的**。只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地把这个 IP 地址解析为链路层所需要的硬件地址。

既然在网络链路上传送的帧最终是按照硬件地址找到目的主机的，那么为什么我们还要使用抽象的 IP 地址，而不直接使用硬件地址进行通信？这样似乎可以免除使用 ARP。

谢希仁老师的计算机网络（第7版）原文解释的不清晰，可以参考知乎的回答：

[谢希仁 计算机网络（第七版）第四章，说为什么不直接使用硬件地址通信，解释实在没看懂，求解答?](https://www.zhihu.com/question/327977420)





#### IP 数据报的格式

IP 数据报的格式能够说明 IP 协议都具有什么功能。在 TCP/IP 的标准中，各种数据格式常常以 32 位（即 4 字节）为单位来描述。图 4-13 是 IP 数据报的完整格式。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE10.jpg"/> </div><br>
从图 4-13 可看出，一个 IP 数据报由首部和数据两部分组成。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。在首部的固定部分的后面是一些可选字段，其长度是可变的。

下面介绍首部各字段的意义。

##### 1. IP 数据报首部的固定部分中的各字段

（1）**版本**：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议的版本必须一致。目前广泛使用的 IP 协议版本号为 4（即 IPv4）。

（2）**首部长度**：占 4 位，可表示的最大十进制数值是 15。请注意，首部长度字段所表示的单位是 32 位字（1 个 32 位字长是 4 字节）。因为 IP 首部的固定长度是 20 字节，因此首部长度字段的最小值是 5（即二进制表示的首部长度是 0101）。而当首部长度为最大值 1111 时（即十进制的 15），就表明首部长度达到最大值 15 个 32 位字长，即 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此 IP 数据报的数据部分永远在 4 字节的整数倍时开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度是 20 字节（即首部长度位 0101），这时不使用任何选项。

（3）**区分服务**：占 8 位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998 年 IETF 把这个字段改名为区分服务 DS（Differentiated Services）。只有在使用区分服务时，这个字段才起作用。在一般的情况下都不使用这个字段。

（4）**总长度**：总长度指首部和数据之和的长度，单位为字节。总长度字段为 16 位，因此数据报的最大长度位 2^16^ - 1 = 65535 字节。然而实际上传送这样长的数据报在现实中是极少遇到的。

我们知道，在 IP 层下面的每一种数据链路层协议都规定了一个数据帧中的**数据字段的最大长度**，这称为**最大传送单元** MTU（Maximum Transfer Unit）。当一个 IP 数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层所规定的 MTU 值。例如，最常用的以太网就规定其 MTU 值是 1500 字节。若所传送的数据报长度超过数据链路层的 MTU 值，就必须把过长的数据报进行分片处理。

虽然使用尽可能长的 IP 数据报会使传输效率得到提高（因为每一个 IP 数据报中首部长度占数据报总长度的比例就会小些），但数据报短也有好处。每一个 IP 数据报越短，路由器转发的速度就越快。为此，IP 协议规定，在互联网中所有的主机和路由器，必须能够接受长度不超过 576 字节的数据报。这是假定上层交下来的数据长度有 512 字节（合理的长度），加上最长的 IP 首部 60 字节，再加上 4 字节的富余量，就得到 576 字节。当主机需要发送长度超过 576 字节的数据报时，应当先了解一下，目的主机能否接受所要发送的数据报长度。否则，就要进行分片。

在进行分片时（见后面的 “片偏移” 字段），数据报首部中的 “总长度” 字段时指**分片后的每一个分片**的首部长度与该分片的数据长度的总和。

（5）**标识**（identification）：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段。但这个 “标识” 并不是序号，因为 IP 是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能被正确地重装成为原来的数据报。

（6）**标志**（flag）：占 3 位，但目前只有两位有意义。

- 标志字段中的最低位记为 **MF**（More Fragment）。MF = 1 即表示后面 “**还有分片**” 的数据报。MF = 0 表示这已是若干数据报片中的最后一个。
- 标志字段中间的一位记为 **DF**（Don't Fragment），意思是 “**不能分片**”。只有当 DF = 0 时才允许分片。

（7）**片偏移**：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以 8 个字节为偏移单位。也就是说，每个分片的长度一定是 8 字节（64 位）的整数倍。

（8）**生存时间**：占 8 位，生存时间字段常用的英文缩写是 TTL（Time To Live），表明这是数据在网络上的**寿命**。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在互联网中兜圈子（例如从路由器 R~1~ 转发到 R~2~，再转发到 R~3~，然后又转发到 R~1~），因而白白消耗网络资源。最初的设计是以秒作为 TTL 值得得。每经过一个路由器时，就把 TTL 减去数据报在路由器所消耗掉得一段时间。若数据报在路由器消耗得时间小于 1 秒，就把 TTL 值减 1。当 TTL 值减为零时，就丢弃这个数据报。

然而随着技术的进步，路由器处理数据报所需的时间不断在缩短，一般都远远小于 1 秒，后来就把 TTL 字段的功能改为 “**跳数限制**”（但**名称不变**）。路由器在每次转发数据报之前就把 TTL 值减 1。若 TTL 值减小到零，就丢弃这个数据报，不再转发。因此，现在 TTL 的单位不再是秒，而是**跳数**。TTL 的意义是指明数据报在互联网中至多可经过多少个路由器。显然，数据报能在互联网中经过的路由器的最大数值是 255。若把 TTL 的初始值设置为 1，就表示这个数据报只能在本局域网中传送。因为这个数据报一传送到局域网上的某个路由器，在被转发之前 TTL 值就减小为零，因而就会被这个路由器丢弃。

（9）**协议**：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个协议进行处理。

常用的一些协议和相应的协议字段值如下：

|   协议名   | ICMP | IGMP |  IP  | TCP  | EGP  | IGP  | UDP  | IPv6 | ESP  | OSPF |
| :--------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 协议字段值 |  1   |  2   |  4   |  6   |  8   |  9   |  17  |  41  |  50  |  89  |

（10）**首部检验和**：占 16 位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。



（11）**源地址**：占 32 位。

（12）**目的地址**：占 32 位。



##### 2.IP 数据报首部的可变部分

IP 数据报首部的可变部分就是一个选项字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。而有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。

增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。很多路由器都不考虑 IP 首部的选项字段，因此新的 IP 版本 IPv6 就把 IP 数据报的首部长度做成固定的。





#### IP 层转发分组的流程

路由器若针对主机进行转发记录的话，数量太大不现实，在实际应用中，都是针对网络进行转发。在路由表中，对每一条路由最重要的是以下两个信息：

（目的网络地址，下一跳地址）

虽然互联网所有的分组转发都是**基于目的主机所在的网络**，但在大多数情况下都允许这样的特例，即对特定的目的主机指明一个路由。这种路由叫做**特定主机路由**。采用特定主机路由可使网络管理人员更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。在对网络的连接或路由表进行排错时，指明到某一台主机的特殊路由就十分有用。

路由器还可采用**默认路由**（default rout）以减小路由表所占用的空间和搜索路由表所用的时间。这种转发方式在一个网络只有很少的对外连接时是很有用的。实际上，默认路由在主机发送 IP 数据报时往往更能显示出它的好处。主机在发送每一个 IP 数据报时都要查找自己的路由表。如果一台主机连接在一个小网络上，而这个网络只用要给路由器和互联网连接，那么在这种情况下使用默认路由是非常合适的。

需要强调的是，在 IP 数据报的首部中没有地方可以用来指明 "下一跳路由器的 IP 地址"。在 IP 数据报的首部写上的 IP 地址是源 IP 地址和目的 IP 地址，而没有中间经过的路由器的 IP 地址。我们是通过其他方式来寻址的。

当路由器收到一个待转发的数据报，在从路由表得出下一跳路由器的 IP 地址后，不是把这个地址填入 IP 数据报，而是送交数据链路层的网络接口软件。网络接口软件负责把下一跳路由器的 IP 地址转换成硬件地址（必须使用 ARP），并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。由此可见，当发送一连串的数据报时，上述的这种查找路由表、用 ARP 得到硬件地址、把硬件地址写入 MAC 帧的首部等过程，将不断地重复进行，造成了一定的开销。

根据以上所述，可归纳出**分组转发算法**如下：

（1）从数据报的首部提取目的主机的 IP 地址 D，得出目的网络地址为 N。

（2）若 N 就是与此路由器直接相连的某个网络地址，则进行**直接交付**，不需要再经过其他的路由器，直接把数据报交付目的主机（这里包括把目的主机地址 D 转换为具体的硬件地址，把数据报封装为 MAC 帧，再发送此帧）；否则就是间接交付，执行（3）

（3）若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（4）

（4）若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（5）

（5）若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行（6）

（6）报告转发分组出错

上面所讨论的是 IP 层怎样根据路由表的内容进行分组转发，而没有涉及到路由表一开始是如何建立的以及路由表中的内容应如何进行更新。





#### 划分子网

##### 1.从两级 IP 地址到三级 IP 地址

在今天看来，在 ARPANET 的早期，IP 地址的设计确实不够合理。

第一，**IP 地址空间的利用率有时很低**。

第二，给每一个物理网络分配一个网络号会**使路由表变得太大**而使网络性能变坏。

第三，**两级 IP 地址不够灵活**。

有时情况紧急，一个单位需要在新的地点马上开通一个新的网络。但是在申请到一个新的 IP 地址之前，新增加的网络是不可能连接到互联网上工作的。我们希望有一种方法，使一个单位能随时灵活地增加本单位地网络，而不必事先到互联网管理机构去申请新的网络号。原来的两级 IP 地址无法做到这一点。

为解决上述问题，从 1985 年起在 IP 地址中又增加了一个 ”**子网号字段**“，使两级 IP 地址变成为三级 IP 地址，它能够较好地解决上述问题，并且使用起来也很灵活。这种做法叫做**划分子网**（subnetting），或**子网寻址**或**子网路由选择**。划分子网已成为互联网的正式标准协议。

划分子网的基本思路如下：

（1）一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个**子网**（subnet）。划分子网纯属一个单位内部的事情。本单位以外的网络**看不见**这个网络是由多少个子网组成，因为这个单位**对外仍然表现为一个网络**。

（2）划分子网的方法是从网络的主机号借用若干位作为子网号（subnet-id），当然主机号也就相应减少了同样的位数。于是两级 IP 地址在**本单位内部**就变成**三级** IP 地址：网络号、子网号和主机号。也可以用以下记法来表示：

IP 地址 ::= {<网络号>，<子网号>，<主机号>}

（3）凡是从其他网络发送给本单位某台主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号找到连接在本单位网络上的路由器。但此路由器在收到 IP 数据报后，再按目的网络号和子网号找到目的的子网，把 IP 数据报交付目的主机。

总之，当没有划分子网时，IP 地址是两级结构。划分子网后 IP 地址变成了三级结构。划分子网只是把 IP 地址的主机号这部分进行再划分，而不改变 IP 地址原来的网络号。



##### 2.子网掩码

我们知道，从 IP 数据报的首部无法看出源主机或目的主机所连接的网络是否就行了子网的划分。这是因为 32 位的 IP 地址本身以及数据报的首部都没有包含任何有关任何有关子网划分的信息。因此必须另外想办法，这就是使用子网掩码（subnet mask）（见图 4-20）。



图 4-20（a）是 IP 地址为 145.13.3.10 的主机本来的二级 IP 地址结构。图 4-20（b）是这个两级 IP 地址的子网掩码。图 4-20（c）是同一地址的三级 IP 地址结构，也就是说，现在从原来 16 位的主机号中拿出 8 位作为子网号，而主机号从 16 位减少到 8 位。请注意，现在子网号为 3 的网络的**网络地址**是 145.13.3.0（既不是原来两级 IP 地址的网络地址 145.13.0.0，也不是简单的子网号 3）。为了使路由器 R~1~ 能够很方便地从数据报中的目的 IP 地址中提取出所要找的子网的网络地址，路由器 R~1~ 就要使用三级 IP 地址的子网掩码。图 4-20（d）是三级 IP 地址的子网掩码，它也是 32 位，由一串 24 个 1 和跟随的一串 8 个 0 组成。子网掩码中的 1 对应于 IP 地址中原来二级地址中的 16 位网络号加上新增加的 8 位子网号，而子网掩码中的 0 对应于现在的 8 位主机号。虽然 RFC 文档中没有规定子网掩码中的一串 1 必须是连续的，但却极力推荐在子网掩码中选用**连续的** 1，以免出现可能发生的差错。

图 4-20（e）表示 R~1~ 把三级 IP 地址的子网掩码和收到的数据报的目的 IP 地址 145.13.3.10 逐位相 “与”（AND）（计算机进行这种逻辑 AND 运算是很容易的），得出了所要找的**子网的网络地址** 145.13.3.0。

使用子网掩码的好处就是：不管网络有没有划分子网，只要把子网掩码和 IP 地址进行逐位的 “与” 运算（AND），就立即得出网络地址来。这样在路由器处理到来的分组时就可采用同样的算法。

归纳一下上述的要点。从网络 145.13.0.0 **外面**看，这就是一个普通的 B 类网络，其子网掩码为 16 个连 1后面跟上 16 个连 0。但**进入**到这个网络后（即到了路由器 R1），就看到了还有许多网络（即划分了子网后的许多网络），其网络地址是 145.13.x.0（这里 x 可以表示不同的数值），而这些网络的子网掩码都是 24 个连 1 后面跟上 8 个连 0。总之，在这个 B 类网络的外面和里面，看到的网络是不一样的。

这里还要弄清一个问题，这就是：在不划分子网时，既然没有子网，为什么还要使用子网掩码？这就是为了更便于查找路由表。现在互联网的标准规定：所有的网络都必须使用子网掩码，同时在路由器的路由表中也必须有子网掩码这一栏。如果一个网络不划分子网，那么该网络的子网掩码就使用**默认子网掩码**。默认子网掩码中 1 的位置和 IP 地址中的网络号字段 net-id 正好相对应。因此，若用默认子网掩码和某个不划分子网的 IP 地址逐位相 “与”（AND）。就应当能够得出该 IP 地址的网络地址来。这样做可以不用查找该地址的类别位就能知道这是哪一类的 IP 地址。显然，

A 类地址的默认子网掩码是 255.0.0.0，或 0xFF000000。

B 类地址的默认子网掩码是 255.255.0.0，或 0xFFFF0000。

C 类地址的默认子网掩码是 255.255.255.0，或 0xFFFFFF00。



**子网掩码是一个网络或一个子网的重要属性**。在 RFC 950 成为互联网的正式标准后，路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。在路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。若一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码。

为何子网数要除去全 0 和全 1 这两种情况？

看看RFC950提到的原因：
假设我们有一个网络：192.168.0.0/24，我们现在需要两个子网，那么按照 RFC950，应该使用使用两位子网号，即 /26，得到两个可以使用的子网 192.168.0.64/26 和 192.168.0.128/26
对于主网络 192.168.0.0/24，网络地址是 192.168.0.0，广播地址是 192.168.0.255
对于子网 192.168.0.0/26（子网号全 0），网络地址是 192.168.0.0，广播地址是 192.168.0.63
对于子网 192.168.0.64/26，网络地址是 192.168.0.64，广播地址是 192.168.0.127
对于子网 192.168.0.128/26，网络地址是 192.168.0.128，广播地址是 192.168.0.191
对于子网 192.168.0.192/26（子网号全 1），网络地址是 192.168.0.192，广播地址是 192.168.0.255

可以看出，对于第一个子网，网络地址和主网络的网络地址是重叠的，对于最后一个子网，广播地址和主网络的广播地址也是重叠的。这样的重叠将导致极大的混乱。比如，一个发往 192.168.0.255 的广播是发给主网络的还是子网的？这就是为什么在当时不建议使用全0和全1子网。





#### 使用子网时分组的转发

在划分子网的情况下，分组转发的算法必须做相应的改动。

我们应当注意到，使用子网划分后，路由表必须包含以下三项内容：**目的网络地址**、**子网掩码**和**下一跳地址**。

在划分子网的情况下：路由器转发分组的算法如下：

（1）从收到的数据报的首部提取目的 IP 地址 D。

（2）先判断是否为直接交付。对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和 D 诸位相 “与”（AND 操作），看结果是否和相应的网络地址匹配。若匹配，则把分组直接进行交付（当然还需要把 D 转换成物理地址，把数据报封装成帧发送出去），转发任务结束。否则就是间接交付，执行（3）

（3）若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（4）

（4）若路由表中的每一行（目的网络地址，子网掩码，下一跳地址），用其中的子网掩码和 D 逐位相 “与”（AND 操作），若结果为 N。若 N 与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器；否则，执行（5）。

（5）若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行（6）

（6）报告转发分组出错

















