## 网络层

#### 概述

**网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务**。这里的数据报（datagram）就是 “分组”。

网络在发送分组时不需要先建立连接。每一个分组独立发送，与其前后的分组无关（不进行编号）。**网络层不提供服务质量的承诺**。也就是说，所传送的分组可能出错、丢失、重复和失序（即不按序到达终点），当然也不保证分组交付的时限。由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器比较简单，且价格低廉（与电信网的交换机相比较）。如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责（包括差错处理、流量控制等）。



#### 网际协议 IP

与 IP 协议配套使用的还有三个协议：

- **地址解析协议 ARP**（Address Resolution Protocol）
- **网际控制报文协议 ICMP**（Internet Control Message Protocol）
- **网际组管理协议 IGMP**（Internet Group Management Protocol）

图 4-2 画出了这三个协议和网际协议 IP 的关系。在这一层中，ARP 画在最下面，因为 IP 经常要使用这个协议。ICMP 和 IGMP 画在这一层的上部，因为它们要使用 IP 协议。由于网际协议 IP 是用来使互接起来的许多计算机网络能够进行通信的，因此 TCP/IP 体系中的网络层常常被称为**网际层**（internet layer），或 IP 层。使用 “网际层” 这个名称的好处是强调这是由很多网络构成的互连网络。 

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE1.jpg"/> </div><br>
#### 分类的 IP 地址

##### 1.IP 地址及其表示方法

整个的互联网就是一个**单一的、抽象的网络**。IP 地址就是给互联网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内是唯一的 32 位的标识符。IP 地址的结构使我们可以在互联网上很方便地进行寻址。

IP 地址的编址方法共经过了三个历史阶段。

（1）**分类的 IP 地址**。这是最基本的编址方法。

（2）**子网的划分**。这是对最基本的编址方法的改进。

（3）**构成超网**。这是比较新的无分类编址方法。

所谓 “分类的 IP 地址” 就是将 IP 地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成，其中第一个字段是**网络号**（net-id），它标志主机（或路由器）所连接到的网络。一个网络号在整个互联网范围内必须是唯一的。第二个字段是主机号（host-id），它标志该主机（或路由器）。一台主机号在它前面的网络号所指明的网络范围内必须是唯一的。由此可见，一个 IP 地址**在整个互联网范围内是唯一的**。

这种两级的 IP 地址可以记为：

IP 地址 ::={<网络号>,<主机号>}



图 4-5 给出了各种 IP 地址的网络号字段和主机号字段，这里 A 类、 B 类和 C 类地址都是**单播地址**（一对一通信），是最常用的。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE2.png"/> </div><br>
从图 4-5 可以看出：

- A 类、 B 类和 C 类地址的网络号字段（在途中这个字段是灰色的）分别为 1 个、 2 个和 3 个字节长，而在网络号字段的最前面有 1~3 位的**类别位**，其数指分别规定为 0， 10 和 110。
- A 类、 B 类和 C 类地址的主机号字段分别为 3 个、 2 个和 1 个字节长。
- D 类地址（前 4 位是 1110）用于**多播**（一对多通信）。
- E 类地址（前 4 位是 1111）保留为以后用。	

这里要指出，由于近年来已经广泛使用无分类 IP 地址进行路由选择，A 类、 B 类和 C 类地址的区分已成为历史。为了理解概念的演进，我们这里还要从分类的 IP 地址讲起。

从 IP 地址的结构来看，**IP** 地址并不仅仅指明一台主机，而是还指明了主机所连接到的网络。

把 IP 地址划分为 A 类、 B 类和 C 类三个类别，当初是这样考虑的。各种网络的差异很大，有的网络拥有很多主机，而有的网络上的主机则很少。把 IP 地址划分为 A 类、 B 类和 C 类是为了更好地满足不同用户的要求。当某个单位申请到一个 IP 地址时，实际上是获得了具有同样网络号的一块地址。其中具体的各台主机号则由该单位自行分配，只要做到在该单位管辖的范围内无重复的主机号即可。

对主机或路由器来说，IP 地址都是 32 位的二进制代码。为了提高可读性，我们常常把 32 位的 IP 地址中的每 8 位插入一个空格（**但在机器中并没有这样的空格**）。为了便于书写，可用其等效的十进制数字表示，并且在这些数字之间加上一个点。这就叫做**点分十进制记法**（dotted decimal notation）。图 4-6 是一个 B 类 IP 地址的表示方法。显然，128.11.3.31 比 10000000 00001011 00000011 00011111 书写起来要方便得多。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE3.jpg"/> </div><br>
##### 2.常用的三种类别的 IP 地址

A 类地址的网络号字段占 1 个字节，只有 7 位可供使用（该字段的第一位已固定为 0），但可指派的网络号是 126 个（即 2^32^ - 2）。减 2 的原因是：第一，IP 地址中的全 0 表示 “**这个**（this）”。网络号字段为全 0 的 IP 地址是个保留地址，意思是 “本网络”；第二，网络号为 127（即 01111111）保留作为本地软件**环回测试**（loopback test）本主机的进程之间的通信之用。若主机发送一个目的地址为环回地址（例如 127.0.0.1）的 IP 数据报，则本主机中的协议软件就处理数据报中的数据，而不会把数据报发送到任何网络。目的地址为环回地址的 IP 数据报永远不会出现在任何网络上，因为网络号为 127 的地址根本不是一个网络地址。

关于全 1 和全 0 还可以再举两个例子。例如，B 类地址 128.7.255.255 表示 “在网络 128.7.0.0 上的所有主机”。而 A 类地址 0.0.0.35 则表示 ”在这个网络上主机号为 35 的主机“。

A 类地址的主机号占 3 个字节，因此每一个 A 类网络中的最大主机数是 2^24^ - 2，即 16777214。这里减 2 的原因是：全 0 的主机号字段表示该 IP 地址是 “本主机” 所连接到的**单个网络地址**（例如，一主机的 IP 地址为 5.6.7.8，则该主机所在的网络地址就是 5.0.0.0），而全 1 表示 “**所有的**（all）”，因此全 1 的主机号字段表示该网络上的所有主机。

如果主机号全 0，IP 地址代表仅网络号指向的那个网段，该 IP 代表一个网段；如果主机号全 1，IP 地址代表网络号指向的全部主机，IP 地址代表广播地址 ；其他就是普通的 IP 地址，指向网域中的一个主机了。

在 A 类、B 类、C 类 IP 地址中，如果主机号是全 1，那么这个地址为直接广播地址，它是用来使路由器将一个分组以广播形式发送给特定网络上的所有主机。32 位全为 1 的 **IP地址 ** “255.255.255.255” 为**受限广播地址**（"limited broadcast" destination address），用来将一个分组以广播方式发送给本网络中的所有主机，路由器则阻挡该分组通过，将其广播功能限制在本网内部。

IP 地址空间共有 2^32^（即 4294967296）个地址。整个 A 类地址空间共有 2^31^ 个地址，占整个 IP 地址空间的 50%。

B 类地址的网络号字段有 2 个字节，但前面两位（1 0）已经固定了，只剩下 14 位可以进行分配。因为网络号字段后面的 14 位无论怎样取值也不可能出现使整个 2 字节的网络号字段成为全 0 或全 1，因此这里不存在网络总数减 2 的问题。但实际上 B 类网络地址 128.0.0.0 是不指派的，而可以指派的 B 类最小网络地址是 128.1.0.0[COME06]。因此 B 类地址可指派的网络数为 2^14^ - 1，即 16383。B 类地址的每一个网络上的最大主机数是 2^16^ - 2，即 65534。这里需要减 2 是因为要扣除全 0 和全 1 的主机号。整个 B 类地址空间共约有 2^30^ 个地址，占整个 IP 地址空间的 25%。

C 类地址有 3 个字节的网络号字段，最前面的 3 位是（1 1 0），还有 21 位可以进行分配。C 类网络地址 192.0.0.0 也是不指派的，可以指派的 C 类最小网络是 192.0.1.0[COME06]，因此 C 类地址可指派的网络总数是 2^21^ - 1，即 2097151。每一个 C 类地址的最大主机是 2^8^ - 2，即 254。整个 C 类地址空间共约有 2^29^ 个地址，占整个 IP 地址的 12.5%。

这样，我们就可得出表 4-2 所示的 IP 地址的指派范围。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE4.jpg"/> </div><br>
IP 地址具有以下一些重要特点。

（1）每一个 IP 地址都由网络号和主机号两部分组成。从这个意义上说，IP 地址是一种**分等级的地址结构**。分两个等级的好处是：第一，IP 地址管理机构在分配 IP 地址时**只分配网络号**（第一级），而剩下的主机号（第二级）则由得到该网络号的单位来自行分配。这样就方便了 IP 地址的管理；第二，路由器**仅根据目的主机所连接的网络号来转发分组**（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度较少，从而**减小了路由表所占的存储空间以及查找路由表的时间**。

（2）实际上 IP 地址是标志一台主机（或路由器）和一条链路的**接口**。当一台主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号必须是不同的。这种主机称为**多归属主机**（multihomed host）。由于一个路由器至少应当连接到两个网络，因此一个路由器至少应当有两个不同的 IP 地址。这好比一个建筑正好处在北京路和上海路的交叉口上，那么这个建筑就可以拥有两个门牌号码。例如，北京路 4 号和上海路 37 号。

（3）按照互联网的观点，一个网络是指具有相同网络号 net-id 的主机的集合，因此，**用转发器或网桥连接起来的若干个局域网仍为一个网络**，因为这些局域网都具有同样的网络号。具有不同网络号的局域网必须使用路由器进行互连。

（4）在 IP 地址中，所有分配到网络号的网络（不管是范围很小的局域网，还是可能覆盖很大地理范围的广域网）都是**平等**的。所谓平等，是指互联网同等对待每一个 IP 地址。



#### IP 地址与硬件地址

从层次的角度看，**物理地址是数据链路层和物理层使用的地址**，而 **IP 地址是网络层和以上各层使用的地址，是一种逻辑地址**（称 IP 地址为逻辑地址是因为 IP 地址是用软件实现的）。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE5.jpg"/> </div><br>
在发送数据时，数据从高层下到低层，然后才到通信链路上传输。使用 IP 地址的 IP 数据报一旦交给了数据链路层，就被封装成 MAC 帧了。MAC 帧在传送时使用的源地址和目的地址都是硬件地址，这两个硬件地址都写在 MAC 帧的首部中。

连接在通信链路上的设备（主机或路由器）在收到 MAC 帧时，根据 MAC 帧首部中的硬件地址决定收下或丢弃。只有在剥去 MAC 帧的首部和尾部后把 MAC 层的数据上交给网络层后，网络层才能在 IP 数据报的首部中找到源 IP 地址和目的 IP 地址。

总之，IP 地址放在 IP 数据报的首部，而硬件地址则放在 MAC 帧的首部。在网络层和网络层以上使用的是 IP 地址，而数据链路层及以下使用的是硬件地址。在图 4-8 中，当 IP 数据报放入数据链路层的 MAC 帧中以后，整个的 IP 数据报就成为 MAC 帧的数据，因而在数据链路层看不见数据报的 IP 地址。

图 4-9(a)画的是三个局域网用两个路由器 R~1~ 和 R~2~ 互连的情况。现在主机 H1 要和主机 H2 通信。这两台主机的 IP 地址分别是 IP~1~ 和 IP~2~，而它们的硬件地址分别为 HA~1~ 和 HA~2~（HA 表示 Hardware Address）。通信的路径是：H~1~——经过 R~1~ 转发——再经过 R~2~ 转发——H~2~。路由器 R~1~ 因同时连接到两个局域网上，因此说它有两个硬件地址，即  HA~3~ 和 HA~4~。同理，路由器 R~2~ 也有两个硬件地址 HA~5~ 和 HA~6~。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE6.jpg"/> </div><br>
图 4-9(b)特别强调了 IP 地址与硬件地址的区别。表 4-4 归纳了这种区别。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE7.jpg"/> </div><br>
这里要强调指出以下几点：

（1）**在 IP 层抽象的互联网上只能看到 IP 数据报**。虽然 IP 数据报要经过路由器 R~1~ 和 R~2~ 的两次转发，但在它的首部中的源地址和目的地址**始终**分别是 IP~1~ 和 IP~2~。图中的数据报上写的 “从 IP~1~ 到 IP~2~” 就表示前者是源地址而后者是目的地址。数据报中间经过的两个路由器的 IP 地址并不出现在 IP 数据报的首部中。

（2）虽然在 IP 数据报首部有源站 IP 地址，但**路由器只根据目的站的 IP 地址的网络号进行路由选择**。

（3）**在局域网的链路层，只能看见 MAC 帧**。IP 数据报被封装在 MAC 帧中。MAC 帧在不同网络上传送时，其 MAC 帧首部中的源地址和目的地址要发生变化，见图 4-9(b)。开始在 H~1~ 和 R~1~ 间传送时，MAC 帧首部中写的是从硬件地址 HA~1~ 发送到硬件地址 HA~3~，路由器 R~1~ 收到此 MAC 帧后，在数据链路层，要丢弃原来的 MAC 帧的首部和尾部。在转发时，在数据链路层，要重新加上 MAC 帧的首部和尾部。这时首部中的源地址和目的地址分别便成为 HA~4~ 和 HA~5~。路由器 R~2~ 收到此帧后，再次更换 MAC 帧的首部和尾部，首部中的源地址和目的地址分别变为 HA~6~ 和 HA~2~。MAC 帧的首部的这种变化，在上面的 IP 层上是看不见的。

（4）尽管互连在一起的网络的硬件地址体系各不相同，但 **IP 层抽象的互联网却屏蔽了下层这些很复杂的细节。只要我们在网络层上讨论问题，就能够使用统一的、抽象的 IP 地址研究主机和主机或路由器之间的通信**。上述的这种 “屏蔽” 概念是一个很有用、很普遍的基本概念。例如，计算机中广泛使用的图形用户界面使得用户只需简单地点击几下鼠标就能让计算机完成很多任务。实际上计算机要完成这些任务必须执行很多条指令。但这些复杂的过程全都被设计良好的图形用户界面屏蔽掉了，使用户看不见这些复杂过程。

以上这些概念是计算机网络的精髓所在，对这些重要概念务必仔细思考和掌握。





#### 地址解析协议 ARP

在实际应用中，我们经常会遇到这样的问题：已经知道了一个机器（主机或路由器）的 IP 地址，需要找出其相应的硬件地址。地址解析协议 ARP 就是用来解决这样的问题的。图 4-10 说明了 ARP 协议的作用。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE8.jpg"/> </div><br>
由于是 IP 协议使用了 ARP 协议，因此通常就把 ARP 协议划归网络层。但 ARP 协议的用途是为了从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。因此，有的教科书就按照协议的作用，把 ARP 协议划归在数据链路层。这样做当然也是可以的。

我们知道，网络层使用的是 IP 地址，但在实际网络的链路上传送数据帧时，最终还是必须使用该网络的硬件地址。但 IP 地址和下面的网络的硬件地址之间由于格式不同而不存在简单的映射关系（例如，IP 地址有 32 位，而局域网的硬件地址是 48 位）。此外，在一个网络上可能经常会有新的主机加入进来，或撤走一些主机。更换网络适配器也会使主机的硬件地址改变。**地址解析协议** ARP 解决这个问题的方法是在主机 ARP 高速缓存中存放一个从 IP 地址到硬件地址的映射表，并且这个映射表还经常动态更新（新增或超时删除）。

每一台主机都设有一个 ARP **高速缓存**（**ARP cache**），里面有**本局域网上**的各主机和路由器的 IP 地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。那么主机怎样知道这些地址呢？我们可以通过下面的例子来说明。

当主机 A 要向**本局域网**上的某台主机 B 发送 IP 数据报时，就现在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就在 ARP 高速缓存中查出其对应的硬件地址，再把这个硬件地址写入 MAC 帧，然后通过局域网把该 MAC 帧发往此硬件地址。

也有可能查不到主机 B 的 IP 地址的项目。这可能是主机 B 才入网，也可能是主机 A 刚刚加电，其高速缓存还是空的。在这种情况下，主机 A 就自动运行 ARP，然后按以下步骤找出主机 B 的硬件地址。

（1）ARP 进程在本局域网上广播发送一个 ARP 请求分组。图 4-11(a) 是主机 A 广播发送 ARP 请求分组的示意图。ARP 请求分组的主要内容是：“我的 IP 地址是 209.0.0.5，硬件地址是 00-00-C0-15-AD-18。我想知道 IP 地址为 209.0.0.6 的主机的硬件地址。”

（2）在本局域网上的所有主机上运行的 ARP 进程都收到此 ARP 请求分组。

（3）主机 B 的 IP 地址与 ARP请求分组中要查询的 IP 地址一致，就收下这个 ARP 请求分组，并向主机 A 发送 ARP 响应分组，同时在这个 ARP 响应分组中写入自己的硬件地址。由于其余的所有主机的 IP 地址都与 ARP 请求分组中要查询的 IP 地址不一致，因此都不理睬这个 ARP 请求分组，见图 4-11(b)。ARP 响应分组的主要内容是：“我的 IP 地址是 209.0.0.6，我的硬件地址是 08-00-2B-00-EE-0A。” 请注意：虽然 ARP 请求分组是广播发送的，但 ARP 响应分组是普通的单播，即从一个源地址发送到一个目的地址。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE9.jpg"/> </div><br>
（4）主机 A 收到主机 B 的 ARP 响应分组后，就在其 ARP 高速缓存中写入主机 B 的 IP 地址到硬件地址的映射。

当主机 A 向 B 发送数据报时，很可能以后不久主机 B 还要向 A 发送数据报，因而主机 B 也可能要向 A 发送 ARP 请求分组。为了减少网络上的通信量，主机 A 在发送其 ARP 请求分组时，就把自己的 IP 地址到硬件地址的映射写入 ARP 请求分组。当主机 B 收到 A 的 ARP 请求分组时，就把主机 A 的这一地址映射写入主机 B 自己的 ARP 高速缓冲中。以后主机 B 向 A 发送数据报时就很方便了。

可见 ARP 高速缓存非常有用。如果不使用 ARP 高速缓存，那么任何一台主机只要进行一次通信，就必须在网络上用广播方式发送 ARP 请求分组，这就使网络上的通信量大大增加。ARP 把已经得到的地址映射保存在高速缓存中，这样就使得该主机下次再和具有同样目的地址的主机通信时，可以直接从高速缓存中找到所需的硬件地址而不必再用广播方式发送 ARP 请求分组。

ARP 对保存在高速缓存中的每一个映射地址项目都设置生存时间（例如，10 ~ 20 分钟）。凡超过生存时间的项目就从高速缓存中删除掉。设置这种地址映射项目的生存时间是很重要的。设想有一种情况。主机 A 和 B 通信。A 的 ARP 高速缓存里保存有 B 的硬件地址。但 B 的网络适配器突然坏了，B 立即更换了一块，因此 B 的硬件地址就改变了。假定 A 还要和 B 继续通信。A 在其 ARP 高速缓存中查找到 B 原先的硬件地址，并使用该硬件地址向 B 发送数据帧。但 B 原先的硬件地址已经失效了，因此 A 无法找到主机 B。但是过了一段不长的生存时间，A 的 ARP 高速缓存中已经删除了 B 原先的硬件地址，于是 A 重新广播发送 ARP 请求分组，又找到了 B。

请注意，ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。如果所要找的主机和源主机不在同一个局域网上，例如，在前面的图 4-9 中，主机 H~1~ 就无法解析出另一个局域网上主机 H~2~ 的硬件地址（实际上主机 H~1~ 也不需要知道远程主机 H~2~ 的硬件地址）。主机 H~1~ 发送给 H~2~ 的 IP 数据报首先需要通过与主机 H~1~ 连接在在同一个局域网上的路由器 R~1~ 来转发。因此主机 H~1~ 这时需要把路由器 R~1~ 的 IP 地址 IP~3~ 解析为硬件地址 HA~3~，以便能够把 IP 数据报传送到路由器 R~1~。以后，R~1~ 从转发表找出了下一跳路由器 R~2~，同时使用 ARP 解析出 R~2~ 的硬件地址 HA~5~。于是 IP 数据报按照硬件地址 HA~5~ 转发到路由器 R~2~。路由器 R~2~ 在转发这个 IP 数据报时用类似方法解析出目的主机 H~2~ 的硬件地址 HA~2~，使 IP 数据报最终交付主机 H~2~。

从 IP 地址到硬件地址的解析是自动运行的，**主机的用户对这种地址解析过程是不知道的**。只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地把这个 IP 地址解析为链路层所需要的硬件地址。

既然在网络链路上传送的帧最终是按照硬件地址找到目的主机的，那么为什么我们还要使用抽象的 IP 地址，而不直接使用硬件地址进行通信？这样似乎可以免除使用 ARP。

谢希仁老师的计算机网络（第7版）原文解释的不清晰，可以参考知乎的回答：

[谢希仁 计算机网络（第七版）第四章，说为什么不直接使用硬件地址通信，解释实在没看懂，求解答?](https://www.zhihu.com/question/327977420)





#### IP 数据报的格式

IP 数据报的格式能够说明 IP 协议都具有什么功能。在 TCP/IP 的标准中，各种数据格式常常以 32 位（即 4 字节）为单位来描述。图 4-13 是 IP 数据报的完整格式。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE10.jpg"/> </div><br>
从图 4-13 可看出，一个 IP 数据报由首部和数据两部分组成。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。在首部的固定部分的后面是一些可选字段，其长度是可变的。

下面介绍首部各字段的意义。

##### 1. IP 数据报首部的固定部分中的各字段

（1）**版本**：占 4 位，指 IP 协议的版本。通信双方使用的 IP 协议的版本必须一致。目前广泛使用的 IP 协议版本号为 4（即 IPv4）。

（2）**首部长度**：占 4 位，可表示的最大十进制数值是 15。请注意，首部长度字段所表示的单位是 32 位字（1 个 32 位字长是 4 字节）。因为 IP 首部的固定长度是 20 字节，因此首部长度字段的最小值是 5（即二进制表示的首部长度是 0101）。而当首部长度为最大值 1111 时（即十进制的 15），就表明首部长度达到最大值 15 个 32 位字长，即 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此 IP 数据报的数据部分永远在 4 字节的整数倍时开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是有时可能不够用。但这样做是希望用户尽量减少开销。最常用的首部长度是 20 字节（即首部长度位 0101），这时不使用任何选项。

（3）**区分服务**：占 8 位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998 年 IETF 把这个字段改名为区分服务 DS（Differentiated Services）。只有在使用区分服务时，这个字段才起作用。在一般的情况下都不使用这个字段。

（4）**总长度**：总长度指首部和数据之和的长度，单位为字节。总长度字段为 16 位，因此数据报的最大长度位 2^16^ - 1 = 65535 字节。然而实际上传送这样长的数据报在现实中是极少遇到的。

我们知道，在 IP 层下面的每一种数据链路层协议都规定了一个数据帧中的**数据字段的最大长度**，这称为**最大传送单元** MTU（Maximum Transfer Unit）。当一个 IP 数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层所规定的 MTU 值。例如，最常用的以太网就规定其 MTU 值是 1500 字节。若所传送的数据报长度超过数据链路层的 MTU 值，就必须把过长的数据报进行分片处理。

虽然使用尽可能长的 IP 数据报会使传输效率得到提高（因为每一个 IP 数据报中首部长度占数据报总长度的比例就会小些），但数据报短也有好处。每一个 IP 数据报越短，路由器转发的速度就越快。为此，IP 协议规定，在互联网中所有的主机和路由器，必须能够接受长度不超过 576 字节的数据报。这是假定上层交下来的数据长度有 512 字节（合理的长度），加上最长的 IP 首部 60 字节，再加上 4 字节的富余量，就得到 576 字节。当主机需要发送长度超过 576 字节的数据报时，应当先了解一下，目的主机能否接受所要发送的数据报长度。否则，就要进行分片。

在进行分片时（见后面的 “片偏移” 字段），数据报首部中的 “总长度” 字段时指**分片后的每一个分片**的首部长度与该分片的数据长度的总和。

（5）**标识**（identification）：占 16 位。IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段。但这个 “标识” 并不是序号，因为 IP 是无连接服务，数据报不存在按序接收的问题。当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。相同的标识字段的值使分片后的各数据报片最后能被正确地重装成为原来的数据报。

（6）**标志**（flag）：占 3 位，但目前只有两位有意义。

- 标志字段中的最低位记为 **MF**（More Fragment）。MF = 1 即表示后面 “**还有分片**” 的数据报。MF = 0 表示这已是若干数据报片中的最后一个。
- 标志字段中间的一位记为 **DF**（Don't Fragment），意思是 “**不能分片**”。只有当 DF = 0 时才允许分片。

（7）**片偏移**：占 13 位。片偏移指出：较长的分组在分片后，某片在原分组中的相对位置。也就是说，相对于用户数据字段的起点，该片从何处开始。片偏移以 8 个字节为偏移单位。也就是说，每个分片的长度一定是 8 字节（64 位）的整数倍。

（8）**生存时间**：占 8 位，生存时间字段常用的英文缩写是 TTL（Time To Live），表明这是数据在网络上的**寿命**。由发出数据报的源点设置这个字段。其目的是防止无法交付的数据报无限制地在互联网中兜圈子（例如从路由器 R~1~ 转发到 R~2~，再转发到 R~3~，然后又转发到 R~1~），因而白白消耗网络资源。最初的设计是以秒作为 TTL 值得得。每经过一个路由器时，就把 TTL 减去数据报在路由器所消耗掉得一段时间。若数据报在路由器消耗得时间小于 1 秒，就把 TTL 值减 1。当 TTL 值减为零时，就丢弃这个数据报。

然而随着技术的进步，路由器处理数据报所需的时间不断在缩短，一般都远远小于 1 秒，后来就把 TTL 字段的功能改为 “**跳数限制**”（但**名称不变**）。路由器在每次转发数据报之前就把 TTL 值减 1。若 TTL 值减小到零，就丢弃这个数据报，不再转发。因此，现在 TTL 的单位不再是秒，而是**跳数**。TTL 的意义是指明数据报在互联网中至多可经过多少个路由器。显然，数据报能在互联网中经过的路由器的最大数值是 255。若把 TTL 的初始值设置为 1，就表示这个数据报只能在本局域网中传送。因为这个数据报一传送到局域网上的某个路由器，在被转发之前 TTL 值就减小为零，因而就会被这个路由器丢弃。

（9）**协议**：占 8 位，协议字段指出此数据报携带的数据是使用何种协议，以便使目的主机的 IP 层知道应将数据部分上交给哪个协议进行处理。

常用的一些协议和相应的协议字段值如下：

|   协议名   | ICMP | IGMP |  IP  | TCP  | EGP  | IGP  | UDP  | IPv6 | ESP  | OSPF |
| :--------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| 协议字段值 |  1   |  2   |  4   |  6   |  8   |  9   |  17  |  41  |  50  |  89  |

（10）**首部检验和**：占 16 位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。



（11）**源地址**：占 32 位。

（12）**目的地址**：占 32 位。



##### 2.IP 数据报首部的可变部分

IP 数据报首部的可变部分就是一个选项字段。选项字段用来支持排错、测量以及安全等措施，内容很丰富。此字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。某些选项项目只需要 1 个字节，它只包括 1 个字节的选项代码。而有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符，最后用全 0 的填充字段补齐成为 4 字节的整数倍。

增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。实际上这些选项很少被使用。很多路由器都不考虑 IP 首部的选项字段，因此新的 IP 版本 IPv6 就把 IP 数据报的首部长度做成固定的。





#### IP 层转发分组的流程

路由器若针对主机进行转发记录的话，数量太大不现实，在实际应用中，都是针对网络进行转发。在路由表中，对每一条路由最重要的是以下两个信息：

（目的网络地址，下一跳地址）

虽然互联网所有的分组转发都是**基于目的主机所在的网络**，但在大多数情况下都允许这样的特例，即对特定的目的主机指明一个路由。这种路由叫做**特定主机路由**。采用特定主机路由可使网络管理人员更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。在对网络的连接或路由表进行排错时，指明到某一台主机的特殊路由就十分有用。

路由器还可采用**默认路由**（default rout）以减小路由表所占用的空间和搜索路由表所用的时间。这种转发方式在一个网络只有很少的对外连接时是很有用的。实际上，默认路由在主机发送 IP 数据报时往往更能显示出它的好处。主机在发送每一个 IP 数据报时都要查找自己的路由表。如果一台主机连接在一个小网络上，而这个网络只用要给路由器和互联网连接，那么在这种情况下使用默认路由是非常合适的。

需要强调的是，在 IP 数据报的首部中没有地方可以用来指明 "下一跳路由器的 IP 地址"。在 IP 数据报的首部写上的 IP 地址是源 IP 地址和目的 IP 地址，而没有中间经过的路由器的 IP 地址。我们是通过其他方式来寻址的。

当路由器收到一个待转发的数据报，在从路由表得出下一跳路由器的 IP 地址后，不是把这个地址填入 IP 数据报，而是送交数据链路层的网络接口软件。网络接口软件负责把下一跳路由器的 IP 地址转换成硬件地址（必须使用 ARP），并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。由此可见，当发送一连串的数据报时，上述的这种查找路由表、用 ARP 得到硬件地址、把硬件地址写入 MAC 帧的首部等过程，将不断地重复进行，造成了一定的开销。

根据以上所述，可归纳出**分组转发算法**如下：

（1）从数据报的首部提取目的主机的 IP 地址 D，得出目的网络地址为 N。

（2）若 N 就是与此路由器直接相连的某个网络地址，则进行**直接交付**，不需要再经过其他的路由器，直接把数据报交付目的主机（这里包括把目的主机地址 D 转换为具体的硬件地址，把数据报封装为 MAC 帧，再发送此帧）；否则就是间接交付，执行（3）

（3）若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（4）

（4）若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（5）

（5）若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行（6）

（6）报告转发分组出错

上面所讨论的是 IP 层怎样根据路由表的内容进行分组转发，而没有涉及到路由表一开始是如何建立的以及路由表中的内容应如何进行更新。





#### 划分子网

##### 1.从两级 IP 地址到三级 IP 地址

在今天看来，在 ARPANET 的早期，IP 地址的设计确实不够合理。

第一，**IP 地址空间的利用率有时很低**。

第二，给每一个物理网络分配一个网络号会**使路由表变得太大**而使网络性能变坏。

第三，**两级 IP 地址不够灵活**。

有时情况紧急，一个单位需要在新的地点马上开通一个新的网络。但是在申请到一个新的 IP 地址之前，新增加的网络是不可能连接到互联网上工作的。我们希望有一种方法，使一个单位能随时灵活地增加本单位地网络，而不必事先到互联网管理机构去申请新的网络号。原来的两级 IP 地址无法做到这一点。

为解决上述问题，从 1985 年起在 IP 地址中又增加了一个 ”**子网号字段**“，使两级 IP 地址变成为三级 IP 地址，它能够较好地解决上述问题，并且使用起来也很灵活。这种做法叫做**划分子网**（subnetting），或**子网寻址**或**子网路由选择**。划分子网已成为互联网的正式标准协议。

划分子网的基本思路如下：

（1）一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个**子网**（subnet）。划分子网纯属一个单位内部的事情。本单位以外的网络**看不见**这个网络是由多少个子网组成，因为这个单位**对外仍然表现为一个网络**。

（2）划分子网的方法是从网络的主机号借用若干位作为子网号（subnet-id），当然主机号也就相应减少了同样的位数。于是两级 IP 地址在**本单位内部**就变成**三级** IP 地址：网络号、子网号和主机号。也可以用以下记法来表示：

IP 地址 ::= {<网络号>，<子网号>，<主机号>}

（3）凡是从其他网络发送给本单位某台主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号找到连接在本单位网络上的路由器。但此路由器在收到 IP 数据报后，再按目的网络号和子网号找到目的的子网，把 IP 数据报交付目的主机。

总之，当没有划分子网时，IP 地址是两级结构。划分子网后 IP 地址变成了三级结构。划分子网只是把 IP 地址的主机号这部分进行再划分，而不改变 IP 地址原来的网络号。



##### 2.子网掩码

我们知道，从 IP 数据报的首部无法看出源主机或目的主机所连接的网络是否进行了子网的划分。这是因为 32 位的 IP 地址本身以及数据报的首部都没有包含任何有关任何有关子网划分的信息。因此必须另外想办法，这就是使用子网掩码（subnet mask）（见图 4-20）。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE11.jpg"/> </div><br>
图 4-20（a）是 IP 地址为 145.13.3.10 的主机本来的二级 IP 地址结构。图 4-20（b）是这个两级 IP 地址的子网掩码。图 4-20（c）是同一地址的三级 IP 地址结构，也就是说，现在从原来 16 位的主机号中拿出 8 位作为子网号，而主机号从 16 位减少到 8 位。请注意，现在子网号为 3 的网络的**网络地址**是 145.13.3.0（既不是原来两级 IP 地址的网络地址 145.13.0.0，也不是简单的子网号 3）。为了使路由器 R~1~ 能够很方便地从数据报中的目的 IP 地址中提取出所要找的子网的网络地址，路由器 R~1~ 就要使用三级 IP 地址的子网掩码。图 4-20（d）是三级 IP 地址的子网掩码，它也是 32 位，由一串 24 个 1 和跟随的一串 8 个 0 组成。子网掩码中的 1 对应于 IP 地址中原来二级地址中的 16 位网络号加上新增加的 8 位子网号，而子网掩码中的 0 对应于现在的 8 位主机号。虽然 RFC 文档中没有规定子网掩码中的一串 1 必须是连续的，但却极力推荐在子网掩码中选用**连续的** 1，以免出现可能发生的差错。

图 4-20（e）表示 R~1~ 把三级 IP 地址的子网掩码和收到的数据报的目的 IP 地址 145.13.3.10 逐位相 “与”（AND）（计算机进行这种逻辑 AND 运算是很容易的），得出了所要找的**子网的网络地址** 145.13.3.0。

使用子网掩码的好处就是：不管网络有没有划分子网，只要把子网掩码和 IP 地址进行逐位的 “与” 运算（AND），就立即得出网络地址来。这样在路由器处理到来的分组时就可采用同样的算法。

归纳一下上述的要点。从网络 145.13.0.0 **外面**看，这就是一个普通的 B 类网络，其子网掩码为 16 个连 1后面跟上 16 个连 0。但**进入**到这个网络后（即到了路由器 R1），就看到了还有许多网络（即划分了子网后的许多网络），其网络地址是 145.13.x.0（这里 x 可以表示不同的数值），而这些网络的子网掩码都是 24 个连 1 后面跟上 8 个连 0。总之，在这个 B 类网络的外面和里面，看到的网络是不一样的。

这里还要弄清一个问题，这就是：在不划分子网时，既然没有子网，为什么还要使用子网掩码？这就是为了更便于查找路由表。现在互联网的标准规定：所有的网络都必须使用子网掩码，同时在路由器的路由表中也必须有子网掩码这一栏。如果一个网络不划分子网，那么该网络的子网掩码就使用**默认子网掩码**。默认子网掩码中 1 的位置和 IP 地址中的网络号字段 net-id 正好相对应。因此，若用默认子网掩码和某个不划分子网的 IP 地址逐位相 “与”（AND）。就应当能够得出该 IP 地址的网络地址来。这样做可以不用查找该地址的类别位就能知道这是哪一类的 IP 地址。显然，

A 类地址的默认子网掩码是 255.0.0.0，或 0xFF000000。

B 类地址的默认子网掩码是 255.255.0.0，或 0xFFFF0000。

C 类地址的默认子网掩码是 255.255.255.0，或 0xFFFFFF00。

图 4-21 是这三类 IP 地址的网络地址和相应的默认子网掩码。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE12.jpg"/> </div><br>
**子网掩码是一个网络或一个子网的重要属性**。在 RFC950 成为互联网的正式标准后，路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。在路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。若一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码。

为何子网数要除去全 0 和全 1 这两种情况？

看看 RFC950 提到的原因：
假设我们有一个网络：192.168.0.0/24，我们现在需要两个子网，那么按照 RFC950，应该使用使用两位子网号，即 /26，得到两个可以使用的子网 192.168.0.64/26 和 192.168.0.128/26
对于主网络 192.168.0.0/24，网络地址是 192.168.0.0，广播地址是 192.168.0.255
对于子网 192.168.0.0/26（子网号全 0），网络地址是 192.168.0.0，广播地址是 192.168.0.63
对于子网 192.168.0.64/26，网络地址是 192.168.0.64，广播地址是 192.168.0.127
对于子网 192.168.0.128/26，网络地址是 192.168.0.128，广播地址是 192.168.0.191
对于子网 192.168.0.192/26（子网号全 1），网络地址是 192.168.0.192，广播地址是 192.168.0.255

可以看出，对于第一个子网，网络地址和主网络的网络地址是重叠的，对于最后一个子网，广播地址和主网络的广播地址也是重叠的。这样的重叠将导致极大的混乱。比如，一个发往 192.168.0.255 的广播是发给主网络的还是子网的？这就是为什么在当时不建议使用全 0 和全 1 子网。





#### 使用子网时分组的转发

在划分子网的情况下，分组转发的算法必须做相应的改动。

我们应当注意到，使用子网划分后，路由表必须包含以下三项内容：**目的网络地址**、**子网掩码**和**下一跳地址**。

在划分子网的情况下：路由器转发分组的算法如下：

（1）从收到的数据报的首部提取目的 IP 地址 D。

（2）先判断是否为直接交付。对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和 D 诸位相 “与”（AND 操作），看结果是否和相应的网络地址匹配。若匹配，则把分组直接进行交付（当然还需要把 D 转换成物理地址，把数据报封装成帧发送出去），转发任务结束。否则就是间接交付，执行（3）

（3）若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行（4）

（4）若路由表中的每一行（目的网络地址，子网掩码，下一跳地址），用其中的子网掩码和 D 逐位相 “与”（AND 操作），若结果为 N。若 N 与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器；否则，执行（5）。

（5）若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行（6）

（6）报告转发分组出错







#### 无分类编址 CIDR（构造超网）

##### 1.网络前缀

划分子网在一定程度上缓解了互联网在发展中遇到的困难。然而在 1992 年互联网仍然面临三个必须尽早解决的问题，这就是：

（1）B 类地址在 1992 年已分配了近一半，眼看很快就将全部分配完毕！

（2）互联网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）。

（3）整个 IPv4 的地址空间最终将全部耗尽。在 2011 年 2 月 3 日，IANA 宣布 IPv4 地址已经耗尽了。

为了解决前两个问题，IETF 很快就研究出采用**无分类编址**的方法。对于第三个问题，IETF 专门成立了 IPv6 工作组负责研究解决新版本 IP 协议的问题。

其实早在 1987 年，RFC 1009 就指明了在一个划分子网的网络中可同时使用几个不同的子网掩码。

使用**变长子网掩码** VLSM（Variable Length Subnet Mask）可进一步提高 IP 地址资源的利用率。在 VLSM 的基础上又进一步研究出**无分类编址**方法，它的正式名字时**无分类域间路由选择** CIDR（Classless Inter-Domain Routing，CIDR 的读音是 “sider”）。

CIDR 最主要的特点有两个：

（1）CIDR **消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念**，因而能更加有效地分配 IPv4 的地址空间，并且在新的 IPv6 使用之前容许互联网的规模继续增长。CIDR 把 32 位的 IP 地址划分为前后两个部分。前面部分是 “**网络前缀**”（network-prefix）（或简称为 “**前缀**”），用来指明网络，后面部分用来指明主机。因此 CIDR 使 IP 地址从三级编址（使用子网掩码）又回到了两级编址，但这已是**无分类的两级编址**。其记法是：

IP 地址 ::= {<网络前缀>，<主机号>}

CIDR 还使用 “**斜线记法**”（slash notation），或称为 **CIDR** 记法，即在 IP 地址后面加上斜线 “/”，然后写上网络前缀所占的位数。

（2）CIDR 把**网络前缀都相同**的连续的 IP 地址组成一个 “**CIDR 地址块**”。我们只要知道 CIDR 地址块中的任何一个地址，就可以知道这个地址块的起始地址（即最小地址）和最大地址，以及地址块中的地址数。

我们可以用地址块中的最小地址和网络前缀的位数指明这个地址块。

为了更方便地进行路由选择，CIDR 使用 32 位的**地址掩码**（address mask）。地址掩码由一串 1 和一串 0 组成，而 1 的个数就是网络前缀的长度。虽然 CIDR 不使用子网了，但由于目前仍有一些网络还使用子网划分和子网掩码，因此 CIDR 使用的地址掩码也可继续称为**子网掩码**。**斜线记法中，斜线后面的数字就是地址掩码中 1 的个数**。

在之前的分类网络中，IP 地址的分配把 IP 地址的 32 位按每 8 位为一段分开。这使得前缀必须为 8，16 或者 24 位。因此，可分配的最小的地址块有 254 个地址，而这对大多数企业来说太少了。大一点的地址块包含 65534 个地址，而这对大公司来说都太多了。这导致不能充分使用 IP 地址和在路由上的不便，因为大量的需要单独路由的小型网络（C 类网络）因在地域上分得很开而很难进行聚合路由，于是给路由设备增加了很多负担。

无类别域间路由是基于**可变长子网掩码（VLSM）**来进行任意长度的前缀的分配的。在 RFC 950（1985）中有关于可变长子网掩码的说明。CIDR 包括：

- 指定任意长度的前缀的可变长子网掩码技术。遵从CIDR规则的地址有一个后缀说明前缀的位数，例如：192.168.0.0/16。这使得对日益缺乏的IPv4地址的使用更加有效。
- 将多个连续的前缀聚合成**超网**，以及，在互联网中，只要有可能，就显示为一个聚合的网络，因此在总体上可以减少路由表的表项数目。聚合使得互联网的路由表不用分为多级，并通过 VLSM 逆转 “划分子网” 的过程。
- 根据机构的实际需要和短期预期需要而不是分类网络中所限定的过大或过小的地址块来管理 IP 地址的分配的过程。



##### 2.最长前缀匹配

在使用 CIDR 时，由于采用了网络前缀这种记法，IP 地址由网络前缀和主机号这两个部分组成，因此在路由表中的项目也要有相应的改变。这时，每个项目由 “**网络前缀**” 和 “**下一跳地址**” 组成。但是在查找路由表时**可能会得到不止一个匹配结果**。这时**应当从匹配结果中选择具有最长网络前缀的路由**。这就叫做**最长前缀匹配**（longest-prefix matching），这是因为网络前缀越长，其地址块就越小，因而路由就越具体（more specific）。最长前缀匹配又称为**最长匹配**或**最佳匹配**。



##### 3.使用二叉线索查找路由表





#### 网际控制报文协议 ICMP

为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了**网际控制报文协议 ICMP**（Internet Control Message Protocol）。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 是互联网的标准协议。但 ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议。ICMP 报文作为 IP 层数据报的数据，加上数据报的首部，组成 IP 数据报发送出去。ICMP 报文格式如图 4-27 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE14.png"/> </div><br>
##### ICMP 报文的种类

ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。

ICMP 报文的前 4 个字节是统一的格式，共有三个字段：类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。最后面是数据字段，其长度取决于 ICMP 的类型。表 4-8 给出了几种常用的 ICMP 报文类型。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE13.png"/> </div><br>
ICMP 标准在不断更新。已不再使用的 ICMP 报文有：“信息请求与回答报文”、“地址掩码请求与回答报文”、“路由器请求与通告报文” 以及 “源点抑制报文”。现在不再把这几种报文列入。

ICMP 报文的代码字段是为了进一步区分某种类型中的几种不同情况。检验和字段用来检验整个 ICMP 报文。我们应当还记得，IP 数据报首部的检验和并不检验 IP 数据报的内容，因此不能保证经过传输的 ICMP 报文不产生差错。

表 4-8 给出的 ICMP 差错报告报文共有四种，即：

（1）**终点不可达**：当路由器或主机不能交付数据报时就向源点发送终点不可达报文。

（2）**时间超过**：当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。

（3）**参数问题**：当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。

（4）**改变路由（重定向）**：路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）。

下面对改变路由报文进行简短的解释。我们知道，在互联网的主机中也要有一个路由表。当主机要发送数据报时，首先是查找主机自己的路由表，看应当从哪一个接口把数据报发送出去。在互联网中主机的数量远大于路由器的数量，出于效率的考虑，这些主机不和连接在网络上的路由器定期交换路由信息。在主机刚开始工作时，一般都在路由表中设置一个默认路由器的 IP 地址。不管数据报要发送到哪个目的地址，都一律先把数据报传送给这个默认路由器，而这个默认路由器知道到每一个目的网络的最佳路由（通过和其他路由器交换路由信息）。如果默认路由器发现主机发往某个目的地址的数据报的最佳路由应当经过网络上的另一个路由器 R 时，就用改变路由报文把这情况告诉主机。于是，该主机就在其路由表中增加一个项目：到某某目的地址应经过路由器 R（而不是默认路由器）。

所有的 ICMP 差错报告报文中的数据字段都具有同样的格式（图 4-28）。把收到的需要进行差错报告的 IP 数据报的首部和数据字段的前 8 个字节提取出来，作为 ICMP 报文的数据字段。再加上相应的 ICMP 差错报告报文的前 8 个字节，就构成了 ICMP 差错报告报文。提取收到的数据报的数据字段前 8 个字节是为了得到运输层的端口号（对于 TCP 和 UDP）以及运输层报文的发送序号（对于 TCP）。这些信息对源点通知高层协议是有用的。整个 ICMP 报文作为 IP 数据报的数据字段发送给源点。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/网络层 - 图15.jpg"/> </div><br>
下面是不应发送 ICMP 差错报告报文的几种情况。

- 对 ICMP 差错报告报文，不再发送 ICMP 差错报告报文。

- 对第一个分片的数据报片的所有后续数据报片，都不发送 ICMP 差错报告报文。

- 对具有多播地址的数据报，都不发送 ICMP 差错报告报文。

- 对具有特殊地址（如 127.0.0.0 或 0.0.0.0）的数据报，不发送 ICMP 差错报告报文。

  

常用的 ICMP 询问报文有两种，即：

（1）**回送请求和回答**：ICMP 回送请求报文是由主句或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送 ICMP 回送回答报文。这种询问报文用来测试目的站是否可达以及了解其有关状态。

（2）**时间戳请求和回答**：ICMP 时间戳请求报文是请某台主机或路由器回答当前的日期和时间。在 ICMP 时间戳回答报文中有一个 32 位的字段，其中写入的整数代表从 1900 年 1 月 1 日起到当前时刻一共有多少秒。时间戳请求与回答可用于时钟同步和时间测量。





##### ICMP 的应用举例

ICMP 的一个重要应用就是分组网间探测 **PING**（Packet InterNet Groper），用来测试两台主机之间的连通性。PING 使用了 ICMP 回送请求与回送回答报文。PING 是应用层直接使用网络层 ICMP 的一个例子。它没有通过运输层的 TCP 或 UDP。





#### 互联网的路由选择协议

本节将讨论几种常见的路由选择协议，也就是要讨论路由表中的路由是怎样得出的。

##### 有关路由协议的几个基本概念

1.理想的路由算法

路由选择协议的核心就是路由算法，即需要何种算法来获得路由表中的各项目。一个理想的路由算法应具有如下的一些特点：

（1）**算法必须是正确的和完整的**。这里，正确意味着：沿着各路由表所指引的路由，分组一定能够最终达到目的网络和目的主机。

（2）**算法在计算上应简单**。路由选择的计算不应使网络通信量增加太多的额外开销。

（3）**算法应能适应通信量和网络拓扑的变化**，这就是说，要有**自适应性**。当网络中的通信量发生变化时，算法能自适应地改变路由以均衡各链路的负载。当某个或某些节点、链路发生故障不能工作，或者修理好了再投入运行时，算法也能及时地改变路由。有时称这种自适应性为 “**稳健性**”（robustness）。

（4）**算法应具有稳定性**。在网络通信量和网络拓扑相对稳定地情况下，路由算法应收敛于一个可以接受的解，而不应使得出的路由不停地变化。

（5）**算法应是公平的**。路由选择算法应对所有用户（除对少数优先级高的用户）都是平等的。例如，若仅仅使某一对用户的端到端时延为最小，但却不考虑其他的广大用户，这就明显地不符合公平性的要求。

（6）**算法应是最佳的**。路由选择算法应当能够找出最好的路由，使得分组平均时延最小而网络的吞吐量最大。虽然我们希望得到 “最佳” 的算法，但这并不总是最重要的。对于某些网络，网络的可靠性有时要比最小的分组平均时延或最大吞吐量更加重要。因此，**所谓 “最佳” 只能是相对于某一种特定要求下得出的较为合理的选择而已**。

一个实际的路由选择算法，应尽可能接近于理想的算法。再不同的应用条件下，对以上提出的六个方面也可有不同的侧重。

应当指出，路由选择是个非常复杂的问题，因为它是网络中的所有节点共同协调工作的结果。其次，路由选择的环境往往是不断变化的，而这种变化有时无法事先知道，例如，网络中出了某些故障。此外，当网络发生拥塞时，就特别需要能缓解这种拥塞的路由选择策略，但恰好再这种条件下，很难从网络中的各节点获得所需的路由选择信息。

倘若从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，则只有两大类，即**静态路由选择策略**与**动态路由选择策略**。静态路由选择也叫做**非自适应路由选择**，其特点是简单和开销较小，但不能适应网络状态地变化。对于很简单的小网络，完全可以采用静态路由选择，用人工配置每一条路由。动态路由选择也叫做**自适应路由选择**，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。因此，动态路由选择适用于较复杂的大网络。



2.分层次的路由选择协议

互联网采用的路由选择协议主要是自适应的（即动态的）、分布式路由选择协议。由于以下两个原因，互联网采用分层次的路由选择协议：

（1）互联网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会使互联网的通信链路饱和。

（2）许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议（这属于本部门内部的事情），但同时还希望连接到互联网上。

为此，可以把整个互联网划分为许多较小的**自治系统**（autonomous system），一般都记为 AS。自治系统 AS 是在单一技术管理下的一组路由器，而这些路由器使用一种自治系统内部的路由选择协议和共同的度量。一个 AS 对其他 AS 表现出的是**一个单一的和一致的路由选择策略**。

在目前的互联网中，一个大的 ISP 就是一个自治系统。这样，互联网就把路由选择协议划分为两大类，即：

（1）**内部网关协议** IGP（Interior Gateway Protocol）：即在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统使用什么路由选择协议无关。目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。

（2）**外部网关协议** EGP（External Gateway Protocol）：若源主机和目的主机处在不同的自治系统中（这两个自治系统可能使用不同的内部网关协议），当数据报传送到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议 EGP。目前使用最多的外部网关协议是 BGP 的版本 4（BGP-4）。

自治系统之间的路由选择也叫做**域间路由选择**（interdomain routing），而在自治系统内部的路由选择叫做**域内路由选择**（intradomain ）。

对于比较大的自治系统，还可将所有的网络再进行一次划分。例如，可以构筑一个链路速率较高的主干网和许多速率较低的区域网。每个区域网通过路由器连接到主干网。当在一个区域内找不到目的站时，就通过路由器经过主干网到达另一个区域网，或者通过外部路由器到别的自治系统中去找。下面对这两类协议分别进行介绍。





##### 内部网关协议 RIP

1.工作原理

RIP（Routing Information Protocol）是内部网关协议 IGP 中最先得到广泛使用的协议，它的中文名称叫做路由信息协议，但很少被使用。RIP 是一种分布式的**基于距离向量的路由选择协议**，是互联网的标准协议，其最大优点就是简单。

RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的距离记录（因此，这是**一组距离**，即 “**距离向量**”）。RIP 协议将 “**距离**” 定义如下：

从一路由器到直接连接的网络的距离定义为 1。从一路由器到非直接连接的网络的距离定义为所经过的路由器数加 1。“加 1” 是因为到达目的网络后就进行直接交付，而到直接连接的网络的距离已经定义为 1。

RIP 协议的 “距离” 也称为 “**跳数**”（hop count），因为每经过一个路由器，跳数就加 1。RIP 认为好的路由就是它通过的路由器的数目少，即 “距离短”。RIP 允许一条路径最多只能包含 15 个路由器。因此 “距离” 等于 16 时即相当于不可达。可见 **RIP 只适用于小型互联网**。

需要注意的是，到直接连接的网络的距离也可定义为 0（采用这种定义的理由是：路由器在和直接连接到该网络上的主机通信时，不需要经过路由器的距离就应当为 0）。两种不同的定义对实现 RIP 协议并无影响，因为最重要的是要找出最短距离，将所有的距离都加 1 或都减 1，对选择最佳路由其实是一样的。

RIP 不能在两个网络之间同时使用多条路由。RIP 选择一条具有最少路由器的路由（即最短路由），哪怕还存在另一条高速（低时延）但路由器较多的路由。

本节讨论的 RIP 协议和下一节要讨论的 OSPF 协议，都是分布式路由选择协议。它们的共同特点就是每一个路由器都要不断地和其他一些路由器交换路由信息。我们一定要弄清以下三个要点，**即和哪些路由器交换信息**？**交换什么信息**？**在什么时候交换信息**？

RIP 协议的特点是：

（1）**仅和相邻路由器交换信息**。如果两个路由器之间的通信不需要经过另一个路由器，那么这两个路由器就是相邻的。RIP 协议规定，不相邻的路由器不交换信息。

（2）路由器交换的信息是**当前本路由器所知道的全部信息**，**即自己现在的路由表**。也就是说，交换的信息是：“我到本自治系统中所有网络的（最短）距离，以及到每个网络应经过的下一跳路由器”。

（3）**按固定的时间间隔**交换路由信息，例如，每隔 30 秒。然后路由器根据收到的路由信息更新路由表。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。

这里要强调一点：路由器**在刚刚开始工作时**，它的路由表是空的。然后路由器就得出到直接相连的几个网络的距离（这些距离定义为 1）。接着，每一个路由器也只和**数目非常有限的**相邻路由器交换并更新路由信息。但经过若干次的更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。

路由表中最主要的信息就是：到某个网络的距离（即最短距离），以及应经过的下一跳地址。路由表更新的原则是找出到每个目的网络的**最短距离**。这种更新算法又称为**距离向量算法**。下面就是 RIP 协议使用的距离向量算法。



2.距离向量算法

对**每一个相邻路由器**发送过来的 RIP 报文，进行以下步骤：

（1）对地址为 X 的相邻路由器发来的 RIP 报文，先修改此报文中的所有项目：把 “下一跳” 字段中的地址都改为 X，并把所有的 “距离” 字段的值加 1。每一个项目都有三个关键数据，即：到目的网络 N，距离是 d，下一跳路由器是 X。

（2）对修改后的 RIP 报文中的每一个项目，进行以下步骤：

若原来的路由表中没有目的网络 N，则把该项目添加到路由表中。

否则（即在路由表中有目的网络 N，这时就再查看下一跳路由器地址）

​	若下一跳路由器地址是 X，则把收到的项目替换原路由表中的项目。

​	否则（即这个项目是：到目的网络 N，但下一跳路由器不是 X）

​		若收到的项目中的距离 d 小于路由表中的距离，则进行更新，

​		否则什么也不做。



RIP 协议让一个自治系统中的所有路由器都和自己的相邻路由器定期交换路由信息，并不断更新其路由表，使得从**每一个路由器到每一个目的网络的路由都是最短的**（即跳数最少）。这里还应注意：虽然所有的路由器最终都拥有了整个自治系统的全局路由信息，但由于每一个路由器的位置不同，它们的路由表当然也应当是不同的。





3.RIP 协议的报文格式

现在较新的 RIP 版本是 1998 年 11 月公布的 RIP2（已成为互联网标准），新版本协议本身并无多大变化，但性能上有些改进。RIP2 可以支持变长子网掩码和无非类域间路由选择 CIDR。此外，RIP2 还提供简单的鉴别过程支持多播。

图 4-32 是 RIP2 的报文格式，它和 RIP1 的首部相同，但后面的路由部分不一样。从图 4-32 还可看出，RIP 协议使用运输层的用户数据报 UDP 进行传送（使用 UDP 的端口 520）.

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE17.jpg"/> </div><br>
RIP 报文由首部和路由部分组成。

RIP 的首部占 4 个字节，其中的命令字段指出报文的意义。例如，1 表示请求路由信息，2 表示对请求路由信息的响应或未被请求而发出的路由更新报文。首部后面的 “必为 0” 是为了 4 字节字的对齐。

RIP2 报文中的路由部分由若干个路由信息组成。每个路由信息需要用 20 个字节。**地址族标识符**（又称为**地址类别**）字段用来标志所使用的地址协议。如采用 IP 地址就令这个字段的值为 2（原来考虑 RIP 也可用于其他非 TCP/IP 协议的情况）。**路由标记**填入**自治系统号** ASN（Autonomous System Number），这是考虑使 RIP 有可能收到本自治系统以外的路由选择信息。再后面指出某个**网络地址**、该网络的**子网掩码**、**下一跳路由器地址**以及**到此网络的距离**。一个 RIP 报文最多可包括 25 个路由，因而 RIP 报文的最大长度是 4 + 20 * 25 = 504 字节。如超过，必须再用一个 RIP 报文来传送。

RIP2 还具有简单的鉴别功能。若使用鉴别功能，即将原来写入第一个路由信息（20 字节）的位置用作鉴别。这时应将地址标识符置为全 1（即 0xFFFF），而路由标记写入鉴别类型，剩下的 16 字节为鉴别数据。在鉴别数据之后才写入路由信息，但这时最多只能再放入 24 个路由信息。

RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。RIP 协议的这一特点叫做：**好消息传播得块，而坏消息传播得慢**。网络出故障得传播时间往往需要较长得时间（例如数分钟）。这是 RIP 得一个主要缺点。

但如果一个路由器发现了更短的路由，那么这种更新信息就传播得很快。

为了使坏消息传播得更快些，可以次啊去多种措施。例如，让路由器记录收到某特定路由信息得接口，而不让同一路由信息再通过此接口向反方向传送。

总之，RIP 协议最大的优点就是实现简单，开销较小。但 RIP 协议的缺点也较多。首先，RIP 限制了网络的规模，它能使用的最大距离为 15（16表示不可达）。其次，路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。最后，“坏消息传播得慢”，使更新过程的收敛时间过长。因此，对于规模较大的网络就应当使用下一节所述的 OSPF 协议。然而目前再规模较小的网络中，使用 RIP 协议的仍占多数。





##### 内部网关协议 OSPF

1.OSPF 协议的基本特点

这个协议的名字是**开放最短路径优先** OSPF（Open Shortest Path First）。它是为克服 RIP 的缺点在 1989 年开发出来的。OSPF 的原理很简单，但实现起来却较复杂。“**开放**” 表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。“**最短路径优先**” **是因为使用了 Dijkstra 提出的最短路径算法 SPF**。**OSPF 的第二个版本 OSPF2 已成为互联网**标准协议。

OSPF 最主要的特征就是使用分布式的**链路状态协议**（link state protocol），而不是像 RIP 那样的距离向量协议。和 RIP 协议相比，OSPF 的三个要点和 RIP 的都不一样。

（1）向本自治系统中**所有路由器**发送信息。这里使用的方法是**洪泛法**（flooding），这就是路由器通过所有输出端口向所有相邻的路由器发送信息。而每一个相邻路由器又再将此信息发往其所有的相邻路由器（但不再发送给刚刚发来信息的那个路由器）。这样，最终整个区域中所有的路由器都得到了这个信息的一个副本。我们应注意，RIP 协议仅仅是向自己相邻的几个路由器发送信息。

（2）发送的信息就是与本路由器**相邻的所有路由器的链路状态**，但这只是路由器所知道的**部分信息**。所谓 “链路状态” 就是说明本路由器都和哪些路由器相邻，以及该链路的 “**度量**”（metric）。OSPF 将这个 “度量” 用来表示费用、距离、时延、带宽，等等。这些都由网络管理人员决定，因此比较灵活。有时为了方便就称这个度量为 “**代价**”。我们应注意，对于 RIP 协议，发送的信息是：“到所有网络的距离和下一跳路由器”。

（3）只有当链路状态**发生变化时**，路由器才向所有路由器用洪泛法发送此信息。而不像 RIP 那样，不管网络拓扑有无发生变化，路由器之间都要定期交换路由表的信息。

从上述的三个方面可以看出，OSPF 和 RIP 的工作原理相差较大。

由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个**链路状态数据库**（link-state database），这个数据库实际上就是**全网的拓扑结构图**。这个拓扑结构图在全网范围内是**一致的**（这称为**链路状态数据库的同步**）。因此，每一个路由器都知道全网共有多少个路由器，以及哪些路由器是相连的，其代价是多少，等等。每一个路由器使用链路状态数据库中的数据，构造出自己的路由表（例如，使用 SPF 算法）。我们注意到，RIP 协议的每一个路由器虽然知道所有的网络的距离以及下一跳路由器，但却**不知道全网的拓扑结构**（只有到了下一跳路由器，才能知道再下一跳应当怎样走）。

OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。OSPF 的**更新过程收敛得快**是其重要优点。

为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫做区域（area）。图 4-34 就表示一个自治系统划分为四个区域。每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。当然，一个区域也不能太大，在一个区域内的路由器最好不要超过 200 个。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE18.jpg"/> </div><br>
划分区域的好处就是把利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。为了使每一个区域能够和本区域以外的区域进行通信，OSPF 使用**层次结构的区域划分**。在上层的区域叫做**主干区域**（backbone area）。主干区域的标识符规定为 0.0.0.0。主干区域的作用是用来连通其他在下层的区域。从其他区域来的信息都由**区域边界路由器**（area border router）进行概括。在图 4-34 中，路由器 R~3~，R~4~ 和 R~7~ 都是区域边界路由器，而显然，每一个区域至少应当有一个区域边界路由器。在主干区域内的路由器叫做**主干路由器**（backbone router），如 R~3~，R~4~，R~5~，R~6~ 和 R~7~。一个主干路由器可以同时是区域边界路由器，如 R~3~，R~4~ 和 R~7~。在主干区域内还要有一个路由器专门和本自治系统外的其他自治系统交换路由信息。这样的路由器叫做**自治系统边界路由器**（如图中的 R~6~）。

采用分层次划分区域的方法虽然使交换信息的种类增多了，同时也使 OSPF 协议更加复杂了。但这样却能使每一个区域内部交换路由信息的通信量大大减小，因而使 OSPF 协议能够用于规模很大的自治系统中。这里，我们再一次地看到划分层次在网络设计中的重要性。

OSPF 不用 UDP 而是直接用 IP 数据报传送（其 IP 数据报首部的协议字段值为 89）。OSPF 构成的数据报很短。这样做可减少路由信息的通信量。数据报很短的另一好处是可以不必将很长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。

OSPF 分组使用 24 字节的固定长度首部（见图 4-35），分组的数据部分可以是五种类型分组中的一种。下面简单介绍 OSPF 首部各字段的意义。

（1）**版本**：当前的版本号是 2。

（2）**类型**：可以是五种类型分组中的一种。

（3）**分组长度**：包括 OSPF 首部在内的分组长度，以字节为单位。

（4）**路由器标识符**：标志发送该分组的路由器的接口的 IP 地址。

（5）**区域标识符**：分组属于的区域的标识符。

（6）**检验和**：用来检测分组中的差错。

（7）**鉴别类型**：目前只有两种，0（不用）和 1（口令）。

（8）**鉴别**：鉴别类型为 0 时就填入 0，鉴别类型为 1 则填入 8 个字符的口令。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE16.jpg"/> </div><br>
除了以上的几个基本特点外，OSPF 还具有下列的一些特点：

（1）OSPF 允许管理员给每条路由指派不同的代价。例如，高带宽的卫星链路对于非实时的业务可设置为较低的代价，但对于时延敏感的业务就可设置为非常高的代价。因此，OSPF **对于不同类型的业务可计算出不同的路由**。链路的代价可以是 1 至 65535 中的任何一个无量纲的数，因此十分灵活。商用的网络在使用 OSPF 时，通常根据链路带宽来计算链路的代价。这种灵活性是 RIP 所没有的。

（2）如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫做多路径间的**负载平衡**（load balancing）。在代价相同的多条路径上分配通信量是通信量工程中的简单形式。RIP 只能找出到某个网络的一条路径。

（3）所有在 OSPF 路由器之间交换的分组（例如，链路状态更新分组）都具有**鉴别**的功能，因而保证了仅在可信赖的路由器之间交换链路状态信息。

（4）OSPF 支持可变长度的子网划分和无分类的编址 CIDR。

（5）由于网络中链路状态可能经常发生变化，因此 OSPF 让每一个链路状态都带上一个 32 位的**序号**，序号越大状态就越新。OSPF 规定，链路状态序号增长的速率不得超过每 5 秒钟 1 次。这样，全部序号空间在 600 年内不会产生重复号。



2.OSPF 的五种分组类型

OSPF 共有以下五种分组类型：

（1）**类型 1，问候**（Hello）分组，用来发现和维持邻站的可达性

（2）**类型 2，数据库描述**（Database Description）分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。

（3）**类型 3，链路状态请求**（Link State Request）分组，向对方请求发送某些链路状态项目的详细信息。

（4）**类型 4，链路状态更新**（Link State Update）分组，用泛洪法对全网更新链路状态。这种分组是最复杂的，也是 OSPF 协议最核心的部分。路由器使用这种分组将其链路状态通知给邻站。链路状态更新分组共有五种不同的链路状态。

（5）**类型 5，链路状态确认**（Link state Acknowledgment）分组，对链路更新分组的确认。

OSPF 规定，每两个相邻路由器每隔 10 秒钟要交换一次问候分组。这样就能确知哪些邻站是可达的。对相邻路由器来说，“可达” 是最基本的要求，因为只有可达邻站的链路状态信息才存入链路状态数据库（路由表就是根据链路状态数据库计算出来的）。在主场情况下，网络中传送的绝大多数 OSPF 分组都是问候分组。若有 40 秒钟没有收到某个相邻路由器发来的问候分组，则可认为该相邻路由器是不可达的，应立即修改链路状态数据库，并重新计算路由表。

其他的四种分组都是用来进行链路状态数据库的同步。所谓同步就是指不同路由器的链路状态数据库的内容是一样的。两个同步的路由器叫做 “完全邻接的”（fully adjacent）路由器。不是完全邻接的路由器表明它们虽然在物理上是相邻的，但其链路状态数据库并没有达到一致。

当一个路由器刚开始工作时，它只能通过问候分组得知它有哪些相邻的路由器在工作，以及将数据发往相邻路由器所需的 “代价”。如果所有的路由器都把自己的本地链路状态信息对全网进行广播，那么各路由器只要将这些链路状态信息综合起来就可得出链路状态数据库。但这样做开销太大，因此 OSPF 采用下面的办法。

OSPF 让每一个路由器用数据库描述分组和相邻路由器交换本数据库中已有的链路状态摘要信息。摘要信息主要就是指出有哪些路由器的链路状态信息（以及其序号）已经写入了数据库。经过与相邻路由器交换数据库描述分组后，路由器就使用链路状态请求分组，向对方请求发送自己所缺少的某些链路状态项目的详细信息。通过一系列的这种分组交换，全网同步的链路数据库就建立了。图 4-36 给出了 OSPF 的基本操作，说明了两个路由器需要交换各种类型的分组。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE19.jpg"/> </div><br>


在网络运行的过程中，只要有一个路由器的链路状态发生变化，该路由器就要使用链路状态更新分组，用洪泛法向全网更新链路状态。OSPF 使用的是**可靠的洪泛法**。

为了确保链路状态数据库与全网的状态保持一致，OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。

由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时，OSPF 协议要比距离向量协议 RIP 好得多。由于 OSPF 没有 “坏消息传播得慢” 的问题，据统计，其响应网络变化的时间小于 100 ms。

若 N 个路由器连接在一个以太网上，则每个路由器要向其他（N - 1）个路由器发送链路状态信息，因而共有 N（N - 1）个链路状态要在这个以太网上传送。OSPF 协议对这种多点接入的局域网采用了**指定的路由器**（designated router）的方法，使广播的信息量大大减少。指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。





##### 外部网关协议 BGP

1989 年，公布了新的外部网关协议——**边界网关协议** BGP。为简单起见，后面我们把目前使用最多的版本 BGP-4 经常简写为 BGP。

我们首先应当弄清，在不同自治系统 AS 之间的路由选择为什么不能使用前面讨论过的内部网关协议，如 RIP 或 OSPF？

我们知道，内部网关协议（如 RIP 或 OSPF）主要是设法使数据报在一个 AS 中尽可能有效地从源站传送到目的站。在一个 AS 内部也不需要考虑其他方面的策略。然而 BGP 使用的环境却不同。这主要是因为以下的两个原因：

第一，**互联网的规模太大，使得自治系统 AS 之间路由选择非常困难**。连接在互联网主干网上的路由器，必须对任何有效的 IP 地址都能在路由表中找到匹配的目的网络。目前在互联网的主干网路由器中，一个路由表的项目数早已超过了 5 万个网络前缀。如果使用链路状态协议，则每一个路由器必须维持一个很大的链路状态数据库。对于这样大的主干网用 Dijkstra 算法计算最短路径时花费的时间也太长。另外，由于自治系统 AS 各自运行自己选定的内部路由选择协议，并使用本 AS 指明的路径度量，因此，当一条路径通过几个不同 AS 时，要想对这样的路径计算出有意义的代价是不可能的。比较合理的做法是在自治系统之间交换 “**可达性**” 信息（即 “可到达” 或 “不可到达”）。

第二，**自治系统 AS 之间的路由选择必须考虑有关策略**。由于相互连接的网络的性能相差很大，根据最短距离（即最少跳数）找出来的路径，可能并不合适。也有的路径的使用代价很高或很不安全。还有一种情况，如自治系统 AS~1~ 要发送数据报给自治系统 AS~2~，本来最好是经过自治系统 AS~3~。但 AS~3~不愿意让这些数据报通过本自治系统的网络，因为 “这是他们的事情，和我们没有关系。” 但另一方面，自治系统 AS~3~ 愿意让某些相邻自治系统的数据报通过自己的网络，特别是对那些付了服务费的某些自治系统更是如此。因此，自治系统之间的路由选择协议应当允许使用多种路由选择策略。这些策略包括政治、安全或经济方面的考虑。例如，我国国内的站点在互相传送数据报时不应经过国外兜圈子，特鄙视，不要经过某些对我国的安全有威胁的国家。这些策略都是由网络管理人员对每一个路由器进行设置的，但这些策略并不是自治系统之间的路由选择协议本身。

由于上述情况，边界网关协议 BGP 只能是为力求一条能够到达目的网络且**比较好**的路由（不能兜圈子），而**并非要寻找一条最佳路由**。BGP 采用了**路径向量**（path vector）**路由选择协议**，它与距离

向量协议（如 RIP）和链路状态协议（如 OSPF）都有很大的区别。

在配置 BGP 时，每一个自治系统的管理员要选择至少一个路由器作为该自治系统的 “**BGP 发言人**” 。一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是 BGP 边界路由器，但也可以不是 BGP **边界路由器**。

一个BGP 发言人与其他 AS 的 BGP 发言人要交换路由信息，就要先建立 TCP 连接（端口号为 179），然后在此连接上交换 BGP 报文以建立 BGP **会话**（session），利用 BGP 会话交换路由信息，如增加了新的路由，或撤销过时的路由，以及报告出差错的情况等等。使用 TCP 连接能提供可靠的服务，也简化了路由选择协议。使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的**邻站**（neighbor）或**对等站**（peer）。

BGP 协议交换路由信息的结点数量级是自治系统个数的量级，这要比这些自治系统中的网络数少很多。要在许多自治系统之间寻找一条较好的路径，就是要寻找正确的 BGP 发言人（或边界路由器），而在每一个自治系统中 BGP 发言人（或边界路由器）的数目是很少的。这样就使得自治系统之间的路由选择不致过分复杂。

BGP 支持无分类域间路由选择 CIDR，因此 BGP 的路由表也就应当包括目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的自治系统序列。由于使用了路径向量的信息，就可以很容易地避免产生兜圈子的路由。如果一个 BGP 发言人收到了其他 BGP 发言人发来的路径通知，它就要检查一下本自治系统是否在此通知的路径中。如果在这条路径中，就不能采用这条路径（因为会兜圈子）。

在 BGP 刚刚运行时，BGP 的邻站是交换整个的 BGP 路由表。但以后只需要在发生变化时更新有变化的部分。这样做对节省网络带宽和减少路由器的处理开销方面都有好处。

在 RFC 4271 中规定了 BGP-4 的四种报文：

（1）OPEN（打开）报文，用来与相邻的另一个 BGP 发言人建立关系，使通信初始化。

（2）UPDATE（更新）报文，用来通过某一路由的信息，以及列出要撤销的多条路由。

（3）KEEPALIVE（保活）报文，用来周期性地证实邻站的连通性。

（4）NOTIFICATION（通知）报文，用来发送检测到的差错。

若两个邻站属于两个不同 AS，而其中一个邻站打算和另一个邻站定期地交换路由信息，这就应当有一个商谈地过程（因为很可能对方路由器的负荷已很重而不愿意再加重负担）。因此，一开始向邻站进行商谈时就必须发送 OPEN 报文。如果邻站接受这种邻站关系，就用 KEEPALIVE 报文响应。这样，两个 BGP 发言人的邻站关系就建立了。

一旦邻站关系建立了，就要继续维持这种关系。双方中的每一方都需要确信对方是存在的，且一直在保持这种邻站关系。为此，这两个 BGP 发言人彼此要周期性地交换 KEEPALIVE 报文（一般每隔 30 秒）。KEEPALIVE 报文只有 19 字节长（只用 BGP 报文的通用首部），因此不会造成网络上太大的开销。

UPDATE 报文时 BGP 协议的核心内容。BGP 发言人可以用 UPDATE 报文撤销它以前曾经通知过的路由，也可以宣布增加新的路由。撤销路由可以一次撤销许多条，但增加新路由时，每个更新报文只能增加一条。

BGP 可以很容易地解决距离向量算法中的 “坏消息传播得慢” 这一问题。当某个路由器或链路出故障时，由于 BGP 发言人可以从不止一个邻站获得路由信息，因此很容易选择出新的路由。距离向量算法往往不能给出正确的选择，是因为这些算法不能指出哪些邻站到目的站的路由是独立的。

图 4-41 给出了 BGP 报文的格式。四种类型的 BGP 报文具有同样的通用首部，其长度为 19 字节。通用首部分为三个字段。**标记**（marker）字段为 16 字节长，用来鉴别收到的 BGP 报文（这是假定将来有人会发明出合理的鉴别方案）。当不使用鉴别时，标记字段要置为全 1。**长度**字段指出包括通用首部在内的整个 BGP 报文以字节为单位的长度，最小值是 19，最大值是 4096。**类型**字段的值为 1 到 4，分别对应于上述四种 BGP 报文中的一种。

OPEN **报文**共有 6 个字段，即**版本**（1 字节，现在的值是 4）、**本自治系统号**（2 字节，使用全球唯一的 16 位自治系统号，由 ICANN 地区登记机构分配）、**保持时间**（2 字节，以秒计算的保持为邻站关系的时间）、BGP **标识符**（4 字节，通常就是该路由器的 IP 地址）、**可选参数长度**（1 字节）和**可选参数**。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE20.jpg"/> </div><br>


UPDATE **报文**共有 5 个字段，即**不可行路由长度**（2 字节，指明下一个字段的长度）、**撤销的路由**（列出所有要撤销的路由）、**路径属性总长度**（2 字节，指明下一个字段的长度）、**路径属性**（定义在这个报文中增加的路径的属性）和**网络层可达性信息** NLRI（Network Layer Reachablility Information）。最后这个字段定义发出此报文的网络，包括网络前缀的位数、IP 地址前缀。

 KEEPALIVE **报文**只有 BGP 的 19 字节长的通用首部。

NOTIFICATION **报文**有 3 个字段，即差错代码（1 字节）、差错子代码（1 字节）和差错数据（给出有关差错的诊断信息）。



##### 路由器的构成

1.路由器的结构

路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。从路由器的某个输入端口收到的分组，按照分组要去的目的地（即目的网络），把该分组从路由器的某个合适的输出端口转发给下一跳路由器。下一跳路由器也按照这种方法处理分组，直到该分组到达终点为止。路由器的转发分组正是网络层的主要工作。图 4-42 给出了一种典型的路由器的构成框图。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE21.jpg"/> </div><br>


从图 4-42 可以看出，整个的路由器结构可划分为两大部分：**路由选择**部分和**分组转发**部分。

路由选择部分也叫做**控制部分**，其核心构件是路由选择处理机。路由选择处理机的任务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表。

分组转发部分是本节所要讨论的问题，它由三部分组成：**交换结构**、一组**输入端口**和一组**输出端口**（请注意：这里的端口就是硬件接口）。下面分别讨论每一部分的组成。

交换结构（switching fabric）又称为**交换组织**，它的作用就是根据**转发表**（forwarding table）对分组进行处理，将某个输入端口进入的分组从一个合适的输出端口转发出去。交换结构本身就是一种网络，但这种网络完全包含在路由器之中，因此交换结构可看成是 “在路由器中的网络”。

请注意 “转发” 和 “路由选择” 是有区别的。在互联网中，“**转发**” 就是路由器根据转发表把收到的 IP 数据报从路由器合适的端口转发出去。“转发” 仅仅涉及到一个路由器。但 “**路由选择**” 则涉及到很多路由器，路由表则是许多路由器协同工作的结果。这些路由器按照复杂的路由算法，得出整个网络的拓扑变化情况，因而能够动态地改变所选择的路由，并由此构造出整个的路由表。路由表一般仅包含从目的网络到下一跳（用 IP 地址表示）的映射，而转发表是从路由表得出的。转发表必须包含完成转发功能所必需的信息。这就是说，在转发表的每一行必须包含从要到达的目的网络到输出端口和某些 MAC 地址信息（如下一跳的以太网地址）的映射。将转发表和路由表用不同的数据结构实现会带来一些好处，这是因为在转发分组时，转发表的结构应当使查找过程最优化，但路由表则需要对网络拓扑变化的计算最优化。路由表总是用软件实现的，但转发表则甚至可用特殊的硬件来实现。**在讨论路由选择的原理时，往往不去区别转发表和路由表的区别，而可以笼统地都使用路由表这一名词**。

在图 4-42 中，路由器地输入和输出端口里面都各有三个方框，用方框中的 1，2 和 3 分别代表物理层、数据链路层和网络层的处理模块。物理层进行比特的接收。数据链路层则按照链路层协议接收传送分组的帧。在把帧的首部和尾部剥去后，分组就被送入网络层的处理模块。若接收到的分组是路由器之间交换路由信息的分组（如 RIP 或 OSPF 分组等），则把这种分组送交路由器的路由选择部分中的路由选择处理机。若接收到的是数据分组，则按照分组首部中的目的地址查找转发表，根据得出的结果，分组就经过交换结构到达合适的输出端口。一个路由器的输入端口和输出端口就做在路由器的**线路接口卡**上。

输入端口中的查找和转发功能在路由器的交换功能中是最重要的。为了使交换功能分散化，往往把复制的转发表放在每一个输入端口中（如图 4-22 中的虚线箭头所示）。路由选择处理机负责对各转发表的副本进行更新。这些副本常称为 “**影子副本**”（shadow copy）。分散化交换可以避免在路由器中的某一点上出现瓶颈。

以上介绍的查找转发表和转发分组的概念虽然并不复杂，但在具体的实现中还是会遇到不少困难。问题就在于路由器必须以很高的速率转发分组。最理想的情况是输入端口的处理速率能够跟上线路把分组传送到路由器的速率。这种速率称为**线速**（line speed 或 wire speed）。设线路是 OC-48 链路，即 2.5 Gbit/s。若分组长度为 256 字节，那么线速就应当达到每秒能够处理 100 万以上的分组。现在常用 Mpps（百万分组每秒）为单位来说明一个路由器对收到的分组的处理速率有多高。在路由器的设计中，怎样提高查找转发表的速率是一个十分重要的研究课题。

当一个分组正在查找转发表时，后面又紧跟着从这个输入端口收到另一个分组。这个后到的分组就必须在队列中排队等候，因而产生了一定的时延。图 4-43 给出了在输入端口的队列中排队的分组的示意图。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE22.jpg"/> </div><br>


我们再来观察在输出端口上的情况（图 4-44）。输出端口从交换结构接收分组，然后把它们发送到路由器外面的线路上。在网络层的处理模块中设有一个缓冲区，实际上它就是一个队列。当交换结构传送过来的分组的速率超过输出链路的发送速率时，来不及发送的分组就必须暂时存放在这个队列中。数据链路层处理模块把分组加上链路层的首部和尾部，交给物理层后发送到外部线路。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE26.jpg"/> </div><br>


从以上的讨论可以看出，分组在路由器的输入端口和输出端口都可能会在队列中排队等候处理。若分组处理的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。以前我们提到过的分组丢失就是发生再路由器中的输入或输出队列产生溢出的时候。当然，设备或线路出故障也可能使分组丢失。



2.交换结构

交换结构是路由器的关键构建。正是这个交换结构把分组从一个输入端口转移到某个合适的输出端口。实现这样的交换有多种方法，图 4-45 给出了三种常用的交换方法。这三种方法都是将输入端口 I~1~ 收到的分组转发到输出端口 O~2~。下面简单介绍它们的特点。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE23.jpg"/> </div><br>


最早使用的路由器就是利用普通的计算机，用计算机的 CPU 作为路由器的路由选择处理机。路由器的输入和输出端口的功能和传统的操作系统中的 I/O 设备一样。当路由器的某个输入端口收到一个分组时，就用中断方式通知路由选择处理机。然后分组就从输入端口复制到存储器中。路由器处理机从分组首部提取目的地址，查找路由表，再将分组复制到合适的输出端口的缓存中。若存储器的带宽（读或写）为每秒 M 个分组，那么路由器的交换速率（即分组从输入端口传送到输出端口的速率）一定小于 M/2。这是因为存储器对分组的读和写需要花费的时间是同一个数量级。

许多现代的路由器也通过存储器进行交换，图 4-45（a）的示意图表示分组通过存储器进行交换。与早期的路由器的区别就是，目的地址的查找和分组在存储器中的缓存都是在输入端口中进行的。Cisco 公司的 Catalyst 8500 系列交换机（有的公司把路由器也成为交换机）和 Bay Network 公司的 Accelar 1200 系列路由器就采用了共享存储器的方法。

图 4-45（b）是通过总线进行交换的示意图。采用这种方式时，数据报从输入端口通过共享的总线直接传送到合适的输出端口，而不需要路由选择处理机的干预。但是，由于总线是共享的，因此在同一时间只能有一个分组在总线上传送。当分组到达输入端口时若发现总线忙（因为总线正在传送另一个分组），而被阻塞而不能通过交换结构，并在输入端口排队等待。因为每一个要转发的分组都要通过这一条总线，因而路由器的转发带宽就受总线速率的限制。现代的技术已经可以将总线的带宽提高到每秒吉比特的速率，因此许多的路由器产品都采用这种通过总线的交换方式。例如，Cisco 公司的 Catalyst 1900 系列交换机就使用了带宽达到 1 Gbit/s 的总线。

图 4-45（c）画的是通过纵横交换结构（crossbar switch fabric）进行交换。这种交换结构常称为**互联网络**（interconnection network），它有 2N 条总线，可以使 N 个输入端口和 N 个输出端口相连接，这取决于相应的交叉节点是使水平总线和垂直总线接通还是断开。当输入端口收到一个分组时，就将它发送到与该输入端口相连的水平总线上。若通向所要转发的输出端口的垂直总线是空闲的，则在这个节点将垂直总线与水平总线接通，然后将该分组转发到这个输出端口。但若该垂直总线已被占用（有另一个分组正在转发到同一个输出端口），则后到的分组就被阻塞，必须在输入端口排队。采用这种交换方式的路由器例子是 Cisco 公司的 12000 系列交换路由器，它使用的互连网络的带宽达 60 Gbit/s。





#### IPv6

IP 是互联网的核心协议。现在使用的 IP（即 IPv4）是在 20 世纪 70 年代末期设计的。互联网经过几十年的飞速发展，到 2011 年 2 月，IPv4 的地址已经耗尽，ISP 已经不能再申请到新的 IP 地址块了。我国在 2014 年至 2015 年也逐步停止了向新用户和应用分配 IPv4 地址，同时全面开始商用部署 IPv6。

解决 IP 地址耗尽的根本措施就是采用具有更大地址空间的新版本的 IP，即 IPv6。

现今的互联网络发展蓬勃，截至 2018 年 1 月，全球上网人数已达 40.21 亿，IPv4 仅能提供约 42.9 亿个 IP 位置。虽然当前的网络地址转换及无类别域间路由等技术可延缓网络位置匮乏之现象，但为求解决根本问题，从 1990 年开始，互联网工程工作小组开始规划 IPv4 的下一代协议，除要解决即将遇到的 IP 地址短缺问题外，还要发展更多的扩展，为此 IETF 小组创建 IPng，以让后续工作顺利进行。1994年，各 IPng 领域的代表们于多伦多举办的 IETF 会议中，正式提议 **IPv6** 发展计划，该提议直到同年的 11 月 17 日才被认可，并于 1996 年 8 月 10 日成为 IETF 的草案标准，最终 IPv6 在 1998 年 12 月由互联网工程工作小组以互联网标准规范（RFC 2460）的方式正式公布。

IPv6 的计划是创建未来互联网扩展的基础，其目标是取代 IPv4，虽然 IPv6 在 1994 年就已被 IETF 指定作为 IPv4 的下一代标准，由于早期的路由器、防火墙、企业的企业资源计划系统及相关应用程序皆须改写，所以在世界范围内使用 IPv6 部署的公众网与 IPv4 相比还非常的少，技术上仍以双架构并存居多。预计在 2025 年以前 IPv4 仍会被支持，以便给新协议的修正留下足够的时间。

IPv6 能解决的核心问题与互联网当前所面临的关键问题之间出现了明显的偏差，难以给互联网的发展带来革命性的影响。与 IPv4 的各种地址复用解决方案相比，IPv6 能够降低复杂性和成本，然而当前却只有制造商较能够感受到这个优势，用户和运营商无法直接感受到，导致产业链缺乏推动 IPv6 的动力。



##### IPv6 的基本首部

IPv6 仍支持无连接的传送，但将协议数据单元 PDU 称为分组，而不是 IPv4 的数据报。为方便起见，本节仍用数据报这一名词。

IPv6 所引进的主要变化如下：

（1）**更大的地址空间**。IPv6 把地址从 IPv4 的 32 位增大到 4 倍，即增大到 128 位，使地址空间增大了 2^96^ 倍。这样大的地址空间在可预见的将来是不会用完的。

（2）**扩展的地址层次结构**。IPv6 由于地址空间很大，因此可以划分为更多的层次。

（3）**灵活的首部格式**。IPv6 数据报的首部和 IPv4 的并不兼容。IPv6 定义了许多可选的扩展首部，不仅可提供比 IPv4 更多的功能，而且还可提高路由器的处理效率，这是因为路由器对扩展首部不进行处理（除逐跳扩展首部外）。

（4）**改进的选项**。IPv6 允许数据报包含有选项的控制信息，因而可以包含一些新的选项。但 IPv6 的**首部长度是固定的**，其选项放在有效载荷中。我们知道，IPv4 所规定的选项是固定不变的，其选项放在首部的可变部分。

（5）**允许协议继续扩充**。这一点很重要，因为技术总是在不断地发展（如网络硬件的更新）而新的应用也还会出现。但我们知道，IPv4 的功能是固定不变的。

（6）允许即插即用（即自动配置）。因此 IPv6 不需要使用 DHCP。

（7）**支持资源的预分配**。IPv6 支持实时视像等要求保证一定的带宽和时延的应用。

（8）IPv6 首部改为 8 **字节对齐**（即首部长度必须是 8 字节的整数倍）。原来的 IPv4 首部是 4 字节对齐。

IPv6 数据报由两大部分组成，即**基本首部**（base header）和后面的**有效载荷**（payload）。有效载荷也成为**净负荷**。有效载荷允许有零个或多个**扩展首部**（extension header），再后面是数据部分（图 4-46）。但请注意，所有的扩展首部并不属于 IPv6 数据报的首部。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE24.jpg"/> </div><br>


与 IPv4 相比，IPv6 对首部中的某些字段进行了如下的更改：

- 取消了首部长度字段，因为它的首部长度是固定的（40 字节）。
- 取消了服务类型字段，因为优先级和流标号字段实现了服务类型字段的功能。
- 取消了总长度字段，改用有效载荷长度字段。
- 取消了标识、标志和片偏移字段，因为这些功能已包含再分片扩展首部中。
- 把 TTL 字段改称为跳数限制字段，但作用是一样的（名称与作用更加一致）。
- 取消了协议字段，改用下一个首部字段。
- 取消了检验和字段，这样就加快了路由器处理数据报的速度。我们知道，在数据链路层对检测出有差错的帧就丢弃。在运输层，当使用 UDP 时，若检测出有差错的用户数据报就丢弃。当使用 TCP 时，对检测出有差错的报文段就重传，直到正确传送到目的进程为止。因此在网络层的差错检测可以精简掉。
- 取消了选项字段，而用扩展首部来实现选项功能。

由于在首部中不必用的功能取消了，使得 IPv6 首部的字段数减少到只有 8 个（虽然首部长度增大了一倍）。

下面解释 IPv6 基本首部中各字段的作用（参见图 4-47）。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9B%BE25.jpg"/> </div><br>


（1）**版本**（version）：占 4 位。它指明了协议的版本，对 IPv6 该字段是 6。

（2）**通信量类**（traffic class）：占 8 位。这是为了区分不同的 IPv6 数据报的类别或优先级。目前正在进行不同的通信类性能的实验。

（3）**流标号**（flow label）：占 20 位。IPv6 的一个新的机制是支持资源预分配，并且允许路由器把每一个数据报与一个给定的资源分配相联系。IPv6 提出**流**（flow）的抽象概念。所谓 “**流**” **就是互联网络上从特点源点到特点终点（单播或多播）的一系列数据报（如实时音频或视频传输），而在这个 “流” 所经过的路径上的路由器都保证指明的服务质量**。所有属于同一个流的数据报都具有同样的流标号。因此，流标号对实时音频/视频数据的传送特别有用。对于传统的电子邮件或非实时数据，流标号则没有用处，把它置为 0 即可。

（4）**有效载荷长度**（payload length）：占 16 位。它指明 IPv6 数据报除基本首部以外的字节数（所有扩展首部都算在有效载荷之内）。这个字段的最大值是 64 KB（65535 字节）。

（5）**下一个首部**（next header）：占 8 位。它相当于 IPv4 的协议字段或可选字段。

- 当 IPv6 数据报没有扩展首部时，下一个首部字段的作用和 IPv4 的协议字段一样，它的值指出了基本首部后面的数据应交付 IP 层上面的哪一个高层协议（例如：6 或 17 分别表示应交付运输层 TCP 或 UDP）。

- 当出现扩展首部时，下一个首部字段的值就标识后面第一个扩展首部的类型。

（6）**跳数限制**（hop limit）：占 8 位。用来防止数据报在网络中无限期地存在。源点每个数据报发出时即设定某个跳数限制（最大为 255 跳）。每个路由器在转发数据报时，要先把跳数限制字段中的值减 1。当跳数限制的值为零时，就要把这个数据报丢弃。

（7）**源地址**：占 128 位。是数据包的发送端的 IP 地址。

（8）**目的地址**：占 128 位。是数据报的接收端的 IP 地址。

下面介绍一下 IPv6 的扩展首部。

大家知道，IPv4 的数据报如果在其首部中使用了选项，那么沿着数据报传送的路径上的每一个路由器都必须对这些选项一一进行检查，这就降低了路由器处理数据报的速度。然而实际上很多的选项在途中的路由器上是不需要检查的（因为不需要使用这些选项的信息）。IPv6 把原来 IPv4 首部中选项的功能都放在扩展首部中，并把扩展首部留给路径两端的源点和终点的主机来处理，而数据报途中经过的**路由器都不处理这些扩展首部**（只有一个首部例外，即逐跳选项扩展首部），这样就**大大提高了路由器的处理效率**。

在 RFC 2460 中定义了以下六种扩展首部：（1）逐跳选项；（2）路由选择；（3）分片；（4）鉴别；（5）封装安全有效子载荷；（6）目的站选项。

每一个扩展首部都由若干个字段组成，它们的长度也各不同。但所有扩展首部的第一个字段都是 8 位的 “下一个首部” 字段。此字段的值指出了在该扩展首部后面的字段是什么。当使用多个扩展首部时，应按以上的先后顺序出现。高层首部总是放在最后面。





##### IPv6 的地址

一般来讲，一个 IPv6 数据报的目的地址可以是以下三种基本类型地址之一：

（1）**单播**（unicast）：单播就是传统的点对点通信。

（2）**多播**（multicast）：多播是一点对多点的通信，数据报发送到一组计算机中的每一个。IPv6 没有采用广播的术语，而是将广播看作多播的一个特例。

（3）**任播**（anycast）：这是 IPv6 增加的一种类型。任播的终点是一组计算机，但数据报只交付其中的一个，通常是距离最近的一个。

IPv6 把实现 IPv6 的主机和路由器均称为**结点**。由于一个结点可能会使用多条链路与其他的一些结点相连，因此一个结点可能有多个与链路相连的接口。这样，IPv6 给结点的每一个接口指派一个 IP 地址。一个结点可以有多个单播地址，而其中任何一个地址都可以当作到达该结点的目的地址。

在 IPv6 中，每个地址占 128 位，地址空间大于 3.4✖10^38^ 。如果整个地球表明（包括陆地和水面）都覆盖着计算机，那么 IPv6 允许每平方米拥有 7✖10^23^ 个 IP 地址。如果地址分配速率是每微秒分配 100 万个地址，则需要 10^19^ 年的时间才能将所有可能的地址分配完毕。可见在想象到的将来，IPv6 的地址空间是不可能用完的。

巨大的地址范围还必须使维护互联网的人易于阅读和操纵这些地址。IPv4 所用的点分十进制法现在也不够方便了。例如，一个用点分十进制记法的 128 位的地址为：

104.230.140.100.255.255.255.255.0.0.17.128.150.10.255.255

为了使地址再稍简洁些，IPv6 使用**冒号十六进制记法**（colon hexadecimal notation，简写为 colon hex），它把每个 16 位的值用十六进制值表示，各值之间用冒号分隔。例如，如果前面所给的点分十进制数记法的值改为冒号十六进制记法，就变成了：

68E6:8C64:FFFF:FFFF:0:1180:960A:FFFF



























