## Redis开发与运维读书笔记

### 第1章　初识Redis



#### 1.1　盛赞Redis

Redis 是一种基于键值对（key-value）的 NoSQL 数据库，与很多键值对数据库不同的是，Redis中的值可以是由 string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位）等多种数据结构和算法组成，因此 Redis 可以满足很多的应用场景，而且因为Redis会将所有数据都存放在内存中，所以它的读写性能非常惊人。不仅如此，Redis 还可以将内存的数据利用快照和日志的形式保存到硬盘上，这样在发生类似断电或者机器故障的时候，内存中的数据不会 “丢失”。除了上述功能以外，Redis 还提供了键过期、发布订阅、事务、流水线、Lua 脚本等附加功能。总之，如果在合适的场景使用好 Redis，它就会像一把瑞士军刀一样所向披靡。

2008 年，Redis 的作者 Salvatore Sanfilippo 在开发一个叫 LLOOGG 的网站时，需要实现一个高性能的队列功能，最开始是使用 MySQL 来实现的，但后来发现无论怎么优化 SQL 语句都不能使网站的性能提高上去，再加上自己囊中羞涩，于是他决定自己做一个专属于 LLOOGG 的数据库，这个就是 Redis 的前身。后来，Salvatore Sanfilippo 将 Redis1.0 的源码开放到 GitHub 上，可能连他自己都没想到，Redis 后来如此受欢迎。



#### 1.2　Redis特性

Redis 之所以受到如此多公司的青睐，必然有之过人之处，下面是关于 Redis 的 8 个重要特性。

**1.速度快**

正常情况下，Redis 执行命令的速度非常快，官方给出的数字是读写性能可以达到 10万/秒，当然这也取决于机器的性能，但这里先不讨论机器性能上的差异，只分析一下是什么造就了 Redis 如此之快的速度，可以大致归纳为以下四点：

- Redis 的所有数据都是存放在内存中的，表 1-1 是谷歌公司 2009 年给出的各层级硬件执行速度，所以把数据放在内存中是Redis速度快的最主要原因。
- Redis 是用 C 语言实现的，一般来说 C 语言实现的程序 “距离” 操作系统更近，执行速度相对会更快。
- Redis 使用了单线程架构，预防了多线程可能产生的竞争问题。
- 作者对于 Redis 源代码可以说是精打细磨，曾经有人评价 Redis 是少有的集性能和优雅于一身的开源代码。



**2.基于键值对的数据结构服务器**

几乎所有的编程语言都提供了类似字典的功能，例如 Java 里的 map、Python 里的 dict，类似于这种组织数据的方式叫作基于键值的方式，与很多键值对数据库不同的是，Redis 中的值不仅可以是字符串，而且还可以是具体的数据结构，这样不仅能便于在许多应用场景的开发，同时也能够提高开发效率。Redis 的全称是 REmote Dictionary Server，它主要提供了 5 种数据结构：字符串、哈希、列表、集合、有序集合，同时在字符串的基础之上演变出了位图（Bitmaps）和 HyperLogLog 两种神奇的 “数据结构”，并且随着 LBS（Location Based Service，基于位置服务）的不断发展，Redis3.2 版本中加入有关 GEO（地理信息定位）的功能，总之在这些数据结构的帮助下，开发者可以开发出各种 “有意思” 的应用。



**3.丰富的功能**

除了 5 种数据结构，Redis 还提供了许多额外的功能：

- 提供了键过期功能，可以用来实现缓存。
- 提供了发布订阅功能，可以用来实现消息系统。
- 支持 Lua 脚本功能，可以利用 Lua 创造出新的 Redis 命令。
- 提供了简单的事务功能，能在一定程度上保证事务特性。
- 提供了流水线（Pipeline）功能，这样客户端能将一批命令一次性传到 Redis，减少了网络的开销。



**4.简单稳定**

Redis 的简单主要表现在三个方面。首先，Redis 的源码很少，早期版本的代码只有 2 万行左右，3.0 版本以后由于添加了集群特性，代码增至 5 万行左右，相对于很多 NoSQL 数据库来说代码量相对要少很多，也就意味着普通的开发和运维人员完全可以 “吃透” 它。其次，Redis 使用单线程模型，这样不仅使得 Redis 服务端处理模型变得简单，而且也使得客户端开发变得简单。最后，Redis 不需要依赖于操作系统中的类库（例如 Memcache 需要依赖 libevent 这样的系统类库），Redis 自己实现了事件处理的相关功能。

Redis 虽然很简单，但是不代表它不稳定。以笔者维护的上千个 Redis 为例，没有出现过因为 Redis 自身 bug 而宕掉的情况。



**5.客户端语言多**

Redis 提供了简单的 TCP 通信协议，很多编程语言可以很方便地接入到 Redis，并且由于 Redis 受到社区和各大公司的广泛认可，所以支持 Redis 的客户端语言也非常多，几乎涵盖了主流的编程语言，例如 Java、PHP、Python、C、C++、Nodejs 等，第 4 章我们将对 Redis 的客户端进行详细说明。



**6.持久化**

通常看，将数据放在内存中是不安全的，一旦发生断电或者机器故障，重要的数据可能就会丢失，因此 Redis 提供了两种持久化方式：RDB 和 AOF，即可以用两种策略将内存的数据保存到硬盘中（如图 1-1 所示），这样就保证了数据的可持久性，第 5 章我们将对 Redis 的持久化进行详细说明。







**7.主从复制**

Redis 提供了复制功能，实现了多个相同数据的 Redis 副本（如图 1-2 所示），复制功能是分布式 Redis 的基础。第 6 章我们将对 Redis 的复制进行详细说明。



**8.高可用和分布式**

Redis 从 2.8 版本正式提供了高可用实现 Redis Sentinel，它能够保证 Redis 节点的故障发现和故障自动转移。Redis 从 3.0 版本正式提供了分布式实现 Redis Cluster，它是 Redis 真正的分布式实现，提供了高可用、读写和容量的扩展性。



#### 1.3　Redis使用场景

上节我们已经了解了 Redis 的若干个特性，本节来看一下 Redis 的典型应用场景有哪些？



##### 1.3.1　Redis可以做什么

**1.缓存**

缓存机制几乎在所有的大型网站都有使用，合理地使用缓存不仅可以加快数据的访问速度，而且能够有效地降低后端数据源的压力。Redis 提供了键值过期时间设置，并且也提供了灵活控制最大内存和内存溢出后的淘汰策略。可以这么说，一个合理的缓存设计能够为一个网站的稳定保驾护航。第 11 章将对缓存的设计与使用进行详细说明。

**2.排行榜系统**

排行榜系统几乎存在于所有的网站，例如按照热度排名的排行榜，按照发布时间的排行榜，按照各种复杂维度计算出的排行榜，Redis 提供了列表和有序集合数据结构，合理地使用这些数据结构可以很方便地构建各种排行榜系统。

**3.计数器应用**

计数器在网站中的作用至关重要，例如视频网站有播放数、电商网站有浏览数，为了保证数据的实时性，每一次播放和浏览都要做加1的操作，如果并发量很大对于传统关系型数据的性能是一种挑战。Redis 天然支持计数功能而且计数的性能也非常好，可以说是计数器系统的重要选择。

**4.社交网络**

赞/踩、粉丝、共同好友/喜好、推送、下拉刷新等是社交网站的必备功能，由于社交网站访问量通常比较大，而且传统的关系型数据不太适合保存这种类型的数据，Redis提供的数据结构可以相对比较容易地实现这些功能。

**5.消息队列系统**

消息队列系统可以说是一个大型网站的必备基础组件，因为其具有业务解耦、非实时业务削峰等特性。Redis提供了发布订阅功能和阻塞队列的功能，虽然和专业的消息队列比还不够足够强大，但是对于一般的消息队列功能基本可以满足。



##### 1.3.2　Redis不可以做什么

实际上和任何一门技术一样，每个技术都有自己的应用场景和边界，也就是说 Redis 并不是万金油，有很多适合它解决的问题，但是也有很多不合适它解决的问题。我们可以站在数据规模和数据冷热的角度来进行分析。

站在数据规模的角度看，数据可以分为大规模数据和小规模数据，我们知道 Redis 的数据是存放在内存中的，虽然现在内存已经足够便宜，但是如果数据量非常大，例如每天有几亿的用户行为数据，使用 Redis 来存储的话，基本上是个无底洞，经济成本相当的高。

站在数据冷热的角度看，数据分为热数据和冷数据，热数据通常是指需要频繁操作的数据，反之为冷数据，例如对于视频网站来说，视频基本信息基本上在各个业务线都是经常要操作的数据，而用户的观看记录不一定是经常需要访问的数据，这里暂且不讨论两者数据规模的差异，单纯站在数据冷热的角度上看，视频信息属于热数据，用户观看记录属于冷数据。如果将这些冷数据放在 Redis 中，基本上是对于内存的一种浪费，但是对于一些热数据可以放在 Redis 中加速读写，也可以减轻后端存储的负载，可以说是事半功倍。

所以，Redis 并不是万金油，相信随着我们对 Redis 的逐步学习，能够清楚 Redis 真正的使用场景。



#### 1.4　用好Redis的建议

**1.切勿当作黑盒使用，开发与运维同样重要**

很多使用Redis的开发者认为只要会用API开发相应的功能就可以，更有甚者认为Redis就是get、set、del，不需要知道Redis的原理。但是在我们实际运维和使用Redis的过程中发现，很多线上的故障和问题都是由于完全把Redis当做黑盒造成的，如果不了解Redis的单线程模型，有些开发者会在有上千万个键的Redis上执行keys*操作，如果不了解持久化的相关原理，会在一个写操作量很大的Redis上配置自动保存RDB。而且在很多公司内只有专职的关系型数据库DBA，并没有NoSQL的相关运维人员，也就是说开发者很有可能会自己运维Redis，对于Redis的开发者来说既是好事又是坏事。站在好的方面看，开发人员可以通过运维Redis真正了解Redis的一些原理，不
单纯停留在开发上。站在坏的方面看，Redis的开发人员不仅要支持开发，还要承担运维的责任，而且由于运维经验不足可能会造成线上故障。但是从实际经验来看，运维足够规模的Redis会对用好Redis更加有帮助。



**2.阅读源码**

我们在前面提到过，Redis是开源项目，由于作者对Redis代码的极致追求，Redis的代码量相对于许多NoSQL数据库来说是非常小的，也就意味着作为普通的开发和运维人员也是可以“吃透”Redis的。通过阅读优秀的源码，不仅能够加深我们对于Redis的理解，而且还能提高自身的编码水平，
甚至可以对Redis做定制化，也就是说可以修改Redis的源码来满足自身的需求，例如新浪微博在Redis的早期版本上做了很多的定制化来满足自身的需求，豌豆荚也开源基于Proxy的Redis分布式实现Codis。



#### 1.5　正确安装并启动Redis

略



#### 1.6　Redis重大版本

略



#### 1.7　本章重点回顾

1）Redis的8个特性：速度快、基于键值对的数据结构服务器、功能丰富、简单稳定、客户端语言多、持久化、主从复制、支持高可用和分布式。

2）Redis并不是万金油，有些场景不适合使用Redis进行开发。

3）开发运维结合以及阅读源码是用好Redis的重要方法。

4）生产环境中使用配置文件启动Redis。

5）生产环境选取稳定版本的Redis。

6）Redis3.0是重要的里程碑，发布了Redis官方的分布式实现Redis Cluster。





### 第2章　API的理解和使用

Redis 提供了 5 种数据结构，理解每种数据结构的特点对于 Redis 开发运维非常重要，同时掌握Redis的单线程命令处理机制，会使数据结构和命令的选择事半功倍，本章内容如下：

- 预备知识：几个简单的全局命令，数据结构和内部编码，单线程命令处理机制分析。
- 5 种数据结构的特点、命令使用、应用场景。
- 键管理、遍历键、数据库管理。
  

#### 2.1　预备

在正式介绍 5 种数据结构之前，了解一下 Redis 的一些全局命令、数据结构和内部编码、单线程命令处理机制是十分有必要的，它们能为后面内容的学习打下一个好的基础，主要体现在两个方面：第一、Redis 的命令有上百个，如果纯靠死记硬背比较困难，但是如果理解 Redis 的一些机制，会发现这些命令有很强的通用性。第二、Redis 不是万金油，有些数据结构和命令必须在特定场景下使用，一旦使用不当可能对 Redis 本身或者应用本身造成致命伤害。



##### 2.1.1　全局命令

Redis 有 5 种数据结构，它们是键值对中的值，对于键来说有一些通用的命令。

**1.查看所有键**

keys *

keys*命令会将所有的键输出：



**2.键总数**

dbsize

dbsize 命令在计算键总数时不会遍历所有键，而是直接获取 Redis 内置的键总数变量，所以 dbsize 命令的时间复杂度是 O（1）。而 keys 命令会遍历所有键，所以它的时间复杂度 O（n），当 Redis 保存了大量键时，线上环境禁止使用。



**3.检查键是否存在**

exists key

如果键存在则返回 1，不存在则返回 0：



**4.删除键**
del key [key ...]

del 是一个通用命令，无论值是什么数据结构类型，del 命令都可以将其删除。

返回结果为成功删除键的个数，假设删除一个不存在的键，就会返回 0

同时 del 命令可以支持删除多个键：

del a b c



**5.键过期**

expire key seconds

Redis 支持对键添加过期时间，当超过过期时间后，会自动删除键，例如为键 hello 设置了 10 秒过期时间：

set hello world

expire hello 10

ttl 命令会返回键的剩余过期时间，它有 3 种返回值：

- 大于等于 0 的整数：键剩余的过期时间。

- -1：键没设置过期时间。

- -2：键不存在

有关键过期更为详细的使用以及原理会在 2.7 节介绍。



**6.键的数据结构类型**

type key

如果键不存在，则返回none



##### 2.1.2　数据结构和内部编码

type 命令实际返回的就是当前键的数据结构类型，它们分别是：string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合），但这些只是 Redis 对外的数据结构，如图 2-1 所示。

实际上每种数据结构都有自己底层的内部编码实现，而且是多种实现，这样 Redis 会在合适的场景选择合适的内部编码，如图 2-2 所示。

可以看到每种数据结构都有两种以上的内部编码实现，例如 list 数据结构包含了 linkedlist 和 ziplist 两种内部编码。同时有些内部编码，例如 ziplist，可以作为多种外部数据结构的内部实现，可以通过 object encoding 命令查询内部编码：







Redis 这样设计有两个好处：第一，可以改进内部编码，而对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动外部数据结构和命令，例如 Redis3.2 提供了 quicklist，结合了 ziplist 和 linkedlist 两者的优势，为列表类型提供了一种更为优秀的内部编码实现，而对外部用户来说基本感知不到。第二，多种内部编码实现可以在不同场景下发挥各自的优势，例如 ziplist 比较节省内存，但是在列表元素比较多的情况下，性能会有所下降，这时候 Redis 会根据配置选项将列表类型的内部实现转换为 linkedlist。



##### 2.1.3　单线程架构

Redis使用了单线程架构和I/O多路复用模型来实现高性能的内存数据库服务，本节首先通过多个客户端命令调用的例子说明Redis单线程命令处理机制，接着分析Redis单线程模型为什么性能如此之高，最终给出为什么理解单线程模型是使用和运维Redis的关键。



**1.引出单线程模型**

现在开启了三个redis-cli客户端同时执行命令。

客户端1设置一个字符串键值对：

set hello world

客户端2对counter做自增操作：

incr counter

客户端3对counter做自增操作：

incr counter



Redis客户端与服务端的模型可以简化成图2-3，每次客户端调用都经历了发送命令、执行命令、返回结果三个过程。

其中第 2 步是重点要讨论的，因为 Redis 是单线程来处理命令的，所以一条命令从客户端达到服务端不会立刻被执行，所有命令都会进入一个队列中，然后逐个被执行。所以上面 3 个客户端命令的执行顺序是不确定的（如图 2-4 所示），但是可以确定不会有两条命令被同时执行（如图 2-5 所示），
所以两条 incr 命令无论怎么执行最终结果都是 2，不会产生并发问题，这就是 Redis 单线程的基本模型。但是像发送命令、返回结果、命令排队肯定不像描述的这么简单，Redis 使用了 I/O 多路复用技术来解决 I/O 的问题，下一节将进行介绍。



**2.为什么单线程还能这么快**

通常来讲，单线程处理能力要比多线程差，例如有10000斤货物，每辆车的运载能力是每次200斤，那么要50次才能完成，但是如果有50辆车，只要安排合理，只需要一次就可以完成任务。那么为什么Redis使用单线程模型会达到每秒万级别的处理能力呢？可以将其归结为三点：

第一，纯内存访问，Redis将所有数据放在内存中，内存的响应时长大约为100纳秒，这是Redis达到每秒万级别访问的重要基础。

第二，非阻塞I/O，Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间，如图2-6所示。







第三，单线程避免了线程切换和竞态产生的消耗。

既然采用单线程就能达到如此高的性能，那么也不失为一种不错的选择，因为单线程能带来几个好处：第一，单线程可以简化数据结构和算法的实现。如果对高级编程语言熟悉的读者应该了解并发数据结构实现不但困难而且开发测试比较麻烦。第二，单线程避免了线程切换和竞态产生的消耗，
对于服务端开发来说，锁和线程切换通常是性能杀手。

但是单线程会有一个问题：对于每个命令的执行时间是有要求的。如果某个命令执行过长，会造成其他命令的阻塞，对于Redis这种高性能的服务来说是致命的，所以Redis是面向快速执行场景的数据库。

单线程机制很容易被初学者忽视，但笔者认为Redis单线程机制是开发和运维人员使用和理解Redis的核心之一，随着后面的学习，相信读者会逐步理解。





#### 2.2　字符串

字符串类型是 Redis 最基础的数据结构。首先键都是字符串类型，而且其他几种数据结构都是在字符串类型基础上构建的，所以字符串类型能为其他四种数据结构的学习奠定基础。如图 2-7 所示，字符串类型的值实际可以是字符串（简单的字符串、复杂的字符串（例如 JSON、XML））、数字
（整数、浮点数），甚至是二进制（图片、音频、视频），但是值最大不能超过 512MB。



##### 2.2.1　命令

字符串类型的命令比较多，本小节将按照常用和不常用两个维度进行说明，但是这里常用和不常用是相对的，希望读者尽可能都去了解和掌握。



**1.常用命令**

（1）设置值

set key value [ex seconds] [px milliseconds] [nx|xx]

set命令有几个选项：

- ex seconds：为键设置秒级过期时间。

- px milliseconds：为键设置毫秒级过期时间。

- nx：键必须不存在，才可以设置成功，用于添加。

- xx：与 nx 相反，键必须存在，才可以设置成功，用于更新。除了 set 选项，Redis 还提供了 setex 和 setnx 两个命令：

  setex key seconds value
  setnx key value

setnx和setxx在实际使用中有什么应用场景吗？以setnx命令为例子，由于Redis的单线程命令处理机制，如果有多个客户端同时执行setnx key value，根据setnx的特性只有一个客户端能设置成功，setnx可以作为分布式锁的一种实现方案。



（2）获取值

get key



（3）批量设置值

mset key value [key value ...]



（4）批量获取值

mget key [key ...]

如果有些键不存在，那么它的值为nil（空），结果是按照传入键的顺序返回

批量操作命令可以有效提高开发效率。

学会使用批量操作，有助于提高业务处理效率，但是要注意的是每次批量操作所发送的命令数不是无节制的，如果数量过多可能造成Redis阻塞或者网络拥塞。



（5）计数

incr key

incr 命令用于对值做自增操作，返回结果分为三种情况：

- 值不是整数，返回错误。

- 值是整数，返回自增后的结果。

- 键不存在，按照值为0自增，返回结果为1。

  

很多存储系统和编程语言内部使用 CAS 机制实现计数功能，会有一定的 CPU 开销，但在 Redis 中完全不存在这个问题，因为 Redis 是单线程架构，任何命令到了 Redis 服务端都要顺序执行。



**2.不常用命令**

（1）追加值

append key value

append 可以向字符串尾部追加值

（2）字符串长度

strlen key

每个中文占用 3 个字节。

（3）设置并返回原值

getset key value

getset 和 set 一样会设置值，但是不同的是，它同时会返回键原来的值

（4）设置指定位置的字符

setrange key offeset value

位置从 0 开始计算

（5）获取部分字符串

getrange key start end

start和end分别是开始和结束的偏移量，偏移量从0开始计算

表2-2是字符串类型命令的时间复杂度，开发人员可以参考此表，结合自身业务需求和数据大小选择适合的命令。











##### 2.2.2　内部编码

字符串类型的内部编码有3种：

- int：8个字节的长整型。

- embstr：小于等于39个字节的字符串（**注释**：新版改到 44 了，有待验证）。

- raw：大于39个字节的字符串。

Redis 会根据当前值的类型和长度决定使用哪种内部编码实现。

有关字符串类型的内存优化技巧将在 8.3 节详细介绍。



##### 2.2.3　典型使用场景

**1.缓存功能**

图 2-10 是比较典型的缓存使用场景，其中Redis作为缓存层，MySQL作为存储层，绝大部分请求的数据都是从Redis中获取。由于Redis具有支撑高并发的特性，所以缓存通常能起到加速读写和降低后端压力的作用。

下面伪代码模拟了图 2-10 的访问过程：

1）该函数用于获取用户的基础信息：

```c
UserInfo getUserInfo(long id){
...
}
```



2）首先从Redis获取用户信息：

```c
// 定义键
userRedisKey = "user:info:" + id;
// 从Redis获取值
value = redis.get(userRedisKey);
if (value != null) {
// 将值进行反序列化为UserInfo并返回结果
userInfo = deserialize(value);
return userInfo;
}
```



与 MySQL 等关系型数据库不同的是，Redis 没有命令空间，而且也没有对键名有强制要求（除了不能使用一些特殊字符）。但设计合理的键名，有利于防止键冲突和项目的可维护性，比较推荐的方式是使用 “业务名：对象名：id：[属性]” 作为键名（也可以不是分号）。例如 MySQL 的数据库名为
vs，用户表名为user，那么对应的键可以用 "vs：user：1"，"vs：user：1：name" 来表示，如果当前 Redis 只被一个业务使用，甚至可以去掉 “vs：”。如果键名比较长，例如 “user：{uid}：friends：messages：{mid}”，可以在能描述键含义的前提下适当减少键的长度，例如变为 “u：{uid}：fr：m：{mid}”，从而减少由于键过长的内存浪费。

3）如果没有从Redis获取到用户信息，需要从MySQL中进行获取，并将结果回写到Redis，添加1小时（3600秒）过期时间：

```c
// 从MySQL获取用户信息
userInfo = mysql.get(id);
// 将userInfo序列化，并存入Redis
redis.setex(userRedisKey, 3600, serialize(userInfo));
// 返回结果
return userInfo
```



整个功能的伪代码如下：

```c
UserInfo getUserInfo(long id){
    userRedisKey = "user:info:" + id
    value = redis.get(userRedisKey);
    UserInfo userInfo;
    if (value != null) {
    	userInfo = deserialize(value);
    } else {
    	userInfo = mysql.get(id);
    if (userInfo != null)
   		redis.setex(userRedisKey, 3600, serialize(userInfo));
    }
    return userInfo;
}
```



**2.计数**

略



**3.共享Session**

略



**4.限速**

略



#### 2.3　哈希

几乎所有的编程语言都提供了哈希（hash）类型，它们的叫法可能是哈希、字典、关联数组。在Redis中，哈希类型是指键值本身又是一个键值对结构，形如value={{field1，value1}，...{fieldN，valueN}}，Redis键值对和哈希类型二者的关系可以用图2-14来表示。







