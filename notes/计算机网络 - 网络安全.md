## 网络安全

在 20 世界 70 年代后期，美国的**数据加密标准** DES（Data Encryption Standard）和**公钥密码体制**（public key crypto-system，又称为公开密钥密码体制）的出现，成为近代密码学发展史上的两个重要里程碑。



#### 两类密码体制



##### 对称密钥密码体制

所谓**对称密钥密码体制**，即**加密密钥与解密密钥是使用相同的密码体制**。

**数据加密标准** DES 属于对称密钥密码体制。它由 IBM 公司研制出，于 1977 年被美国定为联邦信息标准后，在国际上引起了极大的重视。ISO 曾将 DES 作为数据加密标准。

DES 是一种分组密码。在加密前，先对整个的明文进行分组。每一个组为 64 位长的二进制数据。然后对每一个 64 位二进制数据进行加密处理，产生一组 64 位密文数据。最后将各组密文串接起来，即得出整个的密文。使用的密钥占有 64 位（实际密钥长度为 56 位，外加 8 位用于奇偶校验）。

**DES 的保密性取决于对密钥的保密，而算法是公开的**。DES 的问题是它的密钥长度。56 位长的密钥意味着共有 2^56^ 种可能的密钥，也就是说，共有约 7.6 ✖ 10^16^ 种密钥。假设一台计算机 1μs 可执行一次 DES 加密，同时假定平均只需搜索密钥空间的一半即可找到密钥，那么破译 DES 要超过 1000 年。

但现在已经设计出来搜索 DES 密钥的专用芯片。在 1999 年已经有人借助于一台不到 25 万美元的专用计算机，用 22 小时多一点的时间破译了 56 位密钥的 DES。若用价格为 100 万美元或 1000 万美元的机器，则预期的搜索时间分别为 3.5 小时或 21 分钟。现在对于 56 位 DES 密钥的搜索已成常态，56 位 DES 已不再被认为是安全的。

对于 DES 56 位密钥的问题，学者们提出了三重 DES（Triple DES 或记为 3DES）的方案，把一个 64 位明文用一个密钥加密，再用另一个密钥解密，然后再使用第一个密钥加密，即

Y = DES~K1~(DES^1^ ~K2~(DES~K1~(X))

三重 DES 广泛用于网络、金融、信用卡等系统。

AES 于 2001 年正式取代 DES 成为高级加密标准。





##### 公钥密码体制

**公钥密码体制**（又称为公开密钥密码体制）的概念是由斯坦福大学的研究人员于 1976 年提出的。公钥密码体制**使用不同的加密密钥与解密密钥**。

公钥密码体制的产生主要有两个方面的原因，一是由于对称密钥密码体制的**密钥分配**问题，二是由于对**数字签名**的需求。

在对称密钥密码体制中，加解密的双方使用的是相同的密钥。但怎样才能做到这一点呢？一种是实现约定，另一种是用信使来传送。在高度自动化的大型计算机网络中，用信使来传送密钥显然是不合适的。如果事先约定密钥，就会给密钥的管理和更换带来极大的不便。若使用高度安全的**密钥分配中心** KDC（Key Distribution Center），也会使得网络成本增加。

对数字签名的强烈需求也是产生公钥密码体制的一个原因。在许多应用中，人们需要对纯数字的电子信息进行签名，表明该信息确实是某个特定的人产生的。

公钥密码体制提出不久，人们就找到了三种公钥密码体制。目前最著名的是由美国三位科学家于 1976 年提出的 **RSA 体制**。它是一种基于数论中的大数分解问题的体制。

在公钥密码体制中，**加密密钥** PK（public key，即**公钥**）是向公众公开的，而**解密密钥** SK（secret key，即**私钥**或**密钥**）则是需要保密的。加密算法 E 和解密算法 D 也都是公开的。

公钥密码体制的加密和解密过程有如下特点：

（1）**密钥对**产生器产生出接收者 B 的一对密钥：加密密钥 PK~b~ 和解密密钥 SK~B~ 。发送者 A 所用的加密密钥 PK~b~ 就是接收者 B 的公钥，它向公众公开。而 B 所用的解密密钥 SK~B~ 就是接收者 B 的私钥，对其他人都保密。

（2）发送者 A 用 B 的公钥 PK~B~ 通过 E 运算对明文 X 加密，得出密文 Y，发送给 B。

Y = E~PKB~ (X)

B 用自己的私钥 SK~B~ 通过 D 运算进行解密，恢复出明文，即

D~SKB~ (Y) = D~SKB~ (E~PKB~ (X)) = X

(3) 虽然在计算机上可以很容易地产生成对的 PK~b~ 和 SK~B~ ，但从已知的 PK~B~ 实际上不可能推导出 SK~B~ ，即从 PK~B~ 到 SK~B~ 是 "**计算上不可能的**"。 

（4）虽然公钥可用来加密，但却不能用来解密，即

D~PKB~ (E~PKB~ (X)) ≠ X

（5）先后对 X 进行 D 运算和 E 运算或进行 E 运算和 D 运算，结果都是一样的：

E~PKB~ (D~SKB~ (X)) = D~SKB~ (E~PKB~ (X)) = X

请注意，通常都是先加密然后再解密。但仅从运算的角度看，D 运算和 E 运算的先后顺序则可以是任意的。对某个报文进行 D 运算，但并不表明是要对其解密。

图 7-3 给出了用公钥密码体制进行加密的过程。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%20-%20%E5%9B%BE1.jpg"/> </div><br>

公开密钥与对称密钥在是用通信信道方面有很大的不同。在使用对称密钥时，由于双方使用同样的密钥，因此在通信信道上可以进行**一对一的双向保密通信**，每一方即可用此密钥加密明文，并发送给对方，也可接收密文，用同一密钥对密文解密。这种保密通信仅限于持有此密钥的双方（如再有第三方就不保密了）。但在使用公开密钥时，在通信信道上可以是**多对一的单向保密通信**。例如在图 7-3 中，可以有很多人同时持有 B 的公钥，并各自用此公钥对自己的报文加密后发送给 B。只有 B 才能够用其私钥对收到的多个密文一一进行解密。但使用这对密钥进行反方向的保密通信则是不行的。在现实生活中，这种多对一的单向保密通信是很常用的。例如，在网购时，很多顾客都向同一个网站发送各自的信用卡信息，就属于这种情况。

请注意，**任何加密方法的安全性取决于密钥的长度，以及攻破密文所需的计算量**，而不是简单地取决于加密的体制（公钥密码体制或传统加密体制）。我们还要指出，公钥密码体制并没有使传统密码体制被弃用，因为目前公钥加密算法的**开销较大**，在可见的将来还不会放弃传统加密方法。 





#### 数字签名

书信或文件是工具亲笔签名或印章来证明其真实性的。但在计算机网络中传送的文电又如何盖章呢？这就要使用数字签名。数字签名必须保证能够实现以下三点功能：

（1）接收者能够核实发送者对报文的签名。也就是说，接收者能够确信该报文的确是发送者发送的。其他人无法伪造对报文的签名。这叫做**报文鉴别**。

（2）接收者确信所收到的数据和发送者发送的完全一样而没有被篡改过。这叫做**报文的完整性**。

（3）发送者事后不能抵赖对报文的签名。这叫做**不可否认**。

现在已有多种实现数字签名的方法。但采用公钥算法要比采用对称密钥算法更容易实现。下面就来介绍这种数字签名。

为了进行**签名**，A 用其私钥对 SK~A~ 对报文 X 进行 D 运算（见图 7-4）。D 运算本来叫做解密运算。可是，还没有加密怎么就进行解密呢？这并没有关系。因为 D 运算只是得到了某种不可读的密文。在图 7-4 中我们写为 “D 运算” 而不是 “解密运算”，就是为了避免产生这种误解。A 把经过 D 运算得到的密文传送给 B。B 为了**核实签名**，用 A 的公钥进行 E 运算，还原出明文 X。请注意，任何人用 A 的公钥 PK~A~ 进行 E 运算后都可以得出 A 发送的明文。可见图 7-4 所示的通信方式并非为了保密，而是为了进行签名和核实签名，即确认此明文的却是 A 发送的。

 <div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%20-%20%E5%9B%BE2.jpg"/> </div><br>



下面讨论一下数字签名为什么具有上述的三点功能。

因为除 A 外没有别人持有 A 的私钥 SK~A~ ，所以除 A 外没有别人产生密文 D~SKA~(X)。这样，B 就相信报文 X 是 A 签名发送的。这就是报文鉴别的功能。同理，其他人如果篡改过报文，但由于无法得到 A 的私钥 SK~A~ 来对 X 进行加密，那么 B 对篡改过的报文进行解密后，将会得出不可读的明文，就知道收到的报文被篡改过。这样就可以保证报文的完整性。若 A 要抵赖曾发送报文给 B，B 可把 X 及 D~SKA~(X) 出示给进行公证的第三者。第三者很容易用 PK~A~ 去证实 A 确实发送 X 给 B。这就是不可否认的功能。这三项功能的关键都在于没有其他人能够持有 A 的密钥 SK~A~。

但上述过程仅对报文进行了签名，对报文 X 本身却未保密。因为截获到密文 D~SKA~(X) 并知道发送者身份的任何人，通过查阅手册即可获得发送者的公钥 PK~A~，因而能知道报文的内容。若采用图 7-5 所示的方法，即可同时实现秘密通信和数字签名。图中 SK~A~ 和 SK~B~ 分别为 A 和 B 的私钥，而 PK~A~ 和 PK~B~ 分别为 A 和 B 的公钥。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%20-%20%E5%9B%BE3.jpg"/> </div><br>







#### 鉴别

在网络的应用中，**鉴别**（authentication）是网络安全中一个很重要的问题。鉴别和加密是不相同的概念。鉴别是**要验证通信的对方的确是自己所要通信的对象，而不是其他的冒充者，并且所传送的报文是完整的，没有被他人篡改过。**

请注意，鉴别与**授权**（anthorization）也是不同的概念。授权涉及的问题是：所进行的过程是否被允许（如是否可以对某文件进行读或写）。

有时可再把鉴别细分为两种。一种是报文鉴别，即鉴别所收到的报文的确是报文的发送者所发送的，而不是其他人伪造的或篡改的。这就包含了端点鉴别和报文完整性的鉴别。另一种则是实体鉴别，即仅仅鉴别发送报文的实体。实体可以是一个人，也可以是一个进程（客户或服务器）。这就是端点鉴别。

下面分别讨论报文鉴别与实体鉴别的特点。



##### 报文鉴别



1.**密码散列函数**

理论上讲，使用 7.3 节所讨论的数字签名就能够实现对报文的鉴别。然而这种方法有一个很大的缺点，就是对较长的报文（这是很常见的）进行数字签名会使计算机增加非常大的负担，因为这需要进行较多的时间来进行运算。例如图 7-4 所示的 D 运算和 E 运算都需要花费非常多的计算机的 CPU 时间。因此，我们需要找出一种相对简单的方法对报文进行鉴别。这种方法就是使用**密码散列函数**（cryptographic hash function）。

我们在前面几章中，曾多次使用过检验和（checksum）这一概念。实际上，检验和就是散列函数的一种应用，用于发现数据在传输过程中的比特差错。

我们知道，散列函数具有以下两个特点：

（1）散列函数的输入长度可以很长，但其**输出长度是固定的，并且较短**。散列函数的输出叫做**散列值**，或更简单些，称为**散列**。

（2）不同的散列值肯定对应于不同的输入，但不同的输入却可能得出相同的散列值。这就是说，散列函数的输入和输出并非一一对应的，而是多对一的。

在密码学中使用的散列函数称为密码散列函数，其最重要的特点就是：要找到两个不同的报文，它们具有同样的密码散列函数输出，在计算上是不可行的。也就是说，密码散列函数实际上是一种**单向函数**（one-way function）。

上述的重要概念可用图 7-6 来说明。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%20-%20%E5%9B%BE4.jpg"/> </div><br>



这就是说，如果我们的固定长度的散列 H(X) 被网络入侵者截获了，那么解惑者也无法伪造出另一个明文 Y，使得 H(Y) = H(X)。换言之，散列 H(X) 可用来保护明文 X 的完整性，因为如果 (X, H(X)) 是发送方所创建的明文和从该明文导出的散列，那么入侵者无法根据截获的散列 H(X) 伪造出另一个明文 Y，使得 Y 的散列 H(Y) 与明文 X 的散列 H(X) 相同。



2.**实用的密码散列函数 MD5 和 SHA-1**

通过许多学者的不断努力，已经设计出一些实用的密码散列函数（或称为散列算法），其中最出名的就是 MD5 和 SHA-1。MD 就是 Message Digest 的缩写，意思是**报文摘要**。MD5 是报文摘要的第 5 个版本。

报文摘要算法 MD5 公布于 RFC 1321（1991 年），并获得了非常广泛的应用。MD5 的设计者曾提出一个猜想，即根据给定的 MD5 报文摘要代码，要找出一个与原来报文有相同报文摘要的另一报文，其难度在计算上几乎是不可能的。但在 2004 年，已被中国学者证明可以用系统的方法找出一对报文，这对报文具有相同的 MD5 报文摘要，而这仅需 15 分钟，或不到 1 小时。“密码散列函数的逆向变换是不可能的” 这一传统概念现在已受到了颠覆性的动摇。随后，又有许多学者开发了对 MD5 实际的攻击。于是 MD5 最终被另一种叫做安全散列算法 SHA（Secure Hash Algorithm）的标准所取代。SHA 比 MD5 更安全，但计算起来却比 MD5 要慢些。



3.**报文鉴别码**

下面进一步讨论在报文鉴别中怎样使用散列函数。

下面给出的三个简单步骤，看起来似乎可以作为报文鉴别之用。

（1）用户 A 首先根据自己的明文 X 计算出散列 H(X)（例如，使用 MD5）。为方便起见，我们得把得出的散列 H(X) 记为 H。

（2）用户 A 把散列 H 拼接在明文 X 的后面，生成了扩展的报文（X，H），然后发送给 B。

（3）用户 B 收到了这个扩展的报文（X，H）。因为散列的长度 H 是早已知道的固定值，因此可以把收到的散列 H 和明文 X 分离开。B 通过散列函数的运算，计算出收到的明文 X 的散列 H(X) 。若 H(X) = H，则 B 似乎可以相信所收到的明文是 A 发送过来的。

像上面列举的做法，**实际上是不可行的**。设想某个入侵者创建了一个伪造的报文 M，然后也同样地计算出其散列 H(M)，并且冒充 A 把拼接有散列地扩展报文发送给 B。B 收到扩展地报文（M，H(M)）后，按照上面步骤（3）的方法进行验证，发现一切都是正常的，就会误认为所收到的伪造报文就是 A 发送的。

因此，必须设法对上述的攻击进行防范。解决的办法并不复杂，就是对散列进行一次加密。图 7-7 给出了这种办法的示意图。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%20-%20%E5%9B%BE5.jpg"/> </div><br>





从图 7-7 可以看出，在 A 从报文 X 导出散列 H 后，就对散列 H 用密钥 K 加密。这样得出的结果叫做**报文鉴别码** MAC（Message Authentication Code）。请注意：局域网中使用的媒体接入控制 MAC 也是使用这三个字母，因此在看到 MAC 时应注意上下文。

A 把已加密的报文鉴别码 MAC 拼接在报文 X 的后面，得到扩展的报文，发送给 B。

B 收到扩展的报文后，先把报文鉴别码 MAC 与报文 X 分离出来。然后用同样的密钥 K 对收到的报文鉴别码 MAC 进行解密运算，得出加密前的散列 H。再把报文 X 进行散列函数运算，得出散列 H(X)。最后，把计算出的散列 H(X) 与 H 进行比较。如一致，就可以相信所收到的报文 X 的确是 A 发送 的。由于入侵者不掌握密钥 K，所以入侵者无法伪造 A 的报文鉴别码 MAC，因而无法伪造 A 发送的报文。这样就完成了对报文的鉴别。

我们可以注意到，现在整个的报文是不需要加密的。虽然从散列 H 导出报文鉴别码 MAC 需要加密算法，但由于散列 H 的长度通常都远远小于报文 X 的长度，因此这种加密不会消耗很多的计算资源。这样，使用鉴别码 MAC 就能够很方便地保护报文的完整性。

现在已经有了好几个不同的 MAC 标准，而使用最广泛的就是 HMAC，它可以和 MD5 和 SHA-1 一起使用。

如图 7-7 所示的鉴别报文的方法实际上还有不少问题有待解决。例如，采用什么样的方法可以安全有效地来分发通信双方共享的密钥 K？一种可行的方法是采用公钥系统。我们仍然用图 7-7 来说明。

用户 A 用其私钥对散列 H 进行 D 运算，得出报文鉴别码 MAC。然后 A 把报文鉴别码 MAC 拼接在报文 X 的后面，构成扩展的报文发送给 B。B 收到扩展的报文后，采取的做法和前面所述的基本一样，不同的地方是，对收到的报文鉴别码 MAC 是用 A 的公钥进行 E 运算。由于入侵者没有 A 的私钥，因此他不可能伪造出 A 发出的报文。

我们还可看出，采用这样的方法得到的扩展报文，不仅是不可伪造的，也是不可否认的。



##### 实体鉴别

实体鉴别和报文鉴别不同。报文鉴别是对每一个收到的报文都要鉴别报文的发送者，而实体鉴别是在系统接入的全部持续时间内对和自己通信的对方实体只需验证一次。

最简单的实体鉴别过程如图 7-8 所示。A 向远端的 B 发送带有自己身份 A（例如，A 的姓名）和口令的报文，并且使用双方约定好的共享对称密钥 K~AB~ 进行加密。B 收到此报文后，用共享对称密钥 K~AB~ 进行解密，从而鉴别了实体 A 的身份。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%20-%20%E5%9B%BE6.jpg"/> </div><br>

然而这种简单的鉴别方法具有明显的漏洞。例如，入侵者 C 可以从网络上截获 A 发给 B 的报文，C **并不需要破译这个报文**（因为这可能得花很长时间），而是直接把这个由 A 加密的报文发送给 B，使 B 误认为 C 就是 A；然后 B 就向伪装成 A 的 C 发送许多本来应当发给 A 的报文。这就叫做**重放攻击**（reply attack）。C 甚至还可以截获 A 的 IP 地址，然后把 A 的 IP 地址冒充为自己的 IP 地址（这叫做 IP 欺骗），使 B 更加容易受骗。



















































































































