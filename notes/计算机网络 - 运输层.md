## 运输层

运输层是整个网络体系结构中的关键层次之一。一定要弄清楚以下一些重要概念：

（1）运输层为相互通信的应用进程提供逻辑通信。

（2）端口和套接字的意义。

（3）无连接的 UDP 的特点。

（4）面向连接的 TCP 的特点。

（5）在不可靠的网络上实现可靠传输的工作原理，停止等待协议和 ARQ 协议。

（6）TCP 的滑动窗口、流量控制、拥塞控制和连接管理。



#### 运输层协议概述



##### 进程之间的通信

从通信和信息处理的角度看，**运输层向它上面的应用层提供通信服务**，它属于面向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两台主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。

下面通过图 5-1 的示意图来说明运输层的作用。设局域网 LAN~1~ 上的主机 A 和局域网 LAN~2~ 上的主机 B 通过互连的广域网 WAN 进行通信。我们知道，IP 协议能够把源主机 A 发送出的分组，按照首部中的目的地址，送交到目的主机 B，那么，为什么还需要运输层呢？

从 IP 层来说，通信的两端是两台主机。IP 数据报的首部明确地标志了这两台主机的 IP 地址。但 “两台主机之间的通信” 这种说法还不够清楚。这是因为，真正进行通信的实体是在主机中的进程，是这台主机中的一个**进程**和另一台主机中的一个**进程**在交换数据（即通信）。因此严格地讲，两台主机进行通信就是两台主机中的**应用进程互相通信**。IP 协议虽然能把分组送到目的主机，但是这个分组还停留在主机的网络层而没有交付主机中的应用进程。从运输层的角度看，**通信的真正端点并不是主机而是主机中的进程**。也就是说，**端到端的通信**是应用进程之间的通信。在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信。例如，某用户在使用浏览器查找某网站的信息时，其主机的应用层运行浏览器客户进程。如果在浏览网页的同时，还要用电子邮件给网站发送反馈意见，那么主机的应用层就还要运行电子邮件的客户进程。在图 5-1 中，主机 A 的应用进程 AP~1~ 和主机 B 的应用进程 AP~3~ 通信，而与此同时，应用进程 AP~2~ 也和对方的应用进程 AP~4~ 通信。这表明运输层有一个很重要的功能——**复用**（multiplexing）和**分用**（demultiplexing）。这里的 “复用” 是指在发送方不同的应用进程都可以使用同一个运输层协议传送数据（当然需要加上适当的首部），而 “分用” 是指接收方的运输层在剥去报文的首部后能够把这些数据正确交付目的应用进程。

IP 层也有复用和分用的功能。即，在发送方不同协议的数据都可以封装成 IP 数据报发送出去，而在接收方的 IP 层根据 IP 首部中的协议字段进行分用，把剥去首部后的数据交付给应当接收这些数据的协议。

图 5-1 中两个运输层之间有一个双向粗箭头，写明 “**运输层提供应用进程间的逻辑通信**”。“逻辑通信” 的意思是：从应用层来看，只要把应用层报文交给下面的运输层，运输层就可以把这报文传送到对方的运输层（哪怕双方相距很远，例如几千公里），**好像这种通信就是沿水平方向直接传送数据。但事实上这两个运输层这件并没有一条水平方向的物理连接。数据的传送是沿着图中的虚线方向（经过多个层次）传送的**。“逻辑通信” 的意思是 “好像是这样通信，但事实上并非真的这样通信”。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E8%BF%90%E8%BE%93%E5%B1%82%20-%20%E5%9B%BE1.jpg"/> </div><br>
从这里可以看出网络层和运输层有明显的区别。**网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信**（见图 5-2）。然而正如后面还要讨论的，运输层还具有网络层无法代替的许多其他重要功能。

运输层还要对收到的报文进行**差错检测**。大家应当还记得，在网络层，IP 数据报首部中的检验和字段，只检验首部是否出现差错而不检查数据部分。

根据应用程序的不同需求，运输层需要有两种不同的运输协议，即**面向连接的 TCP** 和**无连接的 UDP**，这两种协议就是本章要讨论的主要内容。

我们还应指出，**运输层向高层用户屏蔽了下面网络核心的细节**（如网络拓扑、所采用的路由选择协议等），**它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道**，但这条逻辑通信信道对上层的表现却因运输层使用的不同协议而有很大的差别。当运输层**采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的**（只提供尽最大努力服务），但这种逻辑通信信道就相当于**一条全双工的可靠信道**。但当运输层采用**无连接的 UDP 协议**时，这种逻辑通信信道仍然是一条**不可靠信道**。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E8%BF%90%E8%BE%93%E5%B1%82%20-%20%E5%9B%BE2.jpg"/> </div><br>
##### 运输层的两个主要协议

TCP/IP 运输层的两个主要协议都是互联网的正式标准，即：

（1）**用户数据报协议 UDP**（User Datagram Protocol）

（2）**传输控制协议 TCP**（Transmission Control Protocol）

图 5-3 给出了这两种协议在协议栈中的位置。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E8%BF%90%E8%BE%93%E5%B1%82%20-%20%E5%9B%BE3.jpg"/> </div><br>
按照 OSI 的术语，两个对等运输实体在通信时传送的数据单元叫做**运输协议数据单元** TPDU（Transport Protocol Data Unit）。但在 TCP/IP 体系中，则根据所使用的协议是 TCP 或 UDP，分别称之为 **TCP 报文段**（segment）或 **UDP 用户数据报**。

UDP 在传送数据之前**不需要先建立连接**。远地主机的运输层在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式。

TCP 则**提供面向连接的服务**。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的、面向连接的运输服务，因此不可避免地增加了许多的开销，如确认、流量控制、计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多的处理机资源。

表 5-1 给出了一些应用和应用层协议主要使用的运输层协议（UDP 或 TCP）。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E8%BF%90%E8%BE%93%E5%B1%82%20-%20%E5%9B%BE4.jpg"/> </div><br>
##### 运输层的端口

应用层所有的应用进程都可以通过运输层再传送到 IP 层（网络层），这就是**复用**。运输层从 IP 层收到发送给各应用进程的数据后，必须分别交付指明的各应用进程，这就是**分用**。显然，给应用层的每个应用进程赋予一个非常明确的标志是至关重要的。

我们知道，在单个计算机中的进程是用进程标识符（一个不大的整数）来标志的。但是在互联网环境下，用计算机操作系统所指派的这种进程标识符来标志运行在应用层的各种应用进程是不行的。这是因为在互联网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符。为了使不同操作系统的计算机的应用进程能够互相通信，就必须使用统一的方法（而这种方法必须与特定操作系统无关）对 TCP/IP 体系的应用进程进行标志。

但是，把一个特定机器上运行的特定进程，指明为互联网上通信的最后终点还是不可行的。这是因为进程的创建和撤销都是动态的，通信的一方几乎无法识别对方机器上的进程。另外，我们往往需要利用目的主机提供的功能来识别终点，而不需要知道具体实现这个功能的进程是哪一个（例如，要和互联网上的某个邮件服务器联系，并不一定要知道这个服务器功能是由目的主机上的哪个进程实现的）。

解决这个问题的方法就是在运输层使用**协议端口号**（protocol port number），或通常简称为**端口**（port）。这就是说，虽然通信的终点是应用进程，但只要把所传送的报文交付到目的主机的某个合适的目的端口，剩下的工作（即最后交付目的进程）就由 TCP 或 UDP 来完成。

请注意，这种**在协议栈层间的抽象的协议端口是软件端口**，和路由器或交换机上的硬件端口是完全不同的概念。硬件端口是**不同硬件设备**进行交互的接口，而**软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址**。不同的系统具体实现端口的方法可以是不同的（取决于系统使用的操作系统）。

在后面讲到的 UDP 和 TCP 的首部格式中，我们将会看到（图 5-5 和图 5-14）它们都有**源端口**和**目的端口**这两个重要字段。当运输层收到 IP 层交上来的运输层报文时，就能够根据其首部中的目的端口号把数据交付应用层的目的应用进程。

TCP/IP 的运输层用一个 16 位**端口号**来标志一个端口。但请注意，**端口号只具有本地意义**，它只是为了标志**本计算机**应用层中的各个进程在和运输层交互时的层间接口。在互联网不同计算机中，相同的端口号是**没有关联**的。16 位的端口号可允许有 65535 个不同的端口号，这个数目对一个计算机来说是足够用的。

由此可见，两个计算机中的进程要互相通信，不仅必须知道对方的 IP 地址（为了找到对方的计算机），而且要知道对方的端口号（为了找到对方计算机中的应用进程）。互联网上的计算机通信是采用客户-服务器方式。客户在发起通信请求时，必须先知道对方服务器的 IP 地址和端口号。因此运输层的端口号分为下面的两大类。

（1）**服务器端使用的端口号**：这里又分为两类，最重要的一类叫做**熟知端口号**（well-known port number）或**系统端口号**，数指为 0~1023。这些数指可在网址 www.iana.org 查到。LANA 把这些端口号指派给了 TCP/IP 最重要的一些应用程序，让所有的用户都知道。当一种新的应用程序出现后，IANA 必须为它指派一个熟知端口，否则互联网上的其他应用进程就无法和它进行通信。表 5-2 给出了一些常用的熟知端口号。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E8%BF%90%E8%BE%93%E5%B1%82%20-%20%E5%9B%BE5.jpg"/> </div><br>
另一类叫做**登记端口号**，数值为 1024~49151。这类端口号是为没有熟知端口号的应用程序使用的。使用这类端口号必须在 IANA 按照规定的手续登记，以防止重复。

（2）**客户端使用的端口号**：数值为 49152~65536。由于这类端口号仅在客户进程运行时才动态选择，因此又叫做**短暂端口号**。

短暂端口（ephemeral port）表示这种端口的存在时间是短期的。客户进程并不在意操作系统给它分配的是哪一个端口号，因为客户进程之所以必须有一个端口号（在本地主机中必须是唯一的），是为了让运输层的实体能够找到自己。这和熟知端口不同。服务器一接通电源，服务器程序就运行起来。为了让互联网上所有的的客户程序都能找到服务器程序，服务器程序所使用的端口（即熟知端口）就必须是固定的，并且是众所周知的。

这类端口号留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的端口号，因而可以把数据发送给客户进程。通信结束后，刚才已经使用过的客户端口号就不复存在，这个端口号就可以供其他客户进程使用。





#### 用户数据报协议 UDP



##### UDP 概述

用户数据报协议 UDP 只在 IP 的数据报服务之上增加了很少一点的功能，这就是复用和分用的功能以及无差错检测的功能。UDP 的主要特点是：

（1）UDP 是**无连接的**，即发送数据之前不需要建立连接（当然，发送数据结束时也没有连接可释放），因此减少了开销和发送数据之前的时延。

（2）UDP 使用**尽最大努力交付**，即不保证可靠交付，因此主机不需要维持复杂的连接状态表（这里面有许多参数）。

（3）UDP 是**面向报文**的。发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是**保留这些报文的边界**。这就是说，应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文，如图 5-4 所示。在接受方的 UDP，对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程。也就是说，UDP 一次交付一个完整的报文。因此，应用程序必须选择合适大小的报文。若报文太长，UDP 把它交给 IP 层后，IP 层在传送时可能要进行分片，这会降低 IP 层的效率。反之，若报文太短，UDP 把它交给 IP 层后，会使 IP 数据报的首部的相对长度太大，这也降低了 IP 层的效率。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E8%BF%90%E8%BE%93%E5%B1%82%20-%20%E5%9B%BE6.jpg"/> </div><br>
（4）UDP **没有拥塞控制**，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很多的实时应用（如 IP 电话、实时视频会议等）要求源主机以恒定的速率发送数据，并且允许在网络发送拥塞时丢失一些数据，但却不允许数据有太大的时延。UDP 正好适合这种要求。

（5）UDP **支持一对一、一对多、多对一和多对多的交互通信**。

（6）UDP **的首部开销小**，只有 8 个字节，比 TCP 的 20 个字节的首部要短。

虽然某些实时应用需要使用没有拥塞控制的 UDP，但当很多的源主机同时都向网络发送高速率的实时视频流时，网络就有可能发生拥塞，结果大家都无法正常接收。因此，不使用拥塞控制功能的 UDP 有可能会引起网络产生严重的拥塞问题。

还有一些使用 UDP 的实时应用，需要对 UDP 的不可靠的传输进行适当的改进，以减少数据的丢失。在这种情况下，应用进程本身可以在不影响应用的实时性的前提下，增加一些提高可靠性的措施，如采用前向纠错或重传已丢失的报文。





##### UDP 的首部格式

用户数据报 UDP 有两个字段：数据字段和首部字段。首部字段很简单，只有 8 个字节（图 5-5），由四个字段组成，**每个字段的长度都是两个字节**。各字段意义如下：

（1）**源端口**：源端口号。在需要对方回信时选用。不需要时可用全 0。

（2）**目的端口**：目的端口号。这在终点交付报文时必须使用。

（3）**长度**：UDP 用户数据报的长度，其最小值是 8（仅有首部）。

（4）**检验和**：检测 UDP 用户数据报在传输中是否有错。有错就丢弃。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E8%BF%90%E8%BE%93%E5%B1%82%20-%20%E5%9B%BE7.jpg"/> </div><br>

当运输层从 IP 层收到 UDP 数据报时，就根据首部中的目的端口，把 UDP 数据报通过相应的端口，上交最后的终点——应用进程。图 5-6 是 UDP 基于端口分用的示意图。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E8%BF%90%E8%BE%93%E5%B1%82%20-%20%E5%9B%BE8.jpg"/> </div><br>
如果接收方 UDP 发现收到的报文中的目的端口号不正确（即不存在对应于该端口号的应用进程），就丢弃该报文，并由网际控制报文协议 ICMP 发送 “端口不可达” 差错报文给发送方。traceroute 命令就是让发送的 UDP 用户数据报故意使用一个非法的 UDP 端口，结果 ICMP 就返回 “端口不可达” 差错报文，因而达到了测试的目的。

请注意，虽然在 UDP 之间的通信要用到其端口号，但由于 UDP 的通信是无连接的，因此不需要使用套接字（TCP 之间的通信必须要在两个套接字之间建立连接）。

UDP 用户数据报首部中检验和的计算方法有些特殊。在计算检验和时，要在 UDP 用户数据报之前增加 12 个字节的伪首部。所谓 “伪首部” 是因为这种伪首部并不是 UDP 用户数据报真正的首部。只是在计算检验和时，临时添加在 UDP 用户数据报前面，得到一个临时的 UDP 用户数据报。检验和就是按照这个临时的 UDP 用户数据报来计算的。伪首部既不向下传送也不向上递交，而仅仅是为了计算检验和。图 5-5 的最上面给出了伪首部各字段的内容。

UDP 计算检验和的方法和计算 IP 数据报首部检验和的方法相似。但不同的是：IP 数据报的检验和只检验 IP 数据报的首部，但 UDP 的检验和是把**首部和数据部分一起都检验**。





#### 传输控制协议 TCP 概述

由于 TCP 协议比较复杂，因此本节先对 TCP 协议进行一般的介绍，然后再逐步深入讨论 TCP 的可靠传输、流量控制和拥塞控制等问题。



##### TCP 最主要的特点

TCP 是 TCP/IP 体系中非常复杂的一个协议。下面介绍 TCP 最主要的特点。

（1）TCP 是**面向连接的运输层协议**。这就是说，应用程序再使用 TCP 协议之前，必须先建立 TCP 连接。在传送数据完毕后，必须释放已经建立的 TCP 连接。也就是说，应用进程之间的通信好像在 “打电话”：太花钱要先拨号建立连接，通话结束后要挂机释放连接。

（2）每一条 TCP 连接只能有两个**端点**（endpoint），每一条 TCP 连接只能是**点对点**的（一对一）。

（3）TCP 提供**可靠交付**的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复，并且按序到达。

（4）TCP 提供**全双工通信**。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。在发送时，应用程序在把数据传送给 TCP 的缓存后，就可以做自己的事，而 TCP 在合适的时候把数据发送出去。在接收时，TCP 把收到的数据放入缓存，上层的应用进程在合适的时候读取缓存中的数据。

（5）**面向字节流**。TCP 中的 “**流**”（stream）指的是**流入到进程或从进程流出的字节序列**。“面向字节流” 的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的**字节流**。TCP 并不知道所传送的字节流的含义。TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系（例如，发送方应用程序交给发送方的 TCP 共 10 个数据块，但接收方的 TCP 可能只用了 4 个数据块就把收到的字节流交付上层的应用程序）。但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。当然，接收方的应用程序必须有能力识别收到的字节流，把它还原成有意义的应用层数据。图 5-8 是上述概念的示意图。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E8%BF%90%E8%BE%93%E5%B1%82%20-%20%E5%9B%BE9.jpg"/> </div><br>
为了突出示意图的要点，我们只画出了一个方向的数据流。但请注意，在实际的网络中，一个 TCP 报文段包含上千个字节是很常见的，而图中的各部分都只画出了几个字节，这仅仅是为了更方便地说明 “面向字节流” 的概念。另一点很重要的是：图 5-8 中的 TCP 连接是一条**虚连接**（也就是**逻辑连接**），而不是一条真正的物理连接。TCP 报文段先要传送到 IP 层，加上 IP 首部后，再传送到数据链路层。再加上数据链路层的首部和尾部后，才离开主机发送到物理链路。

图 5-8 指出，TCP 和 UDP 在发送报文时所采用的方式完全不同。TCP 并不关心应用进程一次把多长的报文发送到 TCP 的缓存中，而是根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节（UDP 发送的报文长度是应用进程给出的）。如果应用进程一次只发来一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。





##### TCP 的连接

TCP 把**连接**作为**最基本的抽象**。TCP 的许多特性都与 TCP 是面向连接的这个基本特性有关。因此我们对 TCP 连接需要有更清楚的了解。

前面已经讲过，每一条 TCP 连接有两个端点。那么，TCP 连接的端点是什么呢？不是主机，不是主机的 IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做**套接字**（socket）或**插口**。根据 RFC 793 的定义：端口号**拼接到**（concatenated with）IP 地址即构成了套接字。因此，套接字的表示方法是在点分十进制的 IP 地址后面写上端口号，中间用冒号或逗号隔开。例如，若 IP 地址是 192.3.4.5 而端口号是 80，那么得到的套接字就是（192.3.4.5：80）。总之，我们有

套接字 socket = （IP 地址：端口号）

**每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定**。即：

TCP 连接 ::= {socket~1~，socket~2~} = {(IP~1~：port~1~)，(IP~2~：port~2~)}

总之，TCP 连接就是由协议软件所提供的一种抽象。虽然有时为了方便，我们也可以说，在一个应用进程和另一个应用进程之间建立了一条 TCP 连接，但一定要记住：**TCP 连接的端点是个很抽象的套接字**，即（**IP 地址：端口号**）。也还应记住：同一个 IP 地址可以有多个不同的 TCP 连接，而同一个端口号也可以出现在多个不同的 TCP 连接中。

请注意，socket 这个名词有时容易使人把一些概念弄混淆，因为随着互联网的不断发展以及网络技术的进步，**同一个名词 socket 却可表示多种不同的意思**。例如：

（1）允许应用程序访问连网协议的**应用编程接口 API**（Application Programming Interface），即运输层和应用层之间的一种接口，称为 socket API，并简称为 socket。

（2）在 socket API 中使用的一个**函数名**也叫做 socket。

（3）调用 socket 函数的**端点**称为 socket，如 “创建一个数据报 socket”。

（4）调用 socket 函数时，其**返回值**称为 socket 描述符，可简称为 socket。

（5）在操作系统内核中连网协议的 Berkeley 实现，称为 socket 实现。

上面的这些 socket 的意思都和本章所引用的 RFC 793 定义的 socket（指端口号拼接到 IP 地址）不同。





#### 可靠传输的工作原理

我们知道，TCP 发送的报文段是交给 IP 层传送的。但 IP 层只能提供尽最大努力服务，也就是说，TCP 下面的网络所提供的是不可靠的传输。因此，TCP 必须采用适当的措施才能使得两个运输层之间的通信变得可靠。

理想的传输条件有以下两个特点：

（1）传输信道不产生差错。

（2）不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据。

在这里的理想传输条件下，不需要采取任何措施就能够实现可靠传输。

然而实际的网络都不具备以上两个理想条件。但我们可以使用一些可靠传输协议，当出现差错时让发送方重传出现差错的数据，同时在接收方来不及处理收到的数据时，及时告诉发送方适当降低发送数据的速度。这样一来，本来不可靠的传输信道就能够实现可靠传输了。下面从最简单的停止等待协议讲起。

在计算机网络发展初期，通信链路不太可靠，因此在链路层传送数据时都要采用可靠的通信协议，其中最简单的协议就是这种 “停止等待协议”。在运输层并不使用这种协议，这里只是为了引出可靠传输的问题才从最简单的概念讲起。在运输层使用的可靠传输协议要复杂得多。





##### 停止等待协议

全双工通信的双方既是发送方也是接收方。下面为了讨论问题的方便，我们仅考虑 A 发送数据而 B 接收数据并发送确认。因此 A 叫做**发送方**，而 B 叫做**接收方**。因为这里是讨论可靠传输的原理，因此把传送的数据单元都称为分组，而并不考虑数据是在哪一个层次上传送的。运输层传送的协议数据单元叫做报文段，网络层传送的协议数据单元叫做 IP 数据报。但在一般讨论问题时，都可把它们简称为分组。“停止等待” 就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。

使用确认和重传机制，我们就可以**在不可靠的传输网络上实现可靠的通信**。

像上述的这种可靠传输协议常称为**自动重传请求** ARQ（Automatic Repeat reQuest）。意思是重传的请求是自动进行的。接收方不需要请求发送方重传某个出错的分组。

停止等待协议的优点是简单，但缺点是信道利用率太低。

为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发送完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地在传送。显然，这种传输方式可以获得很高的信道利用率。

当使用流水线传输时，就要使用下面介绍的**连续 ARQ 协议**和**滑动窗口协议**。



##### 连续 ARQ 协议

滑动窗口协议比较复杂，是 TCP 协议的精髓所在。这里先给出连续 ARQ 协议最基本的概念，但不涉及许多细节问题。

图 5-12（a）表示发送方维持的**发送窗口**，它的意义是：位于发送窗口内的 5 个分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。

分组发送是按照分组序号从小到大发送的。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E8%BF%90%E8%BE%93%E5%B1%82%20-%20%E5%9B%BE10.jpg"/> </div><br>


连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。图 5-13（b）表示发送方收到了对第 1 个分组的确认，于是把发送窗口向前移动一个分组的位置。如果原来已经发送了前 5 个分组，那么现在就可以发送窗口内的第 6 个分组了。

接收方一般都是采用**累积确认**的方式。这就是说，接收方不必对收到的分组逐个发送确认，而是在收到几个分组后，**对按序到达的最后一个分组发送确认**，这就表示：到这个分组为止的所有分组都已正确收到了。

累积确认有优点也有缺点。优点是：容易实现，即使确认丢失也不必重传。但缺点是不能向发送方反映出接收方已经正确收到的所有分组的信息。

例如，如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。这就叫做 Go-back-N（回退 N），表示需要再退回来重传已发送过的 N 个分组。可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。

在深入讨论 TCP 的可靠传输问题之前，必须先了解 TCP 的报文段首部的格式。





#### TCP 报文段的首部格式

TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是报文段。一个 TCP 报文段分为首部和数据两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。因此，只有弄清 TCP 首部各字段的作用才能掌握 TCP 的工作原理。下面讨论 TCP 报文段的首部格式。

TCP 报文段首部的前 20 个字节是固定的（图 5-14），后面有 4n 字节是根据需要而增加的选项（n 是整数）。因此 TCP 首部的最小长度是 20 字节。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E8%BF%90%E8%BE%93%E5%B1%82%20-%20%E5%9B%BE11.jpg"/> </div><br>
首部固定部分各字段的意义如下：

（1）**源端口和目的端口**：各占 2 个字节，分别写入源端口号和目的端口号。和前面图 5-6 所示的 UDP 的分用相似，TCP 的分用功能也是通过端口实现的。

（2）**序号**：占 4 字节。序号范围是[0，2^32^ - 1]，共 2^32^（即 4 294 967 296）个符号。序号增加到 2^32^ - 1 后，下一个序号就又回到 0。也就是说，序号使用 mod 2^32^ 运算。TCP 是面向字节流的。在一个 TCP 连接中传送的字节流中的**每一个字节都按顺序编号**。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则指的是**本报文段**所发送的数据的第一个字节的序号。例如，一报文段的序号字段是 301，而携带的数据共有 100 字节。这就表明：本报文段的数据的第一个字节的序号是 301，最后一个字节的序号是 400。显然，下一个报文段（如果还有的话）的数据序号应当从 401 开始，即下一个报文段的序号字段值应为 401。这个字段的名称也叫做 “**报文段序号**”。

（3）**确认号**：占 4 字节，是**期望收到对方下一个报文段的第一个数据字节的序号**。例如，B 正确收到了 A 发送过来的一个报文段，其序号字段值是 501，而数据长度是 200 字节（序号 501 ~ 701），这表明 B 正确收到了 A 发送的到序号 700 为止的数据。因此，B 期望收到 A 的下一个数据序号是 701，于是 B 在发送给 A 的确认报文段中把确认号置为 701。

若确认号 = N，则表明：到序号 N - 1 为止的所有数据都已正确收到。

由于序号字段有 32 位长，可对 4 GB（即 4 千兆字节）的数据进行编号。在一般情况下可保证当序号重复使用时，旧序号的数据早已通过网络到达终点了。

（4）**数据偏移**：占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。这个字段实际上是指出 TCP 报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的。但应注意，“数据偏移” 的单位是 32 位字（即以 4 字节长的字为计算单位）。由于 4 位二进制数能够表示的最大十进制数字是 15，因此数据偏移的最大值是 60 字节，这也是 TCP 首部的最大长度（即选项长度不能超过 40 字节）。

（5）**保留**：占 6 位，保留为今后使用，但目前应置为 0。

下面有 6 个控制位，用来说明本报文段的性质，它们的意义如下。

（6）**紧急 URG**（URGent）：当 URG = 1 时，表面紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据），而不要按原来的排队顺序来传送。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行。因此用户从键盘发出中断命令（Control + C）。如果不使用紧急数据，那么这两个字符将存储在接收 TCP 的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这就做就浪费了许多时间。

当 URG 置 1 时，发送应用进程就告诉发送方的 TCP 有紧急数据要传送。于是发送方 TCP 就把紧急数据插入到本报文段数据的**最前面**，而在紧急数据后面的数据仍是普通数据。这时要与首部中**紧急指针**（Urgent Pointer）字段配合使用。

（7）**确认 ACK**（ACKnowledgment）：仅当 ACK = 1 时确认号字段才有效。当 ACK = 0时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。

（8）**推送 PSH**（PuSH）：当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作。这时，发送方 TCP 把 PSH 置 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH = 1 的报文段，就尽快地（即 “推送” 向前）交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。

虽然应用程序可以选择推送操作，但推送操作很少使用。

（9）**复位 RST**（ReSeT）：当 RST = 1 时，表面 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。RST 置 1 还用来拒绝一个非法的报文段或拒绝打开一个连接。RST 也可称为重建位或重置位。

（10）**同步 SYN**（SYNchronization）：在连接建立时用来同步序号。当 SYN = 1 而 ACK = 0 时，表面这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1。因此，SYN 置为 1 就表示这是一个连接请求或连接接收报文。 

（11）**终止 FIN**（FINis，意思是 “完”、“终”）：用来释放一个连接。当 FIN = 1 时，表面此报文段的发送方的数据已发送完毕，并要求释放运输连接。

（12）**窗口**：占 2 字节。窗口值是 [0，2^16^ - 1] 之间的整数。窗口指的是发送本报文段的一方的**接收窗口**（而不是自己的发送窗口）。窗口值告诉对方：从报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，**窗口值作为接收方让发送方设置其发送窗口的依据**。

窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化着。

（13）**检验和**：占 2 字节。检验和字段检验的范围包括首部和数据这两部分。和 UDP 用户数据报一样，在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。伪首部的格式与图 5-5 中 UDP 用户数据报的伪首部一样。但应把伪首部第 4 个字段中的 17 改为 6（TCO 的协议号是 6），把第 5 字段中的 UDP 长度改为 TCP 长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用 IPv6，则相应的伪首部也要改变。

（14）**紧急指针**：占 2 字节。紧急指针仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据）。因此，紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP 就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为零时也可发送紧急数据。

（15）**选项**：长度可变，最长可达 40 字节。当没有使用 “选项” 时，TCP 的首部长度是 20 字节。

TCP 最初只规定了一种选项，即**最大报文段长度 MSS**（Maximum Segment Size）。请注意 MSS 这个名词的含义。MSS 是**每一个** TCP 报文段中的**数据字段的最大长度**。数据字段加上 TCP 首部才等于整个的 TCP 报文段。所以 MSS 并不是整个 TCP 报文段的最大长度，而是 “TCP 报文段长度减去 TCP 首部长度”。

为什么要规定一个最大报文段长度 MSS 呢？这并不是考虑接收方的接收缓存可能放不下 TCP 报文段中的数据。实际上，MSS 与接收窗口值没有关系。我们知道，TCP 报文段的数据部分，至少要加上 40 字节的首部（TCP 首部 20 字节和 IP 首部 20 字节，这里都还没有考虑首部中的选项部分），才能组成一个 IP 数据报。若选择较小的 MSS 长度，网络的利用率就降低。设想在极端的情况下，当 TCP 报文段只含有 1 个字节的数据时，在 IP 层传输的数据报的开销至少有 40 字节（包括 TCP 报文段的首部和 IP 数据报的首部）。这样，对网络的利用率就不会超过 1/42。到了数据链路层还要加上一些开销。但反过来，若 TCP 报文段非常长，那么在 IP 层传输时就有可能分解成多个短数据报片。在终点要把收到的各个短数据报片装配成原来的 TCP 报文段。当传输出错时还要进行重传。这些也都会使开销增大。

因此，MSS 应尽可能大些，只要在 IP 层传输时不需要再分片就行。由于 IP 数据报所经历的路径是动态变化的，因此在这条路径上确定的不需要分片的 MSS，如果改走另一条路径就可能需要进行分片。因此最佳的 MSS 是很难确定的。在连接建立的过程中，双方都把自己能够支持的 MSS 写入这一字段，以后就按照这个数值传送数据，两个传送方向可以有不同的 MSS 值。若主机未填写这一项，则 MSS 的默认值是 536 字节长。因此，所有在互联网上的主机都应能接收的报文段长度是 536 + 20（固定首部长度）= 556 字节。

随着互联网的发展，又陆续增加了几个选项。如**窗口扩大**选项、**时间戳**选项等。以后又增加了有关选择确认（SACK）选项。这些选项的位置都在图 5-14 所示的选项字段中。





#### TCP 可靠传输的实现

本节讨论 TCP 可靠传输的实现。

我们首先介绍以字节为单位的滑动窗口。为了讲述可靠传输原理的方便，我们**假定数据传输只在一个方向进行**，即 A 发送数据，B 给出确认。



##### 以字节为单位的滑动窗口

TCP 的滑动窗口是以字节为单位的。为了便于说明滑动窗口的工作原理，我们故意把后面图 5-15 至图 5-18 中的字节编号都取得很小。现假定 A 收到了 **B 发来**的确认报文段，其中窗口是 20 字节，而确认号是 31（这表明 B 期望收到的下一个序号是 31，而序号 30 为止的数据已经收到了）。根据这两个数据，A 就构造出自己的发送窗口，如图 5-15 所示。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E8%BF%90%E8%BE%93%E5%B1%82%20-%20%E5%9B%BE12.jpg"/> </div><br>





我们先讨论发送方 A 的发送窗口。发送窗口表示：在没有收到 B 的确认的情况下，A 可以连续把窗口内的数据都发送出去。凡是已经发送过的数据，在未收到确认之前都必须暂时保留，以便在超时重传时使用。

发送窗口里面的序号表示允许发送的序号。显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率。在上一节我们已经讲过，接收方会把自己的接收窗口数值放在窗口字段中发送给对方。因此，A 的发送窗口一定不能超过 B 的接收窗口数值。在后面我们将要讨论，发送方的发送窗口大小还要受到当时网络拥塞程度的制约。但在目前，我们暂不考虑网络拥塞的影响。

发送窗口后沿的后面部分表示已发送且已收到了确认。这些数据显然不需要再保留了。而发送窗口前沿的前面部分表示不允许发送的，因为接收方都没有为这部分数据保留临时存放的缓存空间。

发送窗口的位置由窗口前沿和后沿的位置共同确定。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口后沿不可能向后移动，因为不能撤销掉已收到的确认。发送窗口前沿通常是不断向前移动，但也有可能不动。这对应于两种情况：一是没有收到新的确认，对方通知的窗口大小也不变；二是收到了新的确认但对方通知的窗口缩小了，使得发送窗口前沿正好不动。

发送窗口前沿也可能**向后收缩**。这发生在对方通知的窗口缩小了。但 TCP 的标准**强烈不赞成这样做**。因为这可能发送方在收到这个通知以前已经发送了窗口中的许多数据，现在又要收缩窗口，不让发送这些数据，这样就会产生一些错误。

现在假定 A 发送了序号为 31 ~ 41 的数据。这时，发送窗口位置并未改变（图 5-16），但发送窗口内靠后面有 11 个字节（灰色小方框表示）表示已发送但未收到确认。而发送窗口内靠前面的 9 个字节（42 ~ 50）是允许发送但尚未发送的。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E8%BF%90%E8%BE%93%E5%B1%82%20-%20%E5%9B%BE13.jpg"/> </div><br>





从以上所述可以看出，要描述一个发送窗口的状态需要三个指针：P~1~， P~2~， P~3~（图 5-16）。指针都指向字节的序号。这三个指针指向的几个部分的意义如下：

小于 P~1~ 的是已发送并已收到确认的部分，而大于 P~3~ 的是不允许发送的部分。

P~3~ - P~1~ = A 的发送窗口

P~2~ - P~1~ = 已发送但尚未收到确认的字节数

P~3~ - P~2~ = 允许发送但当前尚未发送的字节数（又称为**可用窗口**或**有效窗口**）

再看一下 B 的接收窗口。B 的接收窗口大小是 20。在接收窗口外面，到 30 号为止的数据是已经发送过确认，并且已经交付主机了。因此在 B 可以不再保留这些数据。接收窗口内的序号（31 ~ 50）是允许接收的。在图 5-16 中，B 收到了序号为 32 和 33 的数据。这些数据没有按序到达，因为序号为 31 的数据没有收到（也许丢失了，也许滞留在网络中的某处）。请注意，B 只能对按序收到的数据中的最高序号给出确认，因此 B 发送的确认报文段中的确认号仍然是 31（即期望收到的序号），而不能是 32 或 33。

现在假定 B 收到了序号为 31 的数据，并把序号为 31 ~ 33 的数据交付主机，然后 B 删除这些数据。接着把接收窗口向前移动 3 个序号（图 5-17），同时给 A 发送确认，其中窗口值仍为 20，但确认号是 34。这表明 B 已经收到了到序号 33 为止的数据。我们注意到，B 还收到了序号为 37，38 和 40 的数据，但这些都没有按序到达，只能先暂存在接收窗口中。A 收到 B 的确认后，就可以把发送窗口向前滑动 3 个序号，但指针 P~2~ 不动。可以看出，现在 A 的可用窗口增大了，可发送的序号范围是 42 ~ 53。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E8%BF%90%E8%BE%93%E5%B1%82%20-%20%E5%9B%BE14.jpg"/> </div><br>





A 在继续发送完序号 42 ~ 53 的数据后，指针 P~2~ 向前移动和 P~3~ 重合。发送窗口内的序号都已用完，但还没有再收到确认（图 5-18）。由于 A 的发送窗口已满，可用窗口已减小到零，因此必须停止发送。请注意，存在下面这种可能性，就是发送窗口内所有的数据都已正确到达 B，B 也早已发出了确认。但不幸的是，所有这些确认都滞留在网络中。在没有收到 B 的确认时，A 不能猜测：“或许 B 收到了吧！” 为了保证可靠传输，A 只能认为 B 还没有收到这些数据。于是，A 在经过一段时间后（由超时计时器控制）就重传这部分数据，重新设置超时计时器，直到收到 B 的确认为止。如果 A 收到确认号落在发送窗口内，那么 A 就可以使发送窗口继续向前滑动，并发送新的数据。

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E8%BF%90%E8%BE%93%E5%B1%82%20-%20%E5%9B%BE15.jpg"/> </div><br>



我们在前面的图 5-8 中曾给出了这样的概念：发送方的应用进程把字节流写入了 TCP 的发送缓存，接收方的应用进程从 TCP 的接收缓存中读取字节流。下面我们就进一步讨论前面讲的窗口和缓存的关系。图 5-19 画出了发送方维持的发送缓存和发送窗口，以及接收方维持的接收缓存和接收窗口。这里首先要明确两点：

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E8%BF%90%E8%BE%93%E5%B1%82%20-%20%E5%9B%BE16.jpg"/> </div><br>

第一，缓存空间和序号空间都是有限的，并且都是循环使用的。最好是把它们画成圆环状的。但这里是为了画图的方便，我们还是把它们画成长条状的。

第二，由于实际上缓存或窗口中的字节数是非常之大的，因此图 5-19 仅仅是个示意图，没有标出具体的数值。但用这样的图来说明缓存和发送窗口以及接收窗口的关系是很清楚的。

我们先看一下图 5-19（a）所示的发送方情况。



