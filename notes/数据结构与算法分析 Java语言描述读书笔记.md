## 数据结构与算法分析 Java语言描述读书笔记

### 第 3 章 表、栈和队列

本章讨论最简单和最基本的三种数据结构。



#### 3.1	抽象数据类型

**抽象数据类型**（abstract data type，ADT）是带有一组操作的一些对象的集合。抽象数据类型是数学的抽象；在 ADT 的定义中没有地方提到关于这组操作是如何实现的任何解释。诸如表、集合、图以及与它们各自的操作一起形成的这些对象都可以被看做是抽象数据类型，这就像整数、实数、布尔数都是数据类型一样。整数、实数和布尔数各自都有与之相关的操作，而抽象数据类型也是如此。对于集合 ADT，可以有像添加（add）、删除（remove）以及包含（contain）这样一些操作。当然，也可以只要两种操作并（union）和查找（find），这两种操作又在这个集合上定义了一种不同的 ADT。

Java 类也考虑到 ADT 的实现，不过适当地隐藏了实现的细节。这样，程序中需要对 ADT 实施操作的任何其他部分可以通过调用适当的方法来进行。如果由于某种原因需要改变实现的细节，那么通过仅仅改变执行这些 ADT 操作的例程应该是很容易做到的。这种改变对于程序的其余部分是完全透明的。

对于每种 ADT 并不存在什么法则来告诉我们必须要有哪些操作，这是一个设计决策。错误处理和结构调整（在适当的地方）一般也取决于程序的设计者。本章中将要讨论的这三种数据结构是 ADT 的最基本的例子。我们将会看到它们中的每一种是如何以多种方法实现的，不过，当它们被正确地实现以后，使用它们的程序却没有必要知道它们是如何实现的。



#### 3.2	表 ADT

我们将处理形如 A~0~，A~1~，A~2~ 。。。A~N-1~ 的一般的表。我们说这个表的大小是 N。我们将大小为 0 的特殊的表称为**空表**（empty list）。

对于除空表外的任何表，我们说 A~i~ 后继 A~i-1~ 并称 A~i-1~ 前驱 A~i~ 。表中的第一个元素是 A~0~ ，而最后一个元素是 A~N-1~ 。我们将不定义 A~0~ 的前驱元，也不定义 A~n-1~ 的后继元。元素 A~i~ 在表中的位置为 i+1。为了简单起见，我们假设表中的元素是整数，但一般说来任意的复元素也是允许的（而且容易由 Java 泛型类处理）。

与这些 “定义” 相关的是要在表 ADT 上进行操作的集合。printList 和 makeEmpty 是常用的操作，其功能显而易见；find 返回某一项首次出现的位置；insert 和 remove 一般是从表的某个位置插入和删除某个元素；而 findKth 则返回（作为参数而被指定的）某个位置上的元素。

当然，一个方法的功能怎样才算恰当，完全要由程序设计者来确定，就像对特殊情况的处理那样。我们还可以添加一些操作，比如 next 和 previous，它们会取一个位置作为参数并分别返回其后继元和前驱元的位置。



##### 3.2.1	表的简单数组实现

对表的所有这些操作都可以通过使用数组来实现。虽然数组是由固定容量创建的，但在需要的时候可以用双倍的容量创建一个不同的数组。它解决由于使用数组而产生的最严重的问题，即从历史上看为了使用一个数组，需要对表的大小进行估计。而这种估计在 Java 或任何现代编程语言中都是不需要的。下列程序段解释一个数组 arr 在必要的时候如何被扩展（其初始长度为 10）：

```java
int[] arr = new int[10];
...
//下面我们决定需要扩大 arr
int[] newArr = new int[arr.length * 2];
for (int i = 0; i < arr.length; i++) {
    newArr[i] = arr[i];
}
arr = newArr;
```



数组的实现可以使得 printList 以线性时间被执行，而 findKth 操作





























































