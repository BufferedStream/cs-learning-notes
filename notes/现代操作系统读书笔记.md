## 现代操作系统读书笔记

读书目的：了解操作系统的基本概念，学习操作系统中的经典算法。



### 第 1 章	引论

现代计算机系统由一个或多个处理器、主存、磁盘、打印机、键盘、鼠标、显示器、网络接口以及各种其它输入/输出设备组成。一般而言，现代计算机系统是一个复杂的系统。如果每位语言程序员都不得不掌握系统的所有细节，那就不可能再编写代码了。而且，管理这些部件并加以优化实验，是一件挑战性极强的工作。所以，计算机安装了一层软件，称为**操作系统**，它的任务是为用户程序提供一个更好、更简单、更清晰的计算机模型，并管理刚才提到的所有设备。本书的主体就是操作系统。

多数读者都会对诸如 Windows、Linux、FreeBSD 或 OS X 等某个操作系统有些体验，但表面现象是会骗人的。用户与之交互的程序，基于文本的通常称为 **shell**，而基于图标的则称为**图形用户界面**（Graphical User Interface，GUI），它们实际上并不是操作系统的一部分，尽管这些程序使用操作系统来完成工作。

图 1-1 给出了这里所讨论的主要部件的一个简化视图。图的底部是硬件。硬件包括芯片、电路板、磁盘、键盘、显示器以及类似的设备。在硬件的顶部是软件。多数计算机有两种运行模式：内核态和用户态。软件中最基础的部分是操作系统，它运行在**内核态**（也称为**管态**、**核心态**）。在这个模式中，操作系统具有对所有硬件的完全访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在**用户态**下。在用户态下，只使用了机器指令中的一个子集。特别地，那些会影响机器的控制或可进行 **I/O**（输入/输出）操作的指令，在用户态中的程序里是禁止的。在本书中，我们会不断地讨论内核态和用户态之间的差别，这些差别在操作系统的运作中扮演着极其重要的角色。

<div align=center>
	<img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E5%9B%BE1.jpg"/>
</div>

用户接口程序（shell 或者 GUI）处于用户态程序中的最低层次，允许用户运行其他程序，诸如 Web 浏览器、电子邮件阅读器或音乐播放器等。这些程序也大量使用操作系统。

操作系统所在的位置如图 1-1 所示。它运行在裸机之上，为所有其他软件提供基础的运行环境。

操作系统和普通软件（用户态）之间的主要区别是，如果用户不喜欢某个特定的电子邮件阅读器，他可以自由选择另一个，或者自己写一个，但是不能自行写一个属于操作系统一部分的时钟中断处理程序。这个程序由硬件保护，防止用户试图对其进行修改。

然而，有时在嵌入式系统（该系统没有内核态）或解释系统（如基于 Java 的操作系统，它采用解释方式而非硬件方式区分组件）中，上述区别是模糊的。

另外，在许多系统中，一些在用户态下运行的程序协助操作系统完成特权功能。例如，经常有一个程序供用户修改其口令之用。但是这个程序不是操作系统的一部分，也不在内核态下运行，不过它明显地带有敏感的功能，并且必须以某种方式给予保护。在某些系统中，这种想法被推向了极致，一些传统上被认为是操作系统的部分（诸如文件系统）在用户空间中运行。在这类系统中，很难划分出一条明显的界限。在内核态中运行的当然是操作系统的一部分，但是一些在内核外运行的程序也有争议地被认为是操作系统地一部分，或者至少与操作系统密切相关。



#### 1.1	什么是操作系统

很难给出操作系统的准确定义。操作系统是一种运行在内核态的软件——尽管这个说法并不总是符合事实。部分原因是操作系统有两个基本上独立的任务，即为应用程序员（实际上是应用程序）提供一个资源集的清晰抽象，并管理这些硬件资源，而不仅仅是一堆硬件。另外，还取决于从什么角度看待操作系统。读者多半听说过其中一个或另一个的功能。下面我们逐项进行讨论。



##### 1.1.1	作为扩展机器的操作系统

在机器语言一级上，多数计算机的体系结构（指令集、存储组织、I/O 和总线结构）是很原始的，而且编程是很困难的，尤其是对输入/输出操作而言。为了更细致地考察这一点。我们以大多数电脑使用的更现代的 **SATA**（Serial ATA）硬盘为例。曾有一本描述早期版本硬盘接口（程序员为了使用硬盘而需要了解的东西）的书，它的页数超过 450 页。自 2007 年起，接口又被修改过很多次，因而比当时更加复杂。显然，没有任何理智的程序员想要在硬件层面上和硬盘打交道。相反，他们使用一些叫做**硬盘驱动**（disk driver）的软件来和硬件交互。这类软件提供了读写硬盘块的接口，而不用深入细节。操作系统包含很多用于控制输入/输出设备的驱动。

但就算是在这个层面，对于大多数应用来说还是太底层了。因此，所有的操作系统都提供使用硬盘的又一层抽象：文件。使用该抽象，程序能创建、读写文件，而不用处理硬件实际工作中那些恼人的细节。

抽象是管理复杂性的一个关键。好的抽象可以把一个几乎不可能管理的任务划分成为两个可管理的部分。其第一部分是有关抽象的定义和实现，第二部分是随时用这些抽象解决问题。几乎每个计算机用户都理解的一个抽象是文件，正如上文所提到的。文件是一种有效的信息片段，诸如数码照片、保存的电子邮件、歌曲或 Web 页面等。处理数码照片、电子邮件、歌曲以及 Web 页面等，要比处理 SATA（或者其他）硬盘的细节容易，这些磁盘的具体细节与前面叙述过的软盘一样。操作系统的任务是创建好的抽象，并实现和管理它所创建的抽象对象。本书中，我们将研究许多关于抽象的内容，因为这是理解操作系统的关键。

上述观点是非常重要的，所以值得用不同的表达方式来再次叙述。即使怀着如此小心翼翼对设计 Macintosh 机器的工业设计师的尊重，还是不得不说，硬件是丑陋的。真实的处理起、内存条、磁盘和其他装置都是非常复杂的，对于那些为使用某个硬件而不得不编写软件的人们而言，他们使用的是困难、特殊和不一致的接口。有时这是由于需要兼容旧的硬件，有时是为了节省成本，但是，有时硬件设计师们并没有意识到（或在意）他们给软件设计带来了多大的麻烦。操作系统的一个主要任务是隐藏硬件，呈现给程序（以及程序员）良好、清晰、优雅、一致的抽象。如图 1-2 所示，操作系统将丑陋转变为美丽。

<div align=center>
	<img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E5%9B%BE2.jpg"/>
</div>

需要指出的是，操作系统的实际客户是应用程序（当然是通过应用程序员）。它们直接与操作系统及其抽象打交道。相反，最终用户与用户接口所提供的抽象打交道，或者是命令行 shell 或者是图形接口。而用户接口的抽象可以与操作系统提供的抽象类似，但也不总是这样。为了更清晰地说明这一点，请读者考虑普通的 Windows 桌面以及面向行的命令提示符。两者都是运行在 Windows 操作系统上的程序，并使用了 Windows 提供的抽象，但是它们提供了非常不同的用户接口。类似地，运行 Gnome 或者 KDE 的 Linux 用户与直接在 X Window 系统（面向文本）顶部工作的 Linux 用户看到的是非常不同的界面，但是在这两种情形中，操作系统下面的抽象是相同的。

在本书中，我们将具体讨论提供给应用程序的抽象，不过很少涉及用户界面。尽管用户界面是一个巨大和重要的课题，但是它们毕竟只和操作系统的外围相关。



##### 1.1.2	作为资源管理者的操作系统

把操作系统看做向应用程序提供基本抽象的概念，是一种自顶向下的观点。按照另一种自底向上的观点，操作系统则用来管理一个复杂系统的各个部分。现代计算机包含处理器、存储器、时钟、磁盘、鼠标、网络接口、打印机以及许多其他设备。从这个角度看，操作系统的任务是在相互竞争的程序之间有序地控制对处理器、存储器以及其他 I/O 接口设备的分配。

现代操作系统允许同时在内存中运行多道程序。假设在一台计算机上运行的三个程序试图同时在同一台打印机上输出计算结果，那么开始的几行可能是程序 1 的输出，接着几行是程序 2 的输出，然后又是程序 3 的输出等，最终结果将是一团糟。采用将打印结果送到磁盘上缓冲区的方法，操作系统可以把潜在的混乱有序化。在一个程序结束后，操作系统可以将暂存在磁盘上的文件送到打印机输出，同时其他程序可以继续产生更多的输出结果，很明显，这些程序的输出还没有真正送至打印机。

当一个计算机（或网络）有多个用户时，管理和保护存储器、I/O 设备以及其他资源的需求变得强烈起来，因为用户间可能会互相干扰。另外，用户通常不仅共享硬件，还要共享信息（文件、数据库等）。简而言之，操作系统的这种观点认为，操作系统的主要任务是记录哪个程序在使用什么资源，对资源请求进行分配，评估使用代价，并且为不同的程序和用户调解互相冲突的资源请求。

资源管理包括用以下两种不同方式实现**多路复用**（共享）资源：在时间上复用和在空间上复用。当一种资源在时间上复用时，不同的程序或用户轮流使用它。先是第一个获得资源的使用，然后下一个，以此类推。例如，若在系统中只有一个 CPU，而多个程序需要在该 CPU 上运行，操作系统则首先把该 CPU 分配给某个程序，在它运行了足够长的时间之后，另一个程序得到 CPU，然后是下一个，如此进行下去，最终，轮到第一个程序再次运行。至于资源是如何实现时间复用的——谁应该是下一个以及运行多长时间等——则是操作系统的任务。还有一个有关时间复用的例子是打印机的共享。当多个打印作业在一台打印机上排队等待打印时，必须决定将轮到打印的是哪个作业。

另一类复用是空间复用，每个客户都得到资源的一部分，从而取代了客户排队。例如，通常在若干运行程序之间分割内存，这样每一个运行程序都可同时入驻内存（例如，为了轮流使用 CPU）。假设有足够的内存可以存放多个程序，那么在内存中同时存放若干个程序的效率，比把所有内存都分给一个程序的效率要高得多，特别是，如果一个程序只需要整个内存的一小部分，结果更是这样。当然，如此的做法会引起公平、保护等问题，这有赖于操作系统解决它们。有关空间复用的其他资源还有磁盘。在许多系统中，一个磁盘同时为许多用户保存文件。分配磁盘空间并记录谁正在使用哪个磁盘块，是操作系统的典型任务。



#### 1.2	操作系统的历史

**批处理系统**（batch system）。其思想是：在输入室收集全部的作业，然后用一台相对便宜的计算机如 IBM 1401 计算机将它们读到磁带上。IBM 1401 计算机适用于读卡片、复制磁带和输出打印，但不适用于数值运算。另外用较昂贵的计算机如 IBM 7094 来完成真正的计算。这些情况如图 1-3 所示。

<div align=center>
	<img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E5%9B%BE2.jpg"/>
</div>

**多道程序设计**（multiprogramming）。在 7094 机上，若当前作业因等待磁盘或其他 I/O 操作而暂停，CPU 就只能简单地踏步直至该 I/O 完成。对于 CPU 操作密集地科学计算问题，I/O 操作较少，因而浪费地时间很少。然而，对于商业数据处理，I/O 操作等待地时间通常占到 80%~90%，所以必须采取某种措施减少（昂贵的）CPU 空闲时间的浪费。

<div align=center>
	<img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E5%9B%BE3.jpg"/>
</div>

解决方案是将内存分为几个部分，每一部分存放不同的作业，如图 1-5 所示。当一个作业等待 I/O 操作完成时，另一个作业可以使用 CPU。如果内存中可以同时存放足够多的作业，则 CPU 利用率可以接近 100%。在内存中同时驻留多个作业需要特殊的硬件来对其进行保护，以避免作业的信息被窃取或受到攻击。360 及其他第三代计算机都配有此类硬件。



**分时系统（timesharing）**：它实际上是多道程序的一个变体，每个用户都有一个联机终端。在分时系统中，假设有 20 个用户登录，其中 17 个在思考、讨论或喝咖啡，则 CPU 可分派给其他三个需要的作业轮流执行。由于调式程序的用户常常只发出简短的命令（如编译一个五页的源文件），而很少有长的费时命令（比如上百万条的文件排序），所以计算机能够为许多用户提供快速的交互时服务，同时在 CPU 空闲时还可能在后台运行一个大作业。第一个通用的分时系统——**兼容分时系统**（Compatible Time Sharing System，CTSS），是 MIT在一台改装过的 7094 机上开发成功的。但直到第三台计算机广泛采用了必需的保护硬件之后，分时系统才逐渐流行开来。



**POSIX**：IEEE 提出的 UNIX 的标准。posix 定义了一个凡是 UNIX 必须支持的小型系统调用接口。事实上，某些其他操作系统也支持 POSIX 接口。



**x86**：在本书中我们使用 **x86** 则会个术语代表所有使用指令集体系结构家族的现代处理器。



**网络操作系统**和**分布式操作系统**：在网络操作系统中，用户知道多台计算机的存在，能够登录到一台远程机器上并将文件从一台机器复制到另一台机器，每台计算机都运行自己本地的操作系统，并有自己的本地用户（或多个用户）。

网络操作系统与单处理器的操作系统没有本质区别。很明显，它们需要一个网络接口控制器以及一些底层软件来驱动它，同时还需要一些程序来运行远程登录和远程文件访问，但这些附加成分并未改变操作系统的本质。

相反，分布式操作系统是以一种传统单处理器操作系统的形式出现在用户面前的，尽管它实际上是由多处理器组成的。用户应该不知晓自己的程序在何处运行或者自己的文件存放于何处，这些应该由操作系统自动和有效地处理。

真正的分布式操作系统不仅仅是在单机操作系统上增添一小段代码，因为分布式系统与集中式系统有本质的区别。例如，分布式系统通常允许一个应用在多台处理器上同时运行，因此，需要更复杂的处理器调度算法来获得最大的并行度优化。

网络中的通信延迟往往导致分布式赛算法必须能适应信息不完备、信息过时甚至信息不正确的环境。这与单机系统完全不同，对于后者，操作系统掌握着整个系统的完备信息。





#### 1.3	计算机硬件简介

操作系统与运行该操作系统的计算机硬件联系密切。操作系统扩展了计算机指令并管理计算机的资源。为了能够工作，操作系统必须了解大量的硬件，至少需要了解硬件如何面对程序员。处于这个原因，这里我们先简要地介绍现代个人计算机中的计算机硬件，然后开始讨论操作系统的具体工作细节。

从概念上讲，一台简单的个人计算机可以抽象为类似于图 1.6 中的模型。CPU、内存以及 I/O 设备都由一条系统总线连接起来并通过总线与其他设备通信。现代个人计算机结构更加复杂，包含多重总线，我们将在后面讨论。目前，这一模式还是够用的。在下面葛小姐中，我们将简要地介绍这些部件，并且讨论一些操作系统设计师所考虑的硬件问题。毫无疑问，这是一个非常简要的概括介绍。

<div align=center>
	<img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E5%9B%BE4.jpg"/>
</div>





##### 1.3.1	处理器

计算机的 “大脑” 是 CPU，它从内存中取出指令并执行之。在每个 CPU 基本周期中，首先从内存中取出指令，解码以确定其类型和操作数，接着执行之，然后取值、解码并执行下一条指令。按照这一方式，程序被执行完成。

每个 CPU 都有一套可执行的专门指令集。所以，X86 处理器不能执行 ARM 程序，而 ARM 处理器也不能执行 x86 程序。**由于用来访问内存以得到指令或数据的时间要比执行指令花费的时间长得多，因此，所有的 CPU 内都有一些用来保存关键变量和临时数据的寄存器**。这与，通常在指令集中提供一些指令，用以将一个字从内存调入寄存器，以及将一个字从寄存器存入内存。其他得指令可以把来自寄存器、内存的操作数组合，或者用两者产生一个结果，如将两个字相加并把结果存在寄存器或内存中。

除了用来保存变量和临时结果的通用寄存器之外，多数计算机还有一些对程序员可见的专用寄存器，其中之一是**程序计数器**（IP），它保存了将要取出的下一条指令的内存地址。在指令取出之后，程序计数器就被更新以便指向后继的指令。

另一个寄存器是**堆栈指针**（SP），它指向内存中当前栈的顶端。该栈包含了每个执行过程的栈帧。一个过程的栈帧中保存了有关的输入参数、局部变量以及那些没有保存在寄存器中的临时变量。

当然还有**程序状态字**（Program Status Word，PSW）寄存器。这个寄存器包含了条件码位（由比较指令设置）、CPU 优先级、模式（用户态或内核态），以及各种其他控制位。用户程序通常读入整个 PSW，但是，只对其中的少量字段写入。在系统调用和 I/O 中，PSW 的作用很重要。

操作系统必须知晓所有的寄存器。在时间多路复用（time multiplexing）CPU 中，操作系统经常会中止正在运行的某个程序并启动（或再启动）另一个程序。每次停止一个运行着的程序时，操作系统必须保存所有的寄存器值，这样在稍后该程序被再次运行时，可以把这些寄存器重新装入。

为了改善性能，CPU 设计师早就放弃了同时读取、解码和执行一条指令的简单模型。许多现代 CPU 具有同时取出多条指令的机制。例如，一个 CPU 可以有单独的取指单元、解码单元和执行单元，于时当它执行指令 n 时，还可以同时对指令 n+1 解码，并且读取指令 n+2。这与的机制称为**流水线**（pipeline），图 1-7a 是一个有着三个阶段的流水线示意图。更长的流水线也是常见的。在多数的流水线设计中，一旦一条指令被取进流水线中，它就必须被执行完毕，即便前一条取出的指令是条件转移，它也必须被执行完毕。流水线使得编译器和操作系统的编写者很头疼，因为它造成了在机器中实现这些软件的复杂性问题，而机器必须处理这些问题。

<div align=center>
	<img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E5%9B%BE5.jpg"/>
</div>



比流水线更先进的设计是**超标量** CPU，如图 1-7b 所示。在这种设计中，有多个执行单元，例如，一个 CPU 用于整数算术运算，一个 CPU 用于浮点算术运算，一个 CPU 用于布尔运算。两个或更多的指令被同时取出、解码并装入暂存缓冲区中，直至它们执行完毕。只要有一个执行单元空闲，就检查保持缓冲区中是否还有可处理的指令，如果有，就把指令从缓冲区中移出并执行之。这种设计存在一种隐含的作用，即程序的指令经常不按顺序执行。在多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同，但是，仍然有部分令人烦恼的复杂情形被强加给操作系统处理，我们在后面会讨论这种情况。

除了用在嵌入式系统中的非常简单的 CPU 之外，多数 CPU 都有两种模式，即前面已经提及的内核态和用户态。通常，在 PSW 中有一个二进制位控制这两种模式。当在内核态运行时，CPU 可以执行指令集中的每一条指令，并且使用硬件的每种功能。在台式机和服务器上，操作系统在内核态下运行，从而可以访问整个硬件。而在大多数嵌入式系统中，一部分操作系统运行在内核态，其余的部分则运行在用户态。

相反，用户程序在用户态下运行，仅允许执行整个指令集的一个子集和访问所有功能的一个子集。一般而言，在用户态中有关 I/O 和内存保护的所有指令是禁止的。当然，将 PSW 中的模式位设置成内核态也是禁止的。

为了从操作系统中获得服务，用户程序必须使用**系统调用**（system call）以陷入内核并调用操作系统。TRAP 指令把用户态切换成内核态，并启用操作系统。当有关工作完成之后，在系统调用后面的指令把控制权返回给用户程序。在本章的后面我们将具体解释系统调用过程，但是在这里，请读者把它看成是一个特别的过程调用指令，该指令具有从用户态切换到内核态的特别能力。

有必要指出的是，计算机使用陷阱而不是一条指令来执行系统调用。其他的多数陷阱是由硬件引起的，用于警告有异常情况发生，如试图被零除或浮点下溢等。在所有的情况下，操作系统都得到控制权并决定如何处理异常情况。有时，由于出错的原因，程序不得不停止。在其他情况下可以忽略出错（如下溢数可以被置为零）。最后，若程序已经提前宣布它希望处理某类条件，那么控制权还必须返回给该程序，让其处理相关的问题。



**多线程和多核芯片**

Intel Pentium 4 引入了被称为**多线程**（multithreading）或**超线程**（hyperthreading，这是 Intel 公司的命名）的特性，x86 处理器和其他一些 CPU 芯片就是这样做的，包括 SPARC、Power5、Intel Xeon 和 Intel Core 系列。近似地说，多线程允许 CPU 保持两个不同的线程状态，然后在纳秒级的时间尺度内来回切换。（线程是一种轻量级进程，即一个运行中的程序。我们将在第 2 章中具体讨论。）例如，如果某个进程需要从内存中读出一个字（需要花费多个时钟周期），多线程 CPU 则可以切换至另一个线程。多线程不提供真正的并行处理。在一个时刻只有一个进程在运行，但是线程的切换时间则减少到纳秒数量级。

多线程对操作系统而言是有意义的，因为每个线程在操作系统看来就像是单个的 CPU。考虑一个实际有两个 CPU 的系统，每个 CPU 有两个线程。这样操作系统将把它看成是 4 个 CPU。如果在某个特定时间点上，只有能够维持两个 CPU 忙碌的工作量，那么在同一个 CPU 上调度两个线程，而让另一个 CPU 完全空转，就没有优势了。这种选择远远不如在每个 CPU 上运行一个线程的效率高。



##### 1.3.2	存储器

在任何一种计算机中，第二种主要部件都是存储器。在理想情形下，存储器应该极为迅速（快于执行一条指令，这样 CPU 不会受到存储器的限制），充分大，而且非常便宜。但是目前的计数无法同时满足这三个目标，于是出现了不同的处理凡是。存储器系统采用一种分层次的机构，如图 1-9 所示。顶层的存储器速度较高，容量较小，与底层的存储器相比每位成本较高，其差别往往是十亿数量级。

<div align=center>
	<img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E5%9B%BE6.jpg"/>
</div>



存储器系统的顶层是 CPU 中的寄存器。它们用与 CPU 相同的材料制成，所以和 CPU 一样快。显然，访问它们是没有时延的。其典型的存储容量是，在 32 位 CPU 中为 32×32 位，而在 64 位 CPU 中为 64×64 位。在这两种情形下，其存储容量都小于 1KB。程序必须在软件中自行管理这些寄存器（即决定如何使用它们）。

































































































































































































































































































































































































































































































































































































