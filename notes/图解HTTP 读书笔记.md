## 图解HTTP 读书笔记

#### 第 1 章	了解 Web 及网络基础

<div align="center"> <img src="https://raw.githubusercontent.com/BufferedStream/cs-learning-notes/master/notes/images/%E5%9B%BE%E8%A7%A3HTTP%20-%20%E5%9B%BE1.jpg"/> </div><br>
URI 是 Uniform Resource Identifier 的缩写，表示统一资源标识符。URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集。





#### 第 2 章	简单的 HTTP 协议

HTTP 协议用于客户端和服务器之间的通信。

请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器端。



[HTTP为什么要设计成无状态的，这样比有状态有什么好处，有哪些协议是典型的有状态，好处又在哪里？](https://www.zhihu.com/question/265610863)

首先，要定义一下什么叫【无状态】。 假设用户A向服务B发了一个请求1，再次发送一个请求2。 服务端本身完全不知道两个请求来自同一个用户，这在协议层次就是【无状态】的。

【无状态】设计不是因为xx所说的历史原因，而是故意为之。无状态就意味着服务端可以根据需要将请求分发到集群的任何一个节点，对缓存、负载均衡有明显的好处，这一点很容易找到相关文献。

很多人对【无状态】感到不理解，大部分情况是误解了【无状态】的含义。http【无状态】仅仅是在***协议层\***，当业务需要状态的时候，可以通过request中数据携带所需状态的id来实现。例如，为了让服务器知道是同一个用户的请求，请求1和请求2中必须携带一个相同的id，让服务端可以根据这个id，最终找到用户数据（【状态】）。

实现1：这个状态如果放在处理请求的服务器进程中（例如session），那服务器进程就是有状态的，该用户下一个请求如果没分发到这个进程，就会拿不到上一次请求留下的状态，这样会影响负载均衡和缓存的实现。

实现2：这个状态如果放在处理请求的服务器进程之外的集中式存储，那服务器进程仍然是无状态的，可以集群、负载均衡。无状态服务一般都用这种方案。

最后我的观点是：无状态和有状态服务适合不同的场景，并没有绝对的优劣。



##### 告知服务器意图的 HTTP 方法

**GET**：	获取资源

GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回：如果是像 CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。



**POST**：	传输实体主体

POST 方法用来传输实体的主体。

虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取响应的主题内容。



**PUT**：	传输文件

PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。

但是，鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的 Web 网站不使用该方法。若配置 Web 应用程序的验证机制，或架构设计采用 RESR（REpresentational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使用 PUT 方法。



**HEAD**：	获得报文首部

HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。



**DELETE**：	删除文件

DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。

但是，HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机制，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的。



**OPTIONS**：	询问支持的方法

OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。



**TRACE**：	追踪路径

TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。

发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器端就将改数字减 1，当数值刚好减到 0 时，就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。

客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改/篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转的，TRACE 方法就是用来确认连接过程中发生的一系列操作。

但是，TRACE 方法本来就不怎么常用，再加上它很容易引发 XST（Corss-Site Tracing，跨站追踪）攻击，通常就更不会用到了。



**CONNECT**：	要求用隧道协议连接代理

CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。



[post 相比get 有很多优点，为什么现在的HTTP通信中大多数请求还是使用get？](https://www.zhihu.com/question/31640769)

[GET 和 POST 到底有什么区别？](https://www.zhihu.com/question/28586791)



这个问题虽然看上去很初级，但实际上却涉及到方方面面，这也就是为啥面试里老爱问这个的原因之一。

HTTP 最早被用来做浏览器与服务器之间交互 HTML 和表单的通讯协议；后来又被被广泛的扩充到接口格式的定义上。所以在讨论 GET 和 POST 区别的时候，需要先确定下到底是浏览器使用的 GET/POST 还是用 HTTP 作为接口传输协议的场景。



**浏览器的GET和POST**

这里特指浏览器中**非** Ajax 的 HTTP 请求，即从 HTML 和浏览器诞生就一直使用的 HTTP 协议中的 GET/POST。浏览器用 GET 请求来获取一个 html 页面/图片/css/js 等资源；用 POST 来提交一个 form 表单，并得到一个结果的网页。

浏览器将 GET 和 POST 定义为：



**GET**

“读取” 一个资源。比如 Get 到一个 html 文件。反复读取不应该对访问的数据有副作用。比如 “GET 一下，用户就下单了，返回订单已受理。”，这是不可接受的。没有副作用被称为 “幂等”（Idempotent）。

因为 GET 是读取，就可以对 GET 请求的数据做缓存。这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如 nginx），或者做到 server 端（用 Etag，至少可以减少带宽消耗）。

GET 的 URL 会被放在浏览器历史和 WEB 服务器日志里面。



**POST**

在页面里 form 标签会定义一个表单。单击其中的 submit 元素会发出一个 POST 请求让服务器做一件事。这件事往往是有副作用的，不幂等的。

不幂等也就意味着不能随意多次执行。因此也就不能缓存。比如通过 POST 下一个单，服务器创建了新的订单，然后返回订单成功的页面。这个页面不能被缓存。试想一下，如果 POST 请求被浏览器缓存了，那么下单请求就可以不向服务器发请求，而直接返回本地缓存的 “下单成功界面”，却又没有真的在服务器下单。那是一件多么滑稽的事情。

因为 POST 可能有副作用，所以浏览器实现为不能把 POST 请求保存为书签。想想，如果点一下书签就下一个单，是不是很恐怖？

此外如果尝试重新执行 POST 请求，浏览器也会弹一个框提示下这个刷新可能会有副作用，询问要不要继续。

当然，服务器的开发者完全可以把 GET 实现为有副作用；把 POST 实现为没有副作用。只不过这和浏览器的预期不符。**把 GET 实现为有副作用是个很可怕的事情**。我依稀记得很久之前百度贴吧因为有一个因为使用 GET 请求可以修改管理员的权限而造成的安全漏洞。反过来，把没有副作用的请求用 POST 实现，浏览器该弹框还是会弹框，对用户体验感改善不大。

但是后边可以看到，将 HTTP POST 作为接口的形式使用时，就没有这种弹框了。于是把一个 POST 请求实现为幂等就有实际的意义。POST 幂等能让很多业务的前后端交互更顺畅，以及避免一些因为前端 bug，触控失误等带来的重复提交。将一个有副作用的操作实现为幂等必须得从业务上能定义出怎么算是 “重复”。如提交数据中增加一个 dedupKey 在一个交易会话中有效，或者利用提交的数据里可以天然当 dedupKey 的字段。这样万一用户强行重复提交，服务器端可以做一次防护。

GET 和 POST 携带数据的格式也有区别。当浏览器发出一个 GET 请求时，就意味着要么是用户自己在浏览器的地址栏输入，要不就是点击了 html 里 a 标签的 href 中的 url。所以其实并不是 GET 携带数据只能用 url，而是浏览器直接发出的 GET 只能由一个 url 触发。所以没办法，GET 上要在 url 之外带一些参数就只能依靠 url 上附带 querystring。但是 HTTP 协议本身并没有这个限制。

浏览器的 POST 请求都来自表单提交。每次提交，表单的数据被浏览器用编码加到 HTTP 请求的 body 里。浏览器发出的 POST 请求的 body 主要有两种格式，一种是 application/x-www-form-urlencoded 用来传输简单的数据，大概就是 “key1=value1&key2=value2” 这样的格式。另外一种是传文件，会采用 multipart/form-data 格式。采用后者是因为 application/x-ww-from-urlencoded 的编码方式对于文件这种二进制的数据非常低效。

浏览器在 POST 一个表单时，url 上也可以带参数，只要  <form action="url"> 里的 url 带 querystring 就行。只不过表单里面的那些用 input 等标签经过用户操作产生的数据都会在 body 里。

因此我们一般会泛泛的说 “GET 请求没有 body，只有 url，请求数据放在 url 的 querystring 中；POST 请求的数据在 body 中”。但这种情况仅限于浏览器发请求的场景。



**接口中的 GET 和 POST**

这里是指通过浏览器的 Ajax api，或者 IOS/Android 的 App 的 http client，java 的 commons-httpcliet/okhttp 或者是 curl，postman 之类的工具发出来的 GET 和 POST 请求。此时 GET/POS 不光能用在前端和后端的交互中，还能用在后端各个子服务的调用中（即当一种 RPC 协议使用）。尽管 RPC 有很多协议，比如 thrift，grpc，但是 http 本身已经有大量的现成的支持工具可以使用，并且对人类很友好，容易 debug。HTTP 协议在微服务中的使用是相对普遍的。

当用 HTTP 实现接口发送请求时，就没有浏览器中那么多限制了，只要是符合 HTTP 格式的就可以发。HTTP 请求的格式，大概是这样的一个字符串（为了美观，我在\r\n后都换行一下）：

```http
<METHOD> <URL> HTTP/1.1\r\n
<Header1>: <HeaderValue1>\r\n
<Header2>: <HeaderValue2>\r\n
...
<HeaderN>: <HeaderValueN>\r\n
\r\n
<Body Data....>
```

其中的 ”<METHOD>“ 可以是 GET 也可以是 POST，或者其他的 HTTP Method，如 PUT、DELETE、OPTION......。从协议本身看，并没有限制说 GET 一定不能没有 body，POST 就一定不能把参数放到 <URL> 的 querystring 上。因此其实可以更加自由的去利用格式。比如 Elastic Search 的 _search api 就用了带 body 的 GET；也可以自己开发接口让 POST 一半的参数放在 url 的 querystring 里，另外一半放 body 里；你甚至还可以让所有的参数都放在 Header 里——可以做各种各样的定制，只要请求的客户端和服务器端都能够约定好。

当然，太自由也带来了另一种麻烦，开发人员不得不每次讨论确定参数是放 url 的 path 里，querystring 里，body 里，header 里这种问题，太低效了。于是就有了一些列接口规范/风格。其中名气最大的当属 REST。REST 充分使用 GET、POST、PUT 和 DELETE，约定了这 4 个接口分别获取、创建、替换和删除 ”资源“，REST 最佳实践还推荐在请求体使用 json 格式。这样仅仅通过看 HTTP 的 method 就可以明白接口是什么意思，并且解析格式也得到了统一。

json 相对于 x-www-from-urlencoded 的优势在于 1）可以有嵌套结构；以及 2）可以支持更丰富的数据类型。通过一些框架，json 可以直接被服务器代码映射为业务实体。用起来十分方便。但是如果是写一个接口支持上传文件，那么还是 multipart/form-data 格式更合适。

REST 中 GET 和 POST 不是随便用的。在 REST 中，【GET】 + 【资源定位符】被专用于获取资源或者资源列表，比如：

```http
GET http://foo.com/books          获取书籍列表
GET http://foo.com/books/:bookId  根据bookId获取一本具体的书
```

与浏览器的场景类似，REST GET 也不应该有副作用，于是可以被反复无脑调用。浏览器（包括浏览器的 Ajax 请求）对于这种 GET 也可以实现缓存（如果服务器端提示了明确需要 Caching）；但是如果用非浏览器，有没有缓存完全看客户端的实现了。当然，也可以从整个 App 角度，也可以完全绕开非浏览器的缓存机制，实现一套业务定制的缓存框架。

REST 【POST】 + 【资源定位符】则用于 ”创建一个资源“，比如：

```text
POST http://foo.com/books
{
  "title": "大宽宽的碎碎念",
  "author": "大宽宽",
  ...
}
```

这里你就能留意到浏览器中用来实现表单提交的 POST，和 REST 实现创建资源的 POST 语义上的不同。

顺便讲下 REST POST 和 REST PUT 的区别。有些 api 是使用 PUT 作为创建资源的 Method。PUT 与 POST 的区别在于，PUT 的实际语义是 ”replace“ replace。REST 规范里提到 PUT 的请求体应该是完整的资源，包括 id 在内。比如上面的创建一本书的 api 也可以定义为：

```text
PUT http://foo.com/books
{
  "id": "BOOK:affe001bbe0556a",
  "title": "大宽宽的碎碎念",
  "author": "大宽宽",
  ...
}
```

服务器应该先根据请求提供的 id 解析查找，如果存在一个对应 id 的元素，就用请求中的数据整体替换已经存在的资源；如果没有，就用 ”把这个 id 对应的资源从 【空】 替换为 【请求数据】“。直观看起来就是 ”创建“ 了。

与 PUT 相比，POST 更像是一个 “factory”，通过一组必要的数据创建出完整的资源。
至于到底用 PUT 还是 POST 创建资源，完全要看是不是提前可以知道资源所有的数据（尤其是 id），以及是不是完整替换。比如对于 AWS S3 这样的对象存储服务，当想上传一个新资源时，其 id就是 “ObjectName” 可以提前知道；同时这个 api 也总是完整的 replace 整个资源。这时的 api 用 PUT 的语义更合适；而对于那些 id 是服务器端自动生成的场景，POST 更合适一些。

有点跑题，就此打住。

回到接口这个主题，上面仅仅粗略介绍了 REST 的情况。但是现实中总是有 REST 的变体，也可能用非 REST 的协议（比如 JSON-RPC、SOAP 等），每种情况中的 GET 和 POST 又会有所不同。



**关于安全性**

我们常常听到 GET 不如 POST安全，因为 POST 用 bode 传输数据，而 GET 用 url 传输，更加容易看到。但是从攻击的角度，无论是 GET 还是 POST 都不够安全，因为 HTTP 本身是**明文协议**。**每个 HTTP 请求和返回的每个 byte 都会在网络上明文传播，不管是 url，header 还是 body**。这完全不是一个 ”是否容易在浏览器地址栏上看到“ 的问题。

为了避免传输中数据被窃取，必须做从客户端到服务器的端端加密。业界的通行做法就是 https——即用 SSL 协议协商出的密钥加密明文的 http 数据。这个加密的协议和 HTTP 协议本身相互独立。如果是利用 HTTP 开发公网的站点/App，要保证安全，https 是最最基本的要求。

当然，端端加密并不一定非得用 https。比如国内金融领域都会用私有网络，也有 GB 的加密协议 SM 系列。但除了军队，金融等特殊机构之外，似乎并没有必要自己发明一套类似于 ssl 的协议。

回到 HTTP 本身，的确 GET 请求的参数更倾向于放在 url 上，因此有更多机会被泄露。比如携带私密信息的 url 会展示在地址栏上，还可以分享给第三方，就非常不安全了。此外，从客户端到服务器端，有大量的中间节点，包括网关，代理等。他们的 access log 通常会输出完整的 url，比如 nginx 的默认 acces log 就是如此。如果 url 上携带敏感数据，就会被记录下来。但请注意，就算私密数据在 body 里，也是可以被记录下来的，因此如果请求要经过不信任的公网，避免泄密的唯一手段就是 https。这里说的 ”避免 acces log 泄露“ 仅仅是指避免可信区域中的 http 代理的默认行为带来的安全隐患。比如你是不太希望让自己公司的运维同学从公司主网关的 log 里看到用户的密码吧。





















